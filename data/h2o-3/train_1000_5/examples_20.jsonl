{"repo": "h2oai/h2o-3", "path": "py2/h2o_objects.py", "func_name": "H2O.stabilize", "original_string": "def stabilize(self, test_func, error, timeoutSecs=10, retryDelaySecs=0.5):\n        '''Repeatedly test a function waiting for it to return True.\n\n        Arguments:\n        test_func      -- A function that will be run repeatedly\n        error          -- A function that will be run to produce an error message\n                          it will be called with (node, timeTakenSecs, numberOfRetries)\n                    OR\n                       -- A string that will be interpolated with a dictionary of\n                          { 'timeTakenSecs', 'numberOfRetries' }\n        timeoutSecs    -- How long in seconds to keep trying before declaring a failure\n        retryDelaySecs -- How long to wait between retry attempts\n        '''\n        start = time.time()\n        numberOfRetries = 0\n        while h2o_args.no_timeout or (time.time() - start < timeoutSecs):\n            if test_func(self, tries=numberOfRetries, timeoutSecs=timeoutSecs):\n                break\n            time.sleep(retryDelaySecs)\n            numberOfRetries += 1\n            # hey, check the sandbox if we've been waiting a long time...rather than wait for timeout\n            # to find the badness?. can check_sandbox_for_errors at any time\n            if ((numberOfRetries % 50) == 0):\n                check_sandbox_for_errors(python_test_name=h2o_args.python_test_name)\n\n        else:\n            timeTakenSecs = time.time() - start\n            if isinstance(error, type('')):\n                raise Exception('%s failed after %.2f seconds having retried %d times' % (\n                    error, timeTakenSecs, numberOfRetries))\n            else:\n                msg = error(self, timeTakenSecs, numberOfRetries)\n                raise Exception(msg)", "language": "python", "code": "def stabilize(self, test_func, error, timeoutSecs=10, retryDelaySecs=0.5):\n        start = time.time()\n        numberOfRetries = 0\n        while h2o_args.no_timeout or (time.time() - start < timeoutSecs):\n            if test_func(self, tries=numberOfRetries, timeoutSecs=timeoutSecs):\n                break\n            time.sleep(retryDelaySecs)\n            numberOfRetries += 1\n            # hey, check the sandbox if we've been waiting a long time...rather than wait for timeout\n            # to find the badness?. can check_sandbox_for_errors at any time\n            if ((numberOfRetries % 50) == 0):\n                check_sandbox_for_errors(python_test_name=h2o_args.python_test_name)\n\n        else:\n            timeTakenSecs = time.time() - start\n            if isinstance(error, type('')):\n                raise Exception('%s failed after %.2f seconds having retried %d times' % (\n                    error, timeTakenSecs, numberOfRetries))\n            else:\n                msg = error(self, timeTakenSecs, numberOfRetries)\n                raise Exception(msg)", "code_tokens": ["def", "stabilize", "(", "self", ",", "test_func", ",", "error", ",", "timeoutSecs", "=", "10", ",", "retryDelaySecs", "=", "0.5", ")", ":", "start", "=", "time", ".", "time", "(", ")", "numberOfRetries", "=", "0", "while", "h2o_args", ".", "no_timeout", "or", "(", "time", ".", "time", "(", ")", "-", "start", "<", "timeoutSecs", ")", ":", "if", "test_func", "(", "self", ",", "tries", "=", "numberOfRetries", ",", "timeoutSecs", "=", "timeoutSecs", ")", ":", "break", "time", ".", "sleep", "(", "retryDelaySecs", ")", "numberOfRetries", "+=", "1", "# hey, check the sandbox if we've been waiting a long time...rather than wait for timeout", "# to find the badness?. can check_sandbox_for_errors at any time", "if", "(", "(", "numberOfRetries", "%", "50", ")", "==", "0", ")", ":", "check_sandbox_for_errors", "(", "python_test_name", "=", "h2o_args", ".", "python_test_name", ")", "else", ":", "timeTakenSecs", "=", "time", ".", "time", "(", ")", "-", "start", "if", "isinstance", "(", "error", ",", "type", "(", "''", ")", ")", ":", "raise", "Exception", "(", "'%s failed after %.2f seconds having retried %d times'", "%", "(", "error", ",", "timeTakenSecs", ",", "numberOfRetries", ")", ")", "else", ":", "msg", "=", "error", "(", "self", ",", "timeTakenSecs", ",", "numberOfRetries", ")", "raise", "Exception", "(", "msg", ")"], "docstring": "Repeatedly test a function waiting for it to return True.", "docstring_tokens": ["Repeatedly", "test", "a", "function", "waiting", "for", "it", "to", "return", "True", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/py2/h2o_objects.py#L293-L325", "partition": "test", "index": 1326, "time": "2014-11-08 20:41:05"}
{"repo": "h2oai/h2o-3", "path": "py2/h2o_ray.py", "func_name": "summary", "original_string": "def summary(self, key, column=\"C1\", timeoutSecs=10, **kwargs):\n    '''\n    Return the summary for a single column for a single Frame in the h2o cluster.  \n    '''\n    params_dict = { \n        # 'offset': 0,\n        # 'len': 100\n    }\n    h2o_methods.check_params_update_kwargs(params_dict, kwargs, 'summary', True)\n    \n    result = self.do_json_request('3/Frames.json/%s/columns/%s/summary' % (key, column), timeout=timeoutSecs, params=params_dict)\n    h2o_sandbox.check_sandbox_for_errors()\n    return result", "language": "python", "code": "def summary(self, key, column=\"C1\", timeoutSecs=10, **kwargs):\n    params_dict = { \n        # 'offset': 0,\n        # 'len': 100\n    }\n    h2o_methods.check_params_update_kwargs(params_dict, kwargs, 'summary', True)\n    \n    result = self.do_json_request('3/Frames.json/%s/columns/%s/summary' % (key, column), timeout=timeoutSecs, params=params_dict)\n    h2o_sandbox.check_sandbox_for_errors()\n    return result", "code_tokens": ["def", "summary", "(", "self", ",", "key", ",", "column", "=", "\"C1\"", ",", "timeoutSecs", "=", "10", ",", "*", "*", "kwargs", ")", ":", "params_dict", "=", "{", "# 'offset': 0,", "# 'len': 100", "}", "h2o_methods", ".", "check_params_update_kwargs", "(", "params_dict", ",", "kwargs", ",", "'summary'", ",", "True", ")", "result", "=", "self", ".", "do_json_request", "(", "'3/Frames.json/%s/columns/%s/summary'", "%", "(", "key", ",", "column", ")", ",", "timeout", "=", "timeoutSecs", ",", "params", "=", "params_dict", ")", "h2o_sandbox", ".", "check_sandbox_for_errors", "(", ")", "return", "result"], "docstring": "Return the summary for a single column for a single Frame in the h2o cluster.", "docstring_tokens": ["Return", "the", "summary", "for", "a", "single", "column", "for", "a", "single", "Frame", "in", "the", "h2o", "cluster", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/py2/h2o_ray.py#L347-L359", "partition": "test", "index": 1327, "time": "2014-11-09 00:05:08"}
{"repo": "h2oai/h2o-3", "path": "py2/h2o_ray.py", "func_name": "delete_model", "original_string": "def delete_model(self, key, ignoreMissingKey=True, timeoutSecs=60, **kwargs):\n    '''\n    Delete a model on the h2o cluster, given its key.\n    '''\n    assert key is not None, '\"key\" parameter is null'\n\n    result = self.do_json_request('/3/Models.json/' + key, cmd='delete', timeout=timeoutSecs)\n\n    # TODO: look for what?\n    if not ignoreMissingKey and 'f00b4r' in result:\n        raise ValueError('Model key not found: ' + key)\n\n    verboseprint(\"delete_model result:\", dump_json(result))\n    return result", "language": "python", "code": "def delete_model(self, key, ignoreMissingKey=True, timeoutSecs=60, **kwargs):\n    assert key is not None, '\"key\" parameter is null'\n\n    result = self.do_json_request('/3/Models.json/' + key, cmd='delete', timeout=timeoutSecs)\n\n    # TODO: look for what?\n    if not ignoreMissingKey and 'f00b4r' in result:\n        raise ValueError('Model key not found: ' + key)\n\n    verboseprint(\"delete_model result:\", dump_json(result))\n    return result", "code_tokens": ["def", "delete_model", "(", "self", ",", "key", ",", "ignoreMissingKey", "=", "True", ",", "timeoutSecs", "=", "60", ",", "*", "*", "kwargs", ")", ":", "assert", "key", "is", "not", "None", ",", "'\"key\" parameter is null'", "result", "=", "self", ".", "do_json_request", "(", "'/3/Models.json/'", "+", "key", ",", "cmd", "=", "'delete'", ",", "timeout", "=", "timeoutSecs", ")", "# TODO: look for what?", "if", "not", "ignoreMissingKey", "and", "'f00b4r'", "in", "result", ":", "raise", "ValueError", "(", "'Model key not found: '", "+", "key", ")", "verboseprint", "(", "\"delete_model result:\"", ",", "dump_json", "(", "result", ")", ")", "return", "result"], "docstring": "Delete a model on the h2o cluster, given its key.", "docstring_tokens": ["Delete", "a", "model", "on", "the", "h2o", "cluster", "given", "its", "key", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/py2/h2o_ray.py#L628-L641", "partition": "test", "index": 1333, "time": "2014-11-09 00:05:08"}
{"repo": "h2oai/h2o-3", "path": "py2/h2o_ray.py", "func_name": "model_metrics", "original_string": "def model_metrics(self, timeoutSecs=60, **kwargs):\n    '''\n    ModelMetrics list. \n    '''\n    result = self.do_json_request('/3/ModelMetrics.json', cmd='get', timeout=timeoutSecs)\n    h2o_sandbox.check_sandbox_for_errors()\n    return result", "language": "python", "code": "def model_metrics(self, timeoutSecs=60, **kwargs):\n    result = self.do_json_request('/3/ModelMetrics.json', cmd='get', timeout=timeoutSecs)\n    h2o_sandbox.check_sandbox_for_errors()\n    return result", "code_tokens": ["def", "model_metrics", "(", "self", ",", "timeoutSecs", "=", "60", ",", "*", "*", "kwargs", ")", ":", "result", "=", "self", ".", "do_json_request", "(", "'/3/ModelMetrics.json'", ",", "cmd", "=", "'get'", ",", "timeout", "=", "timeoutSecs", ")", "h2o_sandbox", ".", "check_sandbox_for_errors", "(", ")", "return", "result"], "docstring": "ModelMetrics list.", "docstring_tokens": ["ModelMetrics", "list", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/py2/h2o_ray.py#L592-L598", "partition": "test", "index": 1332, "time": "2014-11-09 00:05:08"}
{"repo": "h2oai/h2o-3", "path": "py2/h2o_ray.py", "func_name": "compute_model_metrics", "original_string": "def compute_model_metrics(self, model, frame, timeoutSecs=60, **kwargs):\n    '''\n    Score a model on the h2o cluster on the given Frame and return only the model metrics. \n    '''\n    assert model is not None, '\"model\" parameter is null'\n    assert frame is not None, '\"frame\" parameter is null'\n\n    models = self.models(key=model, timeoutSecs=timeoutSecs)\n    assert models is not None, \"/Models REST call failed\"\n    assert models['models'][0]['model_id']['name'] == model, \"/Models/{0} returned Model {1} rather than Model {2}\".format(model, models['models'][0]['key']['name'], model)\n\n    # TODO: test this assert, I don't think this is working. . .\n    frames = self.frames(key=frame)\n    assert frames is not None, \"/Frames/{0} REST call failed\".format(frame)\n    \n    print \"frames:\", dump_json(frames)\n    # is the name not there?\n    # assert frames['frames'][0]['model_id']['name'] == frame, \"/Frames/{0} returned Frame {1} rather than Frame {2}\".format(frame, models['models'][0]['key']['name'], frame)\n\n    result = self.do_json_request('/3/ModelMetrics.json/models/' + model + '/frames/' + frame, cmd='post', timeout=timeoutSecs)\n\n    mm = result['model_metrics'][0]\n    verboseprint(\"model metrics: \" + repr(mm))\n    h2o_sandbox.check_sandbox_for_errors()\n    return mm", "language": "python", "code": "def compute_model_metrics(self, model, frame, timeoutSecs=60, **kwargs):\n    assert model is not None, '\"model\" parameter is null'\n    assert frame is not None, '\"frame\" parameter is null'\n\n    models = self.models(key=model, timeoutSecs=timeoutSecs)\n    assert models is not None, \"/Models REST call failed\"\n    assert models['models'][0]['model_id']['name'] == model, \"/Models/{0} returned Model {1} rather than Model {2}\".format(model, models['models'][0]['key']['name'], model)\n\n    # TODO: test this assert, I don't think this is working. . .\n    frames = self.frames(key=frame)\n    assert frames is not None, \"/Frames/{0} REST call failed\".format(frame)\n    \n    print \"frames:\", dump_json(frames)\n    # is the name not there?\n    # assert frames['frames'][0]['model_id']['name'] == frame, \"/Frames/{0} returned Frame {1} rather than Frame {2}\".format(frame, models['models'][0]['key']['name'], frame)\n\n    result = self.do_json_request('/3/ModelMetrics.json/models/' + model + '/frames/' + frame, cmd='post', timeout=timeoutSecs)\n\n    mm = result['model_metrics'][0]\n    verboseprint(\"model metrics: \" + repr(mm))\n    h2o_sandbox.check_sandbox_for_errors()\n    return mm", "code_tokens": ["def", "compute_model_metrics", "(", "self", ",", "model", ",", "frame", ",", "timeoutSecs", "=", "60", ",", "*", "*", "kwargs", ")", ":", "assert", "model", "is", "not", "None", ",", "'\"model\" parameter is null'", "assert", "frame", "is", "not", "None", ",", "'\"frame\" parameter is null'", "models", "=", "self", ".", "models", "(", "key", "=", "model", ",", "timeoutSecs", "=", "timeoutSecs", ")", "assert", "models", "is", "not", "None", ",", "\"/Models REST call failed\"", "assert", "models", "[", "'models'", "]", "[", "0", "]", "[", "'model_id'", "]", "[", "'name'", "]", "==", "model", ",", "\"/Models/{0} returned Model {1} rather than Model {2}\"", ".", "format", "(", "model", ",", "models", "[", "'models'", "]", "[", "0", "]", "[", "'key'", "]", "[", "'name'", "]", ",", "model", ")", "# TODO: test this assert, I don't think this is working. . .", "frames", "=", "self", ".", "frames", "(", "key", "=", "frame", ")", "assert", "frames", "is", "not", "None", ",", "\"/Frames/{0} REST call failed\"", ".", "format", "(", "frame", ")", "print", "\"frames:\"", ",", "dump_json", "(", "frames", ")", "# is the name not there?", "# assert frames['frames'][0]['model_id']['name'] == frame, \"/Frames/{0} returned Frame {1} rather than Frame {2}\".format(frame, models['models'][0]['key']['name'], frame)", "result", "=", "self", ".", "do_json_request", "(", "'/3/ModelMetrics.json/models/'", "+", "model", "+", "'/frames/'", "+", "frame", ",", "cmd", "=", "'post'", ",", "timeout", "=", "timeoutSecs", ")", "mm", "=", "result", "[", "'model_metrics'", "]", "[", "0", "]", "verboseprint", "(", "\"model metrics: \"", "+", "repr", "(", "mm", ")", ")", "h2o_sandbox", ".", "check_sandbox_for_errors", "(", ")", "return", "mm"], "docstring": "Score a model on the h2o cluster on the given Frame and return only the model metrics.", "docstring_tokens": ["Score", "a", "model", "on", "the", "h2o", "cluster", "on", "the", "given", "Frame", "and", "return", "only", "the", "model", "metrics", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/py2/h2o_ray.py#L542-L566", "partition": "test", "index": 1331, "time": "2014-11-09 00:05:08"}
{"repo": "h2oai/h2o-3", "path": "py2/h2o_ray.py", "func_name": "validate_model_parameters", "original_string": "def validate_model_parameters(self, algo, training_frame, parameters, timeoutSecs=60, **kwargs):\n    '''\n    Check a dictionary of model builder parameters on the h2o cluster \n    using the given algorithm and model parameters.\n    '''\n    assert algo is not None, '\"algo\" parameter is null'\n    # Allow this now: assert training_frame is not None, '\"training_frame\" parameter is null'\n    assert parameters is not None, '\"parameters\" parameter is null'\n\n    model_builders = self.model_builders(timeoutSecs=timeoutSecs)\n    assert model_builders is not None, \"/ModelBuilders REST call failed\"\n    assert algo in model_builders['model_builders']\n    builder = model_builders['model_builders'][algo]\n    \n    # TODO: test this assert, I don't think this is working. . .\n    if training_frame is not None:\n        frames = self.frames(key=training_frame)\n        assert frames is not None, \"/Frames/{0} REST call failed\".format(training_frame)\n\n        key_name = frames['frames'][0]['key']['name']\n        assert key_name==training_frame, \\\n            \"/Frames/{0} returned Frame {1} rather than Frame {2}\".format(training_frame, key_name, training_frame)\n\n        parameters['training_frame'] = training_frame\n\n    # TODO: add parameter existence checks\n    # TODO: add parameter value validation\n\n    # FIX! why ignoreH2oError here?\n    result = self.do_json_request('/3/ModelBuilders.json/' + algo + \"/parameters\", cmd='post', \n        timeout=timeoutSecs, postData=parameters, ignoreH2oError=True, noExtraErrorCheck=True)\n\n    verboseprint(\"model parameters validation: \" + repr(result))\n    return result", "language": "python", "code": "def validate_model_parameters(self, algo, training_frame, parameters, timeoutSecs=60, **kwargs):\n    assert algo is not None, '\"algo\" parameter is null'\n    # Allow this now: assert training_frame is not None, '\"training_frame\" parameter is null'\n    assert parameters is not None, '\"parameters\" parameter is null'\n\n    model_builders = self.model_builders(timeoutSecs=timeoutSecs)\n    assert model_builders is not None, \"/ModelBuilders REST call failed\"\n    assert algo in model_builders['model_builders']\n    builder = model_builders['model_builders'][algo]\n    \n    # TODO: test this assert, I don't think this is working. . .\n    if training_frame is not None:\n        frames = self.frames(key=training_frame)\n        assert frames is not None, \"/Frames/{0} REST call failed\".format(training_frame)\n\n        key_name = frames['frames'][0]['key']['name']\n        assert key_name==training_frame, \\\n            \"/Frames/{0} returned Frame {1} rather than Frame {2}\".format(training_frame, key_name, training_frame)\n\n        parameters['training_frame'] = training_frame\n\n    # TODO: add parameter existence checks\n    # TODO: add parameter value validation\n\n    # FIX! why ignoreH2oError here?\n    result = self.do_json_request('/3/ModelBuilders.json/' + algo + \"/parameters\", cmd='post', \n        timeout=timeoutSecs, postData=parameters, ignoreH2oError=True, noExtraErrorCheck=True)\n\n    verboseprint(\"model parameters validation: \" + repr(result))\n    return result", "code_tokens": ["def", "validate_model_parameters", "(", "self", ",", "algo", ",", "training_frame", ",", "parameters", ",", "timeoutSecs", "=", "60", ",", "*", "*", "kwargs", ")", ":", "assert", "algo", "is", "not", "None", ",", "'\"algo\" parameter is null'", "# Allow this now: assert training_frame is not None, '\"training_frame\" parameter is null'", "assert", "parameters", "is", "not", "None", ",", "'\"parameters\" parameter is null'", "model_builders", "=", "self", ".", "model_builders", "(", "timeoutSecs", "=", "timeoutSecs", ")", "assert", "model_builders", "is", "not", "None", ",", "\"/ModelBuilders REST call failed\"", "assert", "algo", "in", "model_builders", "[", "'model_builders'", "]", "builder", "=", "model_builders", "[", "'model_builders'", "]", "[", "algo", "]", "# TODO: test this assert, I don't think this is working. . .", "if", "training_frame", "is", "not", "None", ":", "frames", "=", "self", ".", "frames", "(", "key", "=", "training_frame", ")", "assert", "frames", "is", "not", "None", ",", "\"/Frames/{0} REST call failed\"", ".", "format", "(", "training_frame", ")", "key_name", "=", "frames", "[", "'frames'", "]", "[", "0", "]", "[", "'key'", "]", "[", "'name'", "]", "assert", "key_name", "==", "training_frame", ",", "\"/Frames/{0} returned Frame {1} rather than Frame {2}\"", ".", "format", "(", "training_frame", ",", "key_name", ",", "training_frame", ")", "parameters", "[", "'training_frame'", "]", "=", "training_frame", "# TODO: add parameter existence checks", "# TODO: add parameter value validation", "# FIX! why ignoreH2oError here?", "result", "=", "self", ".", "do_json_request", "(", "'/3/ModelBuilders.json/'", "+", "algo", "+", "\"/parameters\"", ",", "cmd", "=", "'post'", ",", "timeout", "=", "timeoutSecs", ",", "postData", "=", "parameters", ",", "ignoreH2oError", "=", "True", ",", "noExtraErrorCheck", "=", "True", ")", "verboseprint", "(", "\"model parameters validation: \"", "+", "repr", "(", "result", ")", ")", "return", "result"], "docstring": "Check a dictionary of model builder parameters on the h2o cluster using the given algorithm and model parameters.", "docstring_tokens": ["Check", "a", "dictionary", "of", "model", "builder", "parameters", "on", "the", "h2o", "cluster", "using", "the", "given", "algorithm", "and", "model", "parameters", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/py2/h2o_ray.py#L410-L443", "partition": "test", "index": 1330, "time": "2014-11-09 00:05:08"}
{"repo": "h2oai/h2o-3", "path": "py2/h2o_ray.py", "func_name": "model_builders", "original_string": "def model_builders(self, algo=None, timeoutSecs=10, **kwargs):\n    '''\n    Return a model builder or all of the model builders known to the\n    h2o cluster.  The model builders are contained in a dictionary\n    called \"model_builders\" at the top level of the result.  The\n    dictionary maps algorithm names to parameters lists.  Each of the\n    parameters contains all the metdata required by a client to\n    present a model building interface to the user.\n\n    if parameters = True, return the parameters?\n    '''\n    params_dict = {}\n    h2o_methods.check_params_update_kwargs(params_dict, kwargs, 'model_builders', False)\n\n    request = '3/ModelBuilders.json' \n    if algo:\n        request += \"/\" + algo\n\n    result = self.do_json_request(request, timeout=timeoutSecs, params=params_dict)\n    # verboseprint(request, \"result:\", dump_json(result))\n    h2o_sandbox.check_sandbox_for_errors()\n    return result", "language": "python", "code": "def model_builders(self, algo=None, timeoutSecs=10, **kwargs):\n    params_dict = {}\n    h2o_methods.check_params_update_kwargs(params_dict, kwargs, 'model_builders', False)\n\n    request = '3/ModelBuilders.json' \n    if algo:\n        request += \"/\" + algo\n\n    result = self.do_json_request(request, timeout=timeoutSecs, params=params_dict)\n    # verboseprint(request, \"result:\", dump_json(result))\n    h2o_sandbox.check_sandbox_for_errors()\n    return result", "code_tokens": ["def", "model_builders", "(", "self", ",", "algo", "=", "None", ",", "timeoutSecs", "=", "10", ",", "*", "*", "kwargs", ")", ":", "params_dict", "=", "{", "}", "h2o_methods", ".", "check_params_update_kwargs", "(", "params_dict", ",", "kwargs", ",", "'model_builders'", ",", "False", ")", "request", "=", "'3/ModelBuilders.json'", "if", "algo", ":", "request", "+=", "\"/\"", "+", "algo", "result", "=", "self", ".", "do_json_request", "(", "request", ",", "timeout", "=", "timeoutSecs", ",", "params", "=", "params_dict", ")", "# verboseprint(request, \"result:\", dump_json(result))", "h2o_sandbox", ".", "check_sandbox_for_errors", "(", ")", "return", "result"], "docstring": "Return a model builder or all of the model builders known to the h2o cluster. The model builders are contained in a dictionary called \"model_builders\" at the top level of the result. The dictionary maps algorithm names to parameters lists. Each of the parameters contains all the metdata required by a client to present a model building interface to the user.", "docstring_tokens": ["Return", "a", "model", "builder", "or", "all", "of", "the", "model", "builders", "known", "to", "the", "h2o", "cluster", ".", "The", "model", "builders", "are", "contained", "in", "a", "dictionary", "called", "model_builders", "at", "the", "top", "level", "of", "the", "result", ".", "The", "dictionary", "maps", "algorithm", "names", "to", "parameters", "lists", ".", "Each", "of", "the", "parameters", "contains", "all", "the", "metdata", "required", "by", "a", "client", "to", "present", "a", "model", "building", "interface", "to", "the", "user", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/py2/h2o_ray.py#L386-L407", "partition": "test", "index": 1329, "time": "2014-11-09 00:05:08"}
{"repo": "h2oai/h2o-3", "path": "py2/h2o_ray.py", "func_name": "delete_frame", "original_string": "def delete_frame(self, key, ignoreMissingKey=True, timeoutSecs=60, **kwargs):\n    '''\n    Delete a frame on the h2o cluster, given its key.\n    '''\n    assert key is not None, '\"key\" parameter is null'\n\n    result = self.do_json_request('/3/Frames.json/' + key, cmd='delete', timeout=timeoutSecs)\n\n    # TODO: look for what?\n    if not ignoreMissingKey and 'f00b4r' in result:\n        raise ValueError('Frame key not found: ' + key)\n    return result", "language": "python", "code": "def delete_frame(self, key, ignoreMissingKey=True, timeoutSecs=60, **kwargs):\n    assert key is not None, '\"key\" parameter is null'\n\n    result = self.do_json_request('/3/Frames.json/' + key, cmd='delete', timeout=timeoutSecs)\n\n    # TODO: look for what?\n    if not ignoreMissingKey and 'f00b4r' in result:\n        raise ValueError('Frame key not found: ' + key)\n    return result", "code_tokens": ["def", "delete_frame", "(", "self", ",", "key", ",", "ignoreMissingKey", "=", "True", ",", "timeoutSecs", "=", "60", ",", "*", "*", "kwargs", ")", ":", "assert", "key", "is", "not", "None", ",", "'\"key\" parameter is null'", "result", "=", "self", ".", "do_json_request", "(", "'/3/Frames.json/'", "+", "key", ",", "cmd", "=", "'delete'", ",", "timeout", "=", "timeoutSecs", ")", "# TODO: look for what?", "if", "not", "ignoreMissingKey", "and", "'f00b4r'", "in", "result", ":", "raise", "ValueError", "(", "'Frame key not found: '", "+", "key", ")", "return", "result"], "docstring": "Delete a frame on the h2o cluster, given its key.", "docstring_tokens": ["Delete", "a", "frame", "on", "the", "h2o", "cluster", "given", "its", "key", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/py2/h2o_ray.py#L362-L373", "partition": "test", "index": 1328, "time": "2014-11-09 00:05:08"}
{"repo": "h2oai/h2o-3", "path": "py2/ec2_cmd.py", "func_name": "stop_instances", "original_string": "def stop_instances(instances, region):\n    '''stop all the instances given by its ids'''\n    if not instances: return\n    conn = ec2_connect(region)\n    log(\"Stopping instances {0}.\".format(instances))\n    conn.stop_instances(instances)\n    log(\"Done\")", "language": "python", "code": "def stop_instances(instances, region):\n    if not instances: return\n    conn = ec2_connect(region)\n    log(\"Stopping instances {0}.\".format(instances))\n    conn.stop_instances(instances)\n    log(\"Done\")", "code_tokens": ["def", "stop_instances", "(", "instances", ",", "region", ")", ":", "if", "not", "instances", ":", "return", "conn", "=", "ec2_connect", "(", "region", ")", "log", "(", "\"Stopping instances {0}.\"", ".", "format", "(", "instances", ")", ")", "conn", ".", "stop_instances", "(", "instances", ")", "log", "(", "\"Done\"", ")"], "docstring": "stop all the instances given by its ids", "docstring_tokens": ["stop", "all", "the", "instances", "given", "by", "its", "ids"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/py2/ec2_cmd.py#L208-L214", "partition": "test", "index": 1337, "time": "2014-11-11 18:26:15"}
{"repo": "h2oai/h2o-3", "path": "py2/ec2_cmd.py", "func_name": "terminate_instances", "original_string": "def terminate_instances(instances, region):\n    '''terminate all the instances given by its ids'''\n    if not instances: return\n    conn = ec2_connect(region)\n    log(\"Terminating instances {0}.\".format(instances))\n    conn.terminate_instances(instances)\n    log(\"Done\")", "language": "python", "code": "def terminate_instances(instances, region):\n    if not instances: return\n    conn = ec2_connect(region)\n    log(\"Terminating instances {0}.\".format(instances))\n    conn.terminate_instances(instances)\n    log(\"Done\")", "code_tokens": ["def", "terminate_instances", "(", "instances", ",", "region", ")", ":", "if", "not", "instances", ":", "return", "conn", "=", "ec2_connect", "(", "region", ")", "log", "(", "\"Terminating instances {0}.\"", ".", "format", "(", "instances", ")", ")", "conn", ".", "terminate_instances", "(", "instances", ")", "log", "(", "\"Done\"", ")"], "docstring": "terminate all the instances given by its ids", "docstring_tokens": ["terminate", "all", "the", "instances", "given", "by", "its", "ids"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/py2/ec2_cmd.py#L200-L206", "partition": "test", "index": 1336, "time": "2014-11-11 18:26:15"}
{"repo": "h2oai/h2o-3", "path": "py2/ec2_cmd.py", "func_name": "run_instances", "original_string": "def run_instances(count, ec2_config, region, waitForSSH=True, tags=None):\n    '''Create a new reservation for count instances'''\n\n    ec2params = inheritparams(ec2_config, EC2_API_RUN_INSTANCE)\n    ec2params.setdefault('min_count', count)\n    ec2params.setdefault('max_count', count)\n\n    reservation = None\n    conn = ec2_connect(region)\n    try:\n        reservation = conn.run_instances(**ec2params)\n        log('Reservation: {0}'.format(reservation.id))\n        log('Waiting for {0} EC2 instances {1} to come up, this can take 1-2 minutes.'.format(len(reservation.instances), reservation.instances))\n        start = time.time()\n        time.sleep(1)\n        for instance in reservation.instances:\n            while instance.update() == 'pending':\n               time.sleep(1)\n               h2o_cmd.dot()\n\n            if not instance.state == 'running':\n                raise Exception('\\033[91m[ec2] Error waiting for running state. Instance is in state {0}.\\033[0m'.format(instance.state))\n\n        log('Instances started in {0} seconds'.format(time.time() - start))\n        log('Instances: ')\n        for inst in reservation.instances: log(\"   {0} ({1}) : public ip: {2}, private ip: {3}\".format(inst.public_dns_name, inst.id, inst.ip_address, inst.private_ip_address))\n        \n        if waitForSSH:\n            # kbn: changing to private address, so it should fail if not in right domain\n            # used to have the public ip address\n            wait_for_ssh([ i.private_ip_address for i in reservation.instances ])\n\n        # Tag instances\n        try:\n            if tags:\n                conn.create_tags([i.id for i in reservation.instances], tags)                        \n        except:\n            warn('Something wrong during tagging instances. Exceptions IGNORED!')\n            print sys.exc_info()\n            pass\n\n        return reservation\n    except:\n        print \"\\033[91mUnexpected error\\033[0m :\", sys.exc_info()\n        if reservation:\n            terminate_reservation(reservation, region)\n        raise", "language": "python", "code": "def run_instances(count, ec2_config, region, waitForSSH=True, tags=None):\n    ec2params = inheritparams(ec2_config, EC2_API_RUN_INSTANCE)\n    ec2params.setdefault('min_count', count)\n    ec2params.setdefault('max_count', count)\n\n    reservation = None\n    conn = ec2_connect(region)\n    try:\n        reservation = conn.run_instances(**ec2params)\n        log('Reservation: {0}'.format(reservation.id))\n        log('Waiting for {0} EC2 instances {1} to come up, this can take 1-2 minutes.'.format(len(reservation.instances), reservation.instances))\n        start = time.time()\n        time.sleep(1)\n        for instance in reservation.instances:\n            while instance.update() == 'pending':\n               time.sleep(1)\n               h2o_cmd.dot()\n\n            if not instance.state == 'running':\n                raise Exception('\\033[91m[ec2] Error waiting for running state. Instance is in state {0}.\\033[0m'.format(instance.state))\n\n        log('Instances started in {0} seconds'.format(time.time() - start))\n        log('Instances: ')\n        for inst in reservation.instances: log(\"   {0} ({1}) : public ip: {2}, private ip: {3}\".format(inst.public_dns_name, inst.id, inst.ip_address, inst.private_ip_address))\n        \n        if waitForSSH:\n            # kbn: changing to private address, so it should fail if not in right domain\n            # used to have the public ip address\n            wait_for_ssh([ i.private_ip_address for i in reservation.instances ])\n\n        # Tag instances\n        try:\n            if tags:\n                conn.create_tags([i.id for i in reservation.instances], tags)                        \n        except:\n            warn('Something wrong during tagging instances. Exceptions IGNORED!')\n            print sys.exc_info()\n            pass\n\n        return reservation\n    except:\n        print \"\\033[91mUnexpected error\\033[0m :\", sys.exc_info()\n        if reservation:\n            terminate_reservation(reservation, region)\n        raise", "code_tokens": ["def", "run_instances", "(", "count", ",", "ec2_config", ",", "region", ",", "waitForSSH", "=", "True", ",", "tags", "=", "None", ")", ":", "ec2params", "=", "inheritparams", "(", "ec2_config", ",", "EC2_API_RUN_INSTANCE", ")", "ec2params", ".", "setdefault", "(", "'min_count'", ",", "count", ")", "ec2params", ".", "setdefault", "(", "'max_count'", ",", "count", ")", "reservation", "=", "None", "conn", "=", "ec2_connect", "(", "region", ")", "try", ":", "reservation", "=", "conn", ".", "run_instances", "(", "*", "*", "ec2params", ")", "log", "(", "'Reservation: {0}'", ".", "format", "(", "reservation", ".", "id", ")", ")", "log", "(", "'Waiting for {0} EC2 instances {1} to come up, this can take 1-2 minutes.'", ".", "format", "(", "len", "(", "reservation", ".", "instances", ")", ",", "reservation", ".", "instances", ")", ")", "start", "=", "time", ".", "time", "(", ")", "time", ".", "sleep", "(", "1", ")", "for", "instance", "in", "reservation", ".", "instances", ":", "while", "instance", ".", "update", "(", ")", "==", "'pending'", ":", "time", ".", "sleep", "(", "1", ")", "h2o_cmd", ".", "dot", "(", ")", "if", "not", "instance", ".", "state", "==", "'running'", ":", "raise", "Exception", "(", "'\\033[91m[ec2] Error waiting for running state. Instance is in state {0}.\\033[0m'", ".", "format", "(", "instance", ".", "state", ")", ")", "log", "(", "'Instances started in {0} seconds'", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start", ")", ")", "log", "(", "'Instances: '", ")", "for", "inst", "in", "reservation", ".", "instances", ":", "log", "(", "\"   {0} ({1}) : public ip: {2}, private ip: {3}\"", ".", "format", "(", "inst", ".", "public_dns_name", ",", "inst", ".", "id", ",", "inst", ".", "ip_address", ",", "inst", ".", "private_ip_address", ")", ")", "if", "waitForSSH", ":", "# kbn: changing to private address, so it should fail if not in right domain", "# used to have the public ip address", "wait_for_ssh", "(", "[", "i", ".", "private_ip_address", "for", "i", "in", "reservation", ".", "instances", "]", ")", "# Tag instances", "try", ":", "if", "tags", ":", "conn", ".", "create_tags", "(", "[", "i", ".", "id", "for", "i", "in", "reservation", ".", "instances", "]", ",", "tags", ")", "except", ":", "warn", "(", "'Something wrong during tagging instances. Exceptions IGNORED!'", ")", "print", "sys", ".", "exc_info", "(", ")", "pass", "return", "reservation", "except", ":", "print", "\"\\033[91mUnexpected error\\033[0m :\"", ",", "sys", ".", "exc_info", "(", ")", "if", "reservation", ":", "terminate_reservation", "(", "reservation", ",", "region", ")", "raise"], "docstring": "Create a new reservation for count instances", "docstring_tokens": ["Create", "a", "new", "reservation", "for", "count", "instances"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/py2/ec2_cmd.py#L144-L190", "partition": "test", "index": 1335, "time": "2014-11-11 18:26:15"}
{"repo": "h2oai/h2o-3", "path": "py2/ec2_cmd.py", "func_name": "wait_for_ssh", "original_string": "def wait_for_ssh(ips, port=22, skipAlive=True, requiredsuccess=3):\n    ''' Wait for ssh service to appear on given hosts'''\n    log('Waiting for SSH on following hosts: {0}'.format(ips))\n    for ip in ips:\n        if not skipAlive or not ssh_live(ip, port): \n            log('Waiting for SSH on instance {0}...'.format(ip))\n            count = 0\n            while count < requiredsuccess:\n                if ssh_live(ip, port):\n                    count += 1\n                else:\n                    count = 0\n                time.sleep(1)\n                h2o_cmd.dot()", "language": "python", "code": "def wait_for_ssh(ips, port=22, skipAlive=True, requiredsuccess=3):\n    log('Waiting for SSH on following hosts: {0}'.format(ips))\n    for ip in ips:\n        if not skipAlive or not ssh_live(ip, port): \n            log('Waiting for SSH on instance {0}...'.format(ip))\n            count = 0\n            while count < requiredsuccess:\n                if ssh_live(ip, port):\n                    count += 1\n                else:\n                    count = 0\n                time.sleep(1)\n                h2o_cmd.dot()", "code_tokens": ["def", "wait_for_ssh", "(", "ips", ",", "port", "=", "22", ",", "skipAlive", "=", "True", ",", "requiredsuccess", "=", "3", ")", ":", "log", "(", "'Waiting for SSH on following hosts: {0}'", ".", "format", "(", "ips", ")", ")", "for", "ip", "in", "ips", ":", "if", "not", "skipAlive", "or", "not", "ssh_live", "(", "ip", ",", "port", ")", ":", "log", "(", "'Waiting for SSH on instance {0}...'", ".", "format", "(", "ip", ")", ")", "count", "=", "0", "while", "count", "<", "requiredsuccess", ":", "if", "ssh_live", "(", "ip", ",", "port", ")", ":", "count", "+=", "1", "else", ":", "count", "=", "0", "time", ".", "sleep", "(", "1", ")", "h2o_cmd", ".", "dot", "(", ")"], "docstring": "Wait for ssh service to appear on given hosts", "docstring_tokens": ["Wait", "for", "ssh", "service", "to", "appear", "on", "given", "hosts"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/py2/ec2_cmd.py#L232-L245", "partition": "test", "index": 1340, "time": "2014-11-11 18:26:15"}
{"repo": "h2oai/h2o-3", "path": "py2/ec2_cmd.py", "func_name": "reboot_instances", "original_string": "def reboot_instances(instances, region):\n    '''Reboot all the instances given by its ids'''\n    if not instances: return\n    conn = ec2_connect(region)\n    log(\"Rebooting instances {0}.\".format(instances))\n    conn.reboot_instances(instances)\n    log(\"Done\")", "language": "python", "code": "def reboot_instances(instances, region):\n    if not instances: return\n    conn = ec2_connect(region)\n    log(\"Rebooting instances {0}.\".format(instances))\n    conn.reboot_instances(instances)\n    log(\"Done\")", "code_tokens": ["def", "reboot_instances", "(", "instances", ",", "region", ")", ":", "if", "not", "instances", ":", "return", "conn", "=", "ec2_connect", "(", "region", ")", "log", "(", "\"Rebooting instances {0}.\"", ".", "format", "(", "instances", ")", ")", "conn", ".", "reboot_instances", "(", "instances", ")", "log", "(", "\"Done\"", ")"], "docstring": "Reboot all the instances given by its ids", "docstring_tokens": ["Reboot", "all", "the", "instances", "given", "by", "its", "ids"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/py2/ec2_cmd.py#L224-L230", "partition": "test", "index": 1339, "time": "2014-11-11 18:26:15"}
{"repo": "h2oai/h2o-3", "path": "py2/ec2_cmd.py", "func_name": "start_instances", "original_string": "def start_instances(instances, region):\n    '''Start all the instances given by its ids'''\n    if not instances: return\n    conn = ec2_connect(region)\n    log(\"Starting instances {0}.\".format(instances))\n    conn.start_instances(instances)\n    log(\"Done\")", "language": "python", "code": "def start_instances(instances, region):\n    if not instances: return\n    conn = ec2_connect(region)\n    log(\"Starting instances {0}.\".format(instances))\n    conn.start_instances(instances)\n    log(\"Done\")", "code_tokens": ["def", "start_instances", "(", "instances", ",", "region", ")", ":", "if", "not", "instances", ":", "return", "conn", "=", "ec2_connect", "(", "region", ")", "log", "(", "\"Starting instances {0}.\"", ".", "format", "(", "instances", ")", ")", "conn", ".", "start_instances", "(", "instances", ")", "log", "(", "\"Done\"", ")"], "docstring": "Start all the instances given by its ids", "docstring_tokens": ["Start", "all", "the", "instances", "given", "by", "its", "ids"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/py2/ec2_cmd.py#L216-L222", "partition": "test", "index": 1338, "time": "2014-11-11 18:26:15"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/automl/autoh2o.py", "func_name": "H2OAutoML.download_pojo", "original_string": "def download_pojo(self, path=\"\", get_genmodel_jar=False, genmodel_name=\"\"):\n        \"\"\"\n        Download the POJO for the leader model in AutoML to the directory specified by path.\n\n        If path is an empty string, then dump the output to screen.\n\n        :param path:  An absolute path to the directory where POJO should be saved.\n        :param get_genmodel_jar: if True, then also download h2o-genmodel.jar and store it in folder ``path``.\n        :param genmodel_name Custom name of genmodel jar\n        :returns: name of the POJO file written.\n        \"\"\"\n\n        return h2o.download_pojo(self.leader, path, get_jar=get_genmodel_jar, jar_name=genmodel_name)", "language": "python", "code": "def download_pojo(self, path=\"\", get_genmodel_jar=False, genmodel_name=\"\"):\n        return h2o.download_pojo(self.leader, path, get_jar=get_genmodel_jar, jar_name=genmodel_name)", "code_tokens": ["def", "download_pojo", "(", "self", ",", "path", "=", "\"\"", ",", "get_genmodel_jar", "=", "False", ",", "genmodel_name", "=", "\"\"", ")", ":", "return", "h2o", ".", "download_pojo", "(", "self", ".", "leader", ",", "path", ",", "get_jar", "=", "get_genmodel_jar", ",", "jar_name", "=", "genmodel_name", ")"], "docstring": "Download the POJO for the leader model in AutoML to the directory specified by path.", "docstring_tokens": ["Download", "the", "POJO", "for", "the", "leader", "model", "in", "AutoML", "to", "the", "directory", "specified", "by", "path", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/automl/autoh2o.py#L443-L455", "partition": "test", "index": 1509, "time": "2018-04-11 17:35:20"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/automl/autoh2o.py", "func_name": "get_automl", "original_string": "def get_automl(project_name):\n    \"\"\"\n    Retrieve information about an AutoML instance.\n\n    :param str project_name:  A string indicating the project_name of the automl instance to retrieve.\n    :returns: A dictionary containing the project_name, leader model, and leaderboard.\n    \"\"\"\n    automl_json = h2o.api(\"GET /99/AutoML/%s\" % project_name)\n    project_name = automl_json[\"project_name\"]\n    leaderboard_list = [key[\"name\"] for key in automl_json['leaderboard']['models']]\n\n    if leaderboard_list is not None and len(leaderboard_list) > 0:\n        leader_id = leaderboard_list[0]\n    else:\n        leader_id = None\n\n    leader = h2o.get_model(leader_id)\n    # Intentionally mask the progress bar here since showing multiple progress bars is confusing to users.\n    # If any failure happens, revert back to user's original setting for progress and display the error message.\n    is_progress = H2OJob.__PROGRESS_BAR__\n    h2o.no_progress()\n    try:\n        # Parse leaderboard H2OTwoDimTable & return as an H2OFrame\n        leaderboard = h2o.H2OFrame(\n            automl_json[\"leaderboard_table\"].cell_values,\n            column_names=automl_json[\"leaderboard_table\"].col_header)\n    except Exception as ex:\n        raise ex\n    finally:\n        if is_progress is True:\n            h2o.show_progress()\n\n    leaderboard = leaderboard[1:]\n    automl_dict = {'project_name': project_name, \"leader\": leader, \"leaderboard\": leaderboard}\n    return automl_dict", "language": "python", "code": "def get_automl(project_name):\n    automl_json = h2o.api(\"GET /99/AutoML/%s\" % project_name)\n    project_name = automl_json[\"project_name\"]\n    leaderboard_list = [key[\"name\"] for key in automl_json['leaderboard']['models']]\n\n    if leaderboard_list is not None and len(leaderboard_list) > 0:\n        leader_id = leaderboard_list[0]\n    else:\n        leader_id = None\n\n    leader = h2o.get_model(leader_id)\n    # Intentionally mask the progress bar here since showing multiple progress bars is confusing to users.\n    # If any failure happens, revert back to user's original setting for progress and display the error message.\n    is_progress = H2OJob.__PROGRESS_BAR__\n    h2o.no_progress()\n    try:\n        # Parse leaderboard H2OTwoDimTable & return as an H2OFrame\n        leaderboard = h2o.H2OFrame(\n            automl_json[\"leaderboard_table\"].cell_values,\n            column_names=automl_json[\"leaderboard_table\"].col_header)\n    except Exception as ex:\n        raise ex\n    finally:\n        if is_progress is True:\n            h2o.show_progress()\n\n    leaderboard = leaderboard[1:]\n    automl_dict = {'project_name': project_name, \"leader\": leader, \"leaderboard\": leaderboard}\n    return automl_dict", "code_tokens": ["def", "get_automl", "(", "project_name", ")", ":", "automl_json", "=", "h2o", ".", "api", "(", "\"GET /99/AutoML/%s\"", "%", "project_name", ")", "project_name", "=", "automl_json", "[", "\"project_name\"", "]", "leaderboard_list", "=", "[", "key", "[", "\"name\"", "]", "for", "key", "in", "automl_json", "[", "'leaderboard'", "]", "[", "'models'", "]", "]", "if", "leaderboard_list", "is", "not", "None", "and", "len", "(", "leaderboard_list", ")", ">", "0", ":", "leader_id", "=", "leaderboard_list", "[", "0", "]", "else", ":", "leader_id", "=", "None", "leader", "=", "h2o", ".", "get_model", "(", "leader_id", ")", "# Intentionally mask the progress bar here since showing multiple progress bars is confusing to users.", "# If any failure happens, revert back to user's original setting for progress and display the error message.", "is_progress", "=", "H2OJob", ".", "__PROGRESS_BAR__", "h2o", ".", "no_progress", "(", ")", "try", ":", "# Parse leaderboard H2OTwoDimTable & return as an H2OFrame", "leaderboard", "=", "h2o", ".", "H2OFrame", "(", "automl_json", "[", "\"leaderboard_table\"", "]", ".", "cell_values", ",", "column_names", "=", "automl_json", "[", "\"leaderboard_table\"", "]", ".", "col_header", ")", "except", "Exception", "as", "ex", ":", "raise", "ex", "finally", ":", "if", "is_progress", "is", "True", ":", "h2o", ".", "show_progress", "(", ")", "leaderboard", "=", "leaderboard", "[", "1", ":", "]", "automl_dict", "=", "{", "'project_name'", ":", "project_name", ",", "\"leader\"", ":", "leader", ",", "\"leaderboard\"", ":", "leaderboard", "}", "return", "automl_dict"], "docstring": "Retrieve information about an AutoML instance.", "docstring_tokens": ["Retrieve", "information", "about", "an", "AutoML", "instance", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/automl/autoh2o.py#L503-L537", "partition": "test", "index": 1508, "time": "2018-05-25 16:12:44"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/targetencoder.py", "func_name": "TargetEncoder.fit", "original_string": "def fit(self, frame = None):\n        \"\"\"\n        Returns encoding map as an object that maps 'column_name' -> 'frame_with_encoding_map_for_this_column_name'\n\n        :param frame frame: An H2OFrame object with which to create the target encoding map\n        \"\"\"\n        self._teColumns = list(map(lambda i: frame.names[i], self._teColumns)) if all(isinstance(n, int) for n in self._teColumns) else self._teColumns\n        self._responseColumnName = frame.names[self._responseColumnName] if isinstance(self._responseColumnName, int) else self._responseColumnName\n        self._foldColumnName = frame.names[self._foldColumnName] if isinstance(self._foldColumnName, int) else self._foldColumnName\n        \n        self._encodingMap = ExprNode(\"target.encoder.fit\", frame, self._teColumns, self._responseColumnName,\n                                     self._foldColumnName)._eager_map_frame()\n\n        return self._encodingMap", "language": "python", "code": "def fit(self, frame = None):\n        self._teColumns = list(map(lambda i: frame.names[i], self._teColumns)) if all(isinstance(n, int) for n in self._teColumns) else self._teColumns\n        self._responseColumnName = frame.names[self._responseColumnName] if isinstance(self._responseColumnName, int) else self._responseColumnName\n        self._foldColumnName = frame.names[self._foldColumnName] if isinstance(self._foldColumnName, int) else self._foldColumnName\n        \n        self._encodingMap = ExprNode(\"target.encoder.fit\", frame, self._teColumns, self._responseColumnName,\n                                     self._foldColumnName)._eager_map_frame()\n\n        return self._encodingMap", "code_tokens": ["def", "fit", "(", "self", ",", "frame", "=", "None", ")", ":", "self", ".", "_teColumns", "=", "list", "(", "map", "(", "lambda", "i", ":", "frame", ".", "names", "[", "i", "]", ",", "self", ".", "_teColumns", ")", ")", "if", "all", "(", "isinstance", "(", "n", ",", "int", ")", "for", "n", "in", "self", ".", "_teColumns", ")", "else", "self", ".", "_teColumns", "self", ".", "_responseColumnName", "=", "frame", ".", "names", "[", "self", ".", "_responseColumnName", "]", "if", "isinstance", "(", "self", ".", "_responseColumnName", ",", "int", ")", "else", "self", ".", "_responseColumnName", "self", ".", "_foldColumnName", "=", "frame", ".", "names", "[", "self", ".", "_foldColumnName", "]", "if", "isinstance", "(", "self", ".", "_foldColumnName", ",", "int", ")", "else", "self", ".", "_foldColumnName", "self", ".", "_encodingMap", "=", "ExprNode", "(", "\"target.encoder.fit\"", ",", "frame", ",", "self", ".", "_teColumns", ",", "self", ".", "_responseColumnName", ",", "self", ".", "_foldColumnName", ")", ".", "_eager_map_frame", "(", ")", "return", "self", ".", "_encodingMap"], "docstring": "Returns encoding map as an object that maps 'column_name' -> 'frame_with_encoding_map_for_this_column_name'", "docstring_tokens": ["Returns", "encoding", "map", "as", "an", "object", "that", "maps", "column_name", "-", ">", "frame_with_encoding_map_for_this_column_name"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/targetencoder.py#L78-L91", "partition": "test", "index": 1387, "time": "2018-10-17 19:43:33"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/pipeline/mojo_pipeline.py", "func_name": "H2OMojoPipeline.transform", "original_string": "def transform(self, data, allow_timestamps=False):\n        \"\"\"\n        Transform H2OFrame using a MOJO Pipeline.\n\n        :param data: Frame to be transformed.\n        :param allow_timestamps: Allows datetime columns to be used directly with MOJO pipelines. It is recommended\n        to parse your datetime columns as Strings when using pipelines because pipelines can interpret certain datetime\n        formats in a different way. If your H2OFrame is parsed from a binary file format (eg. Parquet) instead of CSV\n        it is safe to turn this option on and use datetime columns directly.\n\n        :returns: A new H2OFrame.\n        \"\"\"\n        assert_is_type(data, H2OFrame)\n        assert_is_type(allow_timestamps, bool)\n        return H2OFrame._expr(ExprNode(\"mojo.pipeline.transform\", self.pipeline_id[0], data, allow_timestamps))", "language": "python", "code": "def transform(self, data, allow_timestamps=False):\n        assert_is_type(data, H2OFrame)\n        assert_is_type(allow_timestamps, bool)\n        return H2OFrame._expr(ExprNode(\"mojo.pipeline.transform\", self.pipeline_id[0], data, allow_timestamps))", "code_tokens": ["def", "transform", "(", "self", ",", "data", ",", "allow_timestamps", "=", "False", ")", ":", "assert_is_type", "(", "data", ",", "H2OFrame", ")", "assert_is_type", "(", "allow_timestamps", ",", "bool", ")", "return", "H2OFrame", ".", "_expr", "(", "ExprNode", "(", "\"mojo.pipeline.transform\"", ",", "self", ".", "pipeline_id", "[", "0", "]", ",", "data", ",", "allow_timestamps", ")", ")"], "docstring": "Transform H2OFrame using a MOJO Pipeline.", "docstring_tokens": ["Transform", "H2OFrame", "using", "a", "MOJO", "Pipeline", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/pipeline/mojo_pipeline.py#L39-L53", "partition": "test", "index": 1576, "time": "2018-12-17 14:17:51"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/h2o.py", "func_name": "import_hive_table", "original_string": "def import_hive_table(database=None, table=None, partitions=None, allow_multi_format=False):\n    \"\"\"\n    Import Hive table to H2OFrame in memory.\n\n    Make sure to start H2O with Hive on classpath. Uses hive-site.xml on classpath to connect to Hive.\n\n    :param database: Name of Hive database (default database will be used by default)\n    :param table: name of Hive table to import\n    :param partitions: a list of lists of strings - partition key column values of partitions you want to import.\n    :param allow_multi_format: enable import of partitioned tables with different storage formats used. WARNING:\n        this may fail on out-of-memory for tables with a large number of small partitions.\n\n    :returns: an :class:`H2OFrame` containing data of the specified Hive table.\n\n    :examples:\n        >>> my_citibike_data = h2o.import_hive_table(\"default\", \"table\", [[\"2017\", \"01\"], [\"2017\", \"02\"]])\n    \"\"\"    \n    assert_is_type(database, str, None)\n    assert_is_type(table, str)\n    assert_is_type(partitions, [[str]], None)\n    p = { \"database\": database, \"table\": table, \"partitions\": partitions, \"allow_multi_format\": allow_multi_format }\n    j = H2OJob(api(\"POST /3/ImportHiveTable\", data=p), \"Import Hive Table\").poll()\n    return get_frame(j.dest_key)", "language": "python", "code": "def import_hive_table(database=None, table=None, partitions=None, allow_multi_format=False):\n    assert_is_type(database, str, None)\n    assert_is_type(table, str)\n    assert_is_type(partitions, [[str]], None)\n    p = { \"database\": database, \"table\": table, \"partitions\": partitions, \"allow_multi_format\": allow_multi_format }\n    j = H2OJob(api(\"POST /3/ImportHiveTable\", data=p), \"Import Hive Table\").poll()\n    return get_frame(j.dest_key)", "code_tokens": ["def", "import_hive_table", "(", "database", "=", "None", ",", "table", "=", "None", ",", "partitions", "=", "None", ",", "allow_multi_format", "=", "False", ")", ":", "assert_is_type", "(", "database", ",", "str", ",", "None", ")", "assert_is_type", "(", "table", ",", "str", ")", "assert_is_type", "(", "partitions", ",", "[", "[", "str", "]", "]", ",", "None", ")", "p", "=", "{", "\"database\"", ":", "database", ",", "\"table\"", ":", "table", ",", "\"partitions\"", ":", "partitions", ",", "\"allow_multi_format\"", ":", "allow_multi_format", "}", "j", "=", "H2OJob", "(", "api", "(", "\"POST /3/ImportHiveTable\"", ",", "data", "=", "p", ")", ",", "\"Import Hive Table\"", ")", ".", "poll", "(", ")", "return", "get_frame", "(", "j", ".", "dest_key", ")"], "docstring": "Import Hive table to H2OFrame in memory.", "docstring_tokens": ["Import", "Hive", "table", "to", "H2OFrame", "in", "memory", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/h2o.py#L440-L462", "partition": "test", "index": 1458, "time": "2019-02-06 19:20:04"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/backend/cluster.py", "func_name": "H2OCluster.list_jobs", "original_string": "def list_jobs(self):\n        \"\"\"List all jobs performed by the cluster.\"\"\"\n        res = h2o.api(\"GET /3/Jobs\")\n        table = [[\"type\"], [\"dest\"], [\"description\"], [\"status\"]]\n        for job in res[\"jobs\"]:\n            job_dest = job[\"dest\"]\n            table[0].append(self._translate_job_type(job_dest[\"type\"]))\n            table[1].append(job_dest[\"name\"])\n            table[2].append(job[\"description\"])\n            table[3].append(job[\"status\"])\n        return table", "language": "python", "code": "def list_jobs(self):\n        res = h2o.api(\"GET /3/Jobs\")\n        table = [[\"type\"], [\"dest\"], [\"description\"], [\"status\"]]\n        for job in res[\"jobs\"]:\n            job_dest = job[\"dest\"]\n            table[0].append(self._translate_job_type(job_dest[\"type\"]))\n            table[1].append(job_dest[\"name\"])\n            table[2].append(job[\"description\"])\n            table[3].append(job[\"status\"])\n        return table", "code_tokens": ["def", "list_jobs", "(", "self", ")", ":", "res", "=", "h2o", ".", "api", "(", "\"GET /3/Jobs\"", ")", "table", "=", "[", "[", "\"type\"", "]", ",", "[", "\"dest\"", "]", ",", "[", "\"description\"", "]", ",", "[", "\"status\"", "]", "]", "for", "job", "in", "res", "[", "\"jobs\"", "]", ":", "job_dest", "=", "job", "[", "\"dest\"", "]", "table", "[", "0", "]", ".", "append", "(", "self", ".", "_translate_job_type", "(", "job_dest", "[", "\"type\"", "]", ")", ")", "table", "[", "1", "]", ".", "append", "(", "job_dest", "[", "\"name\"", "]", ")", "table", "[", "2", "]", ".", "append", "(", "job", "[", "\"description\"", "]", ")", "table", "[", "3", "]", ".", "append", "(", "job", "[", "\"status\"", "]", ")", "return", "table"], "docstring": "List all jobs performed by the cluster.", "docstring_tokens": ["List", "all", "jobs", "performed", "by", "the", "cluster", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/backend/cluster.py#L266-L276", "partition": "test", "index": 1322, "time": "2019-04-18 23:06:04"}
