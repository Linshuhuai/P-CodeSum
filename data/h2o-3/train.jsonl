{"repo": "h2oai/h2o-3", "path": "scripts/run.py", "func_name": "H2OCloudNode.scrape_port_from_stdout", "original_string": "def scrape_port_from_stdout(self):\n        \"\"\"\n        Look at the stdout log and figure out which port the JVM chose.\n\n        If successful, port number is stored in self.port; otherwise the\n        program is terminated. This call is blocking, and will wait for\n        up to 30s for the server to start up.\n        \"\"\"\n        regex = re.compile(r\"Open H2O Flow in your web browser: https?://([^:]+):(\\d+)\")\n        retries_left = 30\n        while retries_left and not self.terminated:\n            with open(self.output_file_name, \"r\") as f:\n                for line in f:\n                    mm = re.search(regex, line)\n                    if mm is not None:\n                        self.port = mm.group(2)\n                        print(\"H2O cloud %d node %d listening on port %s\\n    with output file %s\" %\n                              (self.cloud_num, self.node_num, self.port, self.output_file_name))\n                        return\n            if self.terminated: break\n            retries_left -= 1\n            time.sleep(1)\n\n        if self.terminated: return\n        print(\"\\nERROR: Too many retries starting cloud %d.\\nCheck the output log %s.\\n\" %\n              (self.cloud_num, self.output_file_name))\n        sys.exit(1)", "language": "python", "code": "def scrape_port_from_stdout(self):\n        \"\"\"\n        Look at the stdout log and figure out which port the JVM chose.\n\n        If successful, port number is stored in self.port; otherwise the\n        program is terminated. This call is blocking, and will wait for\n        up to 30s for the server to start up.\n        \"\"\"\n        regex = re.compile(r\"Open H2O Flow in your web browser: https?://([^:]+):(\\d+)\")\n        retries_left = 30\n        while retries_left and not self.terminated:\n            with open(self.output_file_name, \"r\") as f:\n                for line in f:\n                    mm = re.search(regex, line)\n                    if mm is not None:\n                        self.port = mm.group(2)\n                        print(\"H2O cloud %d node %d listening on port %s\\n    with output file %s\" %\n                              (self.cloud_num, self.node_num, self.port, self.output_file_name))\n                        return\n            if self.terminated: break\n            retries_left -= 1\n            time.sleep(1)\n\n        if self.terminated: return\n        print(\"\\nERROR: Too many retries starting cloud %d.\\nCheck the output log %s.\\n\" %\n              (self.cloud_num, self.output_file_name))\n        sys.exit(1)", "code_tokens": ["def", "scrape_port_from_stdout", "(", "self", ")", ":", "regex", "=", "re", ".", "compile", "(", "r\"Open H2O Flow in your web browser: https?://([^:]+):(\\d+)\"", ")", "retries_left", "=", "30", "while", "retries_left", "and", "not", "self", ".", "terminated", ":", "with", "open", "(", "self", ".", "output_file_name", ",", "\"r\"", ")", "as", "f", ":", "for", "line", "in", "f", ":", "mm", "=", "re", ".", "search", "(", "regex", ",", "line", ")", "if", "mm", "is", "not", "None", ":", "self", ".", "port", "=", "mm", ".", "group", "(", "2", ")", "print", "(", "\"H2O cloud %d node %d listening on port %s\\n    with output file %s\"", "%", "(", "self", ".", "cloud_num", ",", "self", ".", "node_num", ",", "self", ".", "port", ",", "self", ".", "output_file_name", ")", ")", "return", "if", "self", ".", "terminated", ":", "break", "retries_left", "-=", "1", "time", ".", "sleep", "(", "1", ")", "if", "self", ".", "terminated", ":", "return", "print", "(", "\"\\nERROR: Too many retries starting cloud %d.\\nCheck the output log %s.\\n\"", "%", "(", "self", ".", "cloud_num", ",", "self", ".", "output_file_name", ")", ")", "sys", ".", "exit", "(", "1", ")"], "docstring": "Look at the stdout log and figure out which port the JVM chose.\n\n        If successful, port number is stored in self.port; otherwise the\n        program is terminated. This call is blocking, and will wait for\n        up to 30s for the server to start up.", "docstring_tokens": ["Look", "at", "the", "stdout", "log", "and", "figure", "out", "which", "port", "the", "JVM", "chose", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/scripts/run.py#L418-L444", "partition": "test", "index": 1352, "time": "2015-02-28 13:24:03"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/estimators/stackedensemble.py", "func_name": "H2OStackedEnsembleEstimator.metalearner_params", "original_string": "def metalearner_params(self):\n        \"\"\"\n        Parameters for metalearner algorithm\n\n        Type: ``dict``  (default: ``None``).\n        Example: metalearner_gbm_params = {'max_depth': 2, 'col_sample_rate': 0.3}\n        \"\"\"\n        if self._parms.get(\"metalearner_params\") != None:\n            metalearner_params_dict =  ast.literal_eval(self._parms.get(\"metalearner_params\"))\n            for k in metalearner_params_dict:\n                if len(metalearner_params_dict[k]) == 1: #single parameter\n                    metalearner_params_dict[k] = metalearner_params_dict[k][0]\n            return metalearner_params_dict\n        else:\n            return self._parms.get(\"metalearner_params\")", "language": "python", "code": "def metalearner_params(self):\n        \"\"\"\n        Parameters for metalearner algorithm\n\n        Type: ``dict``  (default: ``None``).\n        Example: metalearner_gbm_params = {'max_depth': 2, 'col_sample_rate': 0.3}\n        \"\"\"\n        if self._parms.get(\"metalearner_params\") != None:\n            metalearner_params_dict =  ast.literal_eval(self._parms.get(\"metalearner_params\"))\n            for k in metalearner_params_dict:\n                if len(metalearner_params_dict[k]) == 1: #single parameter\n                    metalearner_params_dict[k] = metalearner_params_dict[k][0]\n            return metalearner_params_dict\n        else:\n            return self._parms.get(\"metalearner_params\")", "code_tokens": ["def", "metalearner_params", "(", "self", ")", ":", "if", "self", ".", "_parms", ".", "get", "(", "\"metalearner_params\"", ")", "!=", "None", ":", "metalearner_params_dict", "=", "ast", ".", "literal_eval", "(", "self", ".", "_parms", ".", "get", "(", "\"metalearner_params\"", ")", ")", "for", "k", "in", "metalearner_params_dict", ":", "if", "len", "(", "metalearner_params_dict", "[", "k", "]", ")", "==", "1", ":", "#single parameter", "metalearner_params_dict", "[", "k", "]", "=", "metalearner_params_dict", "[", "k", "]", "[", "0", "]", "return", "metalearner_params_dict", "else", ":", "return", "self", ".", "_parms", ".", "get", "(", "\"metalearner_params\"", ")"], "docstring": "Parameters for metalearner algorithm", "docstring_tokens": ["Parameters", "for", "metalearner", "algorithm"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/estimators/stackedensemble.py#L216-L230", "partition": "test", "index": 1325, "time": "2018-02-01 16:33:18"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/frame.py", "func_name": "H2OFrame.rename", "original_string": "def rename(self, columns=None):\n        \"\"\"\n        Change names of columns in the frame.\n\n        Dict key is an index or name of the column whose name is to be set.\n        Dict value is the new name of the column.\n\n        :param columns: dict-like transformations to apply to the column names\n        \"\"\"\n        assert_is_type(columns, None, dict)\n        new_names = self.names\n        ncols = self.ncols\n\n        for col, name in columns.items():\n            col_index = None\n            if is_type(col, int) and (-ncols <= col < ncols):\n                col_index = (col + ncols) % ncols  # handle negative indices\n            elif is_type(col, str) and col in self.names:\n                col_index = self.names.index(col)  # lookup the name\n\n            if col_index is not None:\n                new_names[col_index] = name\n\n        return self.set_names(new_names)", "language": "python", "code": "def rename(self, columns=None):\n        \"\"\"\n        Change names of columns in the frame.\n\n        Dict key is an index or name of the column whose name is to be set.\n        Dict value is the new name of the column.\n\n        :param columns: dict-like transformations to apply to the column names\n        \"\"\"\n        assert_is_type(columns, None, dict)\n        new_names = self.names\n        ncols = self.ncols\n\n        for col, name in columns.items():\n            col_index = None\n            if is_type(col, int) and (-ncols <= col < ncols):\n                col_index = (col + ncols) % ncols  # handle negative indices\n            elif is_type(col, str) and col in self.names:\n                col_index = self.names.index(col)  # lookup the name\n\n            if col_index is not None:\n                new_names[col_index] = name\n\n        return self.set_names(new_names)", "code_tokens": ["def", "rename", "(", "self", ",", "columns", "=", "None", ")", ":", "assert_is_type", "(", "columns", ",", "None", ",", "dict", ")", "new_names", "=", "self", ".", "names", "ncols", "=", "self", ".", "ncols", "for", "col", ",", "name", "in", "columns", ".", "items", "(", ")", ":", "col_index", "=", "None", "if", "is_type", "(", "col", ",", "int", ")", "and", "(", "-", "ncols", "<=", "col", "<", "ncols", ")", ":", "col_index", "=", "(", "col", "+", "ncols", ")", "%", "ncols", "# handle negative indices", "elif", "is_type", "(", "col", ",", "str", ")", "and", "col", "in", "self", ".", "names", ":", "col_index", "=", "self", ".", "names", ".", "index", "(", "col", ")", "# lookup the name", "if", "col_index", "is", "not", "None", ":", "new_names", "[", "col_index", "]", "=", "name", "return", "self", ".", "set_names", "(", "new_names", ")"], "docstring": "Change names of columns in the frame.", "docstring_tokens": ["Change", "names", "of", "columns", "in", "the", "frame", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/frame.py#L1035-L1058", "partition": "test", "index": 1400, "time": "2018-02-23 19:01:14"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/automl/autoh2o.py", "func_name": "H2OAutoML.download_pojo", "original_string": "def download_pojo(self, path=\"\", get_genmodel_jar=False, genmodel_name=\"\"):\n        \"\"\"\n        Download the POJO for the leader model in AutoML to the directory specified by path.\n\n        If path is an empty string, then dump the output to screen.\n\n        :param path:  An absolute path to the directory where POJO should be saved.\n        :param get_genmodel_jar: if True, then also download h2o-genmodel.jar and store it in folder ``path``.\n        :param genmodel_name Custom name of genmodel jar\n        :returns: name of the POJO file written.\n        \"\"\"\n\n        return h2o.download_pojo(self.leader, path, get_jar=get_genmodel_jar, jar_name=genmodel_name)", "language": "python", "code": "def download_pojo(self, path=\"\", get_genmodel_jar=False, genmodel_name=\"\"):\n        \"\"\"\n        Download the POJO for the leader model in AutoML to the directory specified by path.\n\n        If path is an empty string, then dump the output to screen.\n\n        :param path:  An absolute path to the directory where POJO should be saved.\n        :param get_genmodel_jar: if True, then also download h2o-genmodel.jar and store it in folder ``path``.\n        :param genmodel_name Custom name of genmodel jar\n        :returns: name of the POJO file written.\n        \"\"\"\n\n        return h2o.download_pojo(self.leader, path, get_jar=get_genmodel_jar, jar_name=genmodel_name)", "code_tokens": ["def", "download_pojo", "(", "self", ",", "path", "=", "\"\"", ",", "get_genmodel_jar", "=", "False", ",", "genmodel_name", "=", "\"\"", ")", ":", "return", "h2o", ".", "download_pojo", "(", "self", ".", "leader", ",", "path", ",", "get_jar", "=", "get_genmodel_jar", ",", "jar_name", "=", "genmodel_name", ")"], "docstring": "Download the POJO for the leader model in AutoML to the directory specified by path.", "docstring_tokens": ["Download", "the", "POJO", "for", "the", "leader", "model", "in", "AutoML", "to", "the", "directory", "specified", "by", "path", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/automl/autoh2o.py#L443-L455", "partition": "test", "index": 1509, "time": "2018-04-11 17:35:20"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/h2o.py", "func_name": "get_frame", "original_string": "def get_frame(frame_id, **kwargs):\n    \"\"\"\n    Obtain a handle to the frame in H2O with the frame_id key.\n\n    :param str frame_id: id of the frame to retrieve.\n    :returns: an :class:`H2OFrame` object\n    \"\"\"\n    assert_is_type(frame_id, str)\n    return H2OFrame.get_frame(frame_id, **kwargs)", "language": "python", "code": "def get_frame(frame_id, **kwargs):\n    \"\"\"\n    Obtain a handle to the frame in H2O with the frame_id key.\n\n    :param str frame_id: id of the frame to retrieve.\n    :returns: an :class:`H2OFrame` object\n    \"\"\"\n    assert_is_type(frame_id, str)\n    return H2OFrame.get_frame(frame_id, **kwargs)", "code_tokens": ["def", "get_frame", "(", "frame_id", ",", "*", "*", "kwargs", ")", ":", "assert_is_type", "(", "frame_id", ",", "str", ")", "return", "H2OFrame", ".", "get_frame", "(", "frame_id", ",", "*", "*", "kwargs", ")"], "docstring": "Obtain a handle to the frame in H2O with the frame_id key.\n\n    :param str frame_id: id of the frame to retrieve.\n    :returns: an :class:`H2OFrame` object", "docstring_tokens": ["Obtain", "a", "handle", "to", "the", "frame", "in", "H2O", "with", "the", "frame_id", "key", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/h2o.py#L858-L866", "partition": "test", "index": 1465, "time": "2015-11-02 13:05:01"}
{"repo": "h2oai/h2o-3", "path": "h2o-docs/src/product/sphinxext/apigen.py", "func_name": "ApiDocWriter._path2uri", "original_string": "def _path2uri(self, dirpath):\n        ''' Convert directory path to uri '''\n        relpath = dirpath.replace(self.root_path, self.package_name)\n        if relpath.startswith(os.path.sep):\n            relpath = relpath[1:]\n        return relpath.replace(os.path.sep, '.')", "language": "python", "code": "def _path2uri(self, dirpath):\n        ''' Convert directory path to uri '''\n        relpath = dirpath.replace(self.root_path, self.package_name)\n        if relpath.startswith(os.path.sep):\n            relpath = relpath[1:]\n        return relpath.replace(os.path.sep, '.')", "code_tokens": ["def", "_path2uri", "(", "self", ",", "dirpath", ")", ":", "relpath", "=", "dirpath", ".", "replace", "(", "self", ".", "root_path", ",", "self", ".", "package_name", ")", "if", "relpath", ".", "startswith", "(", "os", ".", "path", ".", "sep", ")", ":", "relpath", "=", "relpath", "[", "1", ":", "]", "return", "relpath", ".", "replace", "(", "os", ".", "path", ".", "sep", ",", "'.'", ")"], "docstring": "Convert directory path to uri", "docstring_tokens": ["Convert", "directory", "path", "to", "uri"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-docs/src/product/sphinxext/apigen.py#L154-L159", "partition": "test", "index": 1558, "time": "2016-05-04 08:57:54"}
{"repo": "h2oai/h2o-3", "path": "h2o-bindings/bin/bindings.py", "func_name": "endpoint_groups", "original_string": "def endpoint_groups():\n    \"\"\"Return endpoints, grouped by the class which handles them.\"\"\"\n    groups = defaultdict(list)\n    for e in endpoints():\n        groups[e[\"class_name\"]].append(e)\n    return groups", "language": "python", "code": "def endpoint_groups():\n    \"\"\"Return endpoints, grouped by the class which handles them.\"\"\"\n    groups = defaultdict(list)\n    for e in endpoints():\n        groups[e[\"class_name\"]].append(e)\n    return groups", "code_tokens": ["def", "endpoint_groups", "(", ")", ":", "groups", "=", "defaultdict", "(", "list", ")", "for", "e", "in", "endpoints", "(", ")", ":", "groups", "[", "e", "[", "\"class_name\"", "]", "]", ".", "append", "(", "e", ")", "return", "groups"], "docstring": "Return endpoints, grouped by the class which handles them.", "docstring_tokens": ["Return", "endpoints", "grouped", "by", "the", "class", "which", "handles", "them", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-bindings/bin/bindings.py#L298-L303", "partition": "test", "index": 1583, "time": "2016-05-31 16:19:02"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/grid/grid_search.py", "func_name": "H2OGridSearch.join", "original_string": "def join(self):\n        \"\"\"Wait until grid finishes computing.\"\"\"\n        self._future = False\n        self._job.poll()\n        self._job = None", "language": "python", "code": "def join(self):\n        \"\"\"Wait until grid finishes computing.\"\"\"\n        self._future = False\n        self._job.poll()\n        self._job = None", "code_tokens": ["def", "join", "(", "self", ")", ":", "self", ".", "_future", "=", "False", "self", ".", "_job", ".", "poll", "(", ")", "self", ".", "_job", "=", "None"], "docstring": "Wait until grid finishes computing.", "docstring_tokens": ["Wait", "until", "grid", "finishes", "computing", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/grid/grid_search.py#L147-L151", "partition": "test", "index": 1483, "time": "2016-07-21 16:43:26"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/two_dim_table.py", "func_name": "H2OTwoDimTable.as_data_frame", "original_string": "def as_data_frame(self):\n        \"\"\"Convert to a python 'data frame'.\"\"\"\n        if can_use_pandas():\n            import pandas\n            pandas.options.display.max_colwidth = 70\n            return pandas.DataFrame(self._cell_values, columns=self._col_header)\n        return self", "language": "python", "code": "def as_data_frame(self):\n        \"\"\"Convert to a python 'data frame'.\"\"\"\n        if can_use_pandas():\n            import pandas\n            pandas.options.display.max_colwidth = 70\n            return pandas.DataFrame(self._cell_values, columns=self._col_header)\n        return self", "code_tokens": ["def", "as_data_frame", "(", "self", ")", ":", "if", "can_use_pandas", "(", ")", ":", "import", "pandas", "pandas", ".", "options", ".", "display", ".", "max_colwidth", "=", "70", "return", "pandas", ".", "DataFrame", "(", "self", ".", "_cell_values", ",", "columns", "=", "self", ".", "_col_header", ")", "return", "self"], "docstring": "Convert to a python 'data frame'.", "docstring_tokens": ["Convert", "to", "a", "python", "data", "frame", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/two_dim_table.py#L77-L83", "partition": "test", "index": 1550, "time": "2016-07-21 16:43:26"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/model/clustering.py", "func_name": "H2OClusteringModel.centers", "original_string": "def centers(self):\n        \"\"\"The centers for the KMeans model.\"\"\"\n        o = self._model_json[\"output\"]\n        cvals = o[\"centers\"].cell_values\n        centers = [list(cval[1:]) for cval in cvals]\n        return centers", "language": "python", "code": "def centers(self):\n        \"\"\"The centers for the KMeans model.\"\"\"\n        o = self._model_json[\"output\"]\n        cvals = o[\"centers\"].cell_values\n        centers = [list(cval[1:]) for cval in cvals]\n        return centers", "code_tokens": ["def", "centers", "(", "self", ")", ":", "o", "=", "self", ".", "_model_json", "[", "\"output\"", "]", "cvals", "=", "o", "[", "\"centers\"", "]", ".", "cell_values", "centers", "=", "[", "list", "(", "cval", "[", "1", ":", "]", ")", "for", "cval", "in", "cvals", "]", "return", "centers"], "docstring": "The centers for the KMeans model.", "docstring_tokens": ["The", "centers", "for", "the", "KMeans", "model", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/model/clustering.py#L143-L148", "partition": "test", "index": 1450, "time": "2016-07-21 16:43:26"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/frame.py", "func_name": "H2OFrame.nlevels", "original_string": "def nlevels(self):\n        \"\"\"\n        Get the number of factor levels for each categorical column.\n\n        :returns: A list of the number of levels per column.\n        \"\"\"\n        levels = self.levels()\n        return [len(l) for l in levels] if levels else 0", "language": "python", "code": "def nlevels(self):\n        \"\"\"\n        Get the number of factor levels for each categorical column.\n\n        :returns: A list of the number of levels per column.\n        \"\"\"\n        levels = self.levels()\n        return [len(l) for l in levels] if levels else 0", "code_tokens": ["def", "nlevels", "(", "self", ")", ":", "levels", "=", "self", ".", "levels", "(", ")", "return", "[", "len", "(", "l", ")", "for", "l", "in", "levels", "]", "if", "levels", "else", "0"], "docstring": "Get the number of factor levels for each categorical column.\n\n        :returns: A list of the number of levels per column.", "docstring_tokens": ["Get", "the", "number", "of", "factor", "levels", "for", "each", "categorical", "column", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/frame.py#L1000-L1007", "partition": "test", "index": 1397, "time": "2016-07-21 16:43:26"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/backend/cluster.py", "func_name": "H2OCluster.list_timezones", "original_string": "def list_timezones(self):\n        \"\"\"Return the list of all known timezones.\"\"\"\n        from h2o.expr import ExprNode\n        return h2o.H2OFrame._expr(expr=ExprNode(\"listTimeZones\"))._frame()", "language": "python", "code": "def list_timezones(self):\n        \"\"\"Return the list of all known timezones.\"\"\"\n        from h2o.expr import ExprNode\n        return h2o.H2OFrame._expr(expr=ExprNode(\"listTimeZones\"))._frame()", "code_tokens": ["def", "list_timezones", "(", "self", ")", ":", "from", "h2o", ".", "expr", "import", "ExprNode", "return", "h2o", ".", "H2OFrame", ".", "_expr", "(", "expr", "=", "ExprNode", "(", "\"listTimeZones\"", ")", ")", ".", "_frame", "(", ")"], "docstring": "Return the list of all known timezones.", "docstring_tokens": ["Return", "the", "list", "of", "all", "known", "timezones", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/backend/cluster.py#L303-L306", "partition": "test", "index": 1323, "time": "2016-08-04 12:08:14"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/utils/typechecks.py", "func_name": "NOT.check", "original_string": "def check(self, var):\n        \"\"\"Return True if the variable does not match any of the types, and False otherwise.\"\"\"\n        return not any(_check_type(var, tt) for tt in self._types)", "language": "python", "code": "def check(self, var):\n        \"\"\"Return True if the variable does not match any of the types, and False otherwise.\"\"\"\n        return not any(_check_type(var, tt) for tt in self._types)", "code_tokens": ["def", "check", "(", "self", ",", "var", ")", ":", "return", "not", "any", "(", "_check_type", "(", "var", ",", "tt", ")", "for", "tt", "in", "self", ".", "_types", ")"], "docstring": "Return True if the variable does not match any of the types, and False otherwise.", "docstring_tokens": ["Return", "True", "if", "the", "variable", "does", "not", "match", "any", "of", "the", "types", "and", "False", "otherwise", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/utils/typechecks.py#L226-L228", "partition": "test", "index": 1371, "time": "2016-08-15 14:47:11"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/model/model_base.py", "func_name": "ModelBase.default_params", "original_string": "def default_params(self):\n        \"\"\"Dictionary of the default parameters of the model.\"\"\"\n        params = {}\n        for p in self.parms:\n            params[p] = self.parms[p][\"default_value\"]\n        return params", "language": "python", "code": "def default_params(self):\n        \"\"\"Dictionary of the default parameters of the model.\"\"\"\n        params = {}\n        for p in self.parms:\n            params[p] = self.parms[p][\"default_value\"]\n        return params", "code_tokens": ["def", "default_params", "(", "self", ")", ":", "params", "=", "{", "}", "for", "p", "in", "self", ".", "parms", ":", "params", "[", "p", "]", "=", "self", ".", "parms", "[", "p", "]", "[", "\"default_value\"", "]", "return", "params"], "docstring": "Dictionary of the default parameters of the model.", "docstring_tokens": ["Dictionary", "of", "the", "default", "parameters", "of", "the", "model", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/model/model_base.py#L68-L73", "partition": "test", "index": 1533, "time": "2016-08-19 17:11:24"}
{"repo": "h2oai/h2o-3", "path": "h2o-bindings/bin/pyparser.py", "func_name": "ParsedBase.unparse", "original_string": "def unparse(self):\n        \"\"\"Convert the parsed representation back into the source code.\"\"\"\n        ut = Untokenizer(start_row=self._tokens[0].start_row)\n        self._unparse(ut)\n        return ut.result()", "language": "python", "code": "def unparse(self):\n        \"\"\"Convert the parsed representation back into the source code.\"\"\"\n        ut = Untokenizer(start_row=self._tokens[0].start_row)\n        self._unparse(ut)\n        return ut.result()", "code_tokens": ["def", "unparse", "(", "self", ")", ":", "ut", "=", "Untokenizer", "(", "start_row", "=", "self", ".", "_tokens", "[", "0", "]", ".", "start_row", ")", "self", ".", "_unparse", "(", "ut", ")", "return", "ut", ".", "result", "(", ")"], "docstring": "Convert the parsed representation back into the source code.", "docstring_tokens": ["Convert", "the", "parsed", "representation", "back", "into", "the", "source", "code", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-bindings/bin/pyparser.py#L365-L369", "partition": "test", "index": 1448, "time": "2016-08-24 15:16:21"}
{"repo": "h2oai/h2o-3", "path": "h2o-bindings/bin/pyparser.py", "func_name": "Token.move", "original_string": "def move(self, drow, dcol=0):\n        \"\"\"Move the token by `drow` rows and `dcol` columns.\"\"\"\n        self._start_row += drow\n        self._start_col += dcol\n        self._end_row += drow\n        self._end_col += dcol", "language": "python", "code": "def move(self, drow, dcol=0):\n        \"\"\"Move the token by `drow` rows and `dcol` columns.\"\"\"\n        self._start_row += drow\n        self._start_col += dcol\n        self._end_row += drow\n        self._end_col += dcol", "code_tokens": ["def", "move", "(", "self", ",", "drow", ",", "dcol", "=", "0", ")", ":", "self", ".", "_start_row", "+=", "drow", "self", ".", "_start_col", "+=", "dcol", "self", ".", "_end_row", "+=", "drow", "self", ".", "_end_col", "+=", "dcol"], "docstring": "Move the token by `drow` rows and `dcol` columns.", "docstring_tokens": ["Move", "the", "token", "by", "drow", "rows", "and", "dcol", "columns", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-bindings/bin/pyparser.py#L246-L251", "partition": "test", "index": 1447, "time": "2016-08-24 15:16:21"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/utils/typechecks.py", "func_name": "Enum.check", "original_string": "def check(self, var):\n        \"\"\"Check whether the provided value is a valid enum constant.\"\"\"\n        if not isinstance(var, _str_type): return False\n        return _enum_mangle(var) in self._consts", "language": "python", "code": "def check(self, var):\n        \"\"\"Check whether the provided value is a valid enum constant.\"\"\"\n        if not isinstance(var, _str_type): return False\n        return _enum_mangle(var) in self._consts", "code_tokens": ["def", "check", "(", "self", ",", "var", ")", ":", "if", "not", "isinstance", "(", "var", ",", "_str_type", ")", ":", "return", "False", "return", "_enum_mangle", "(", "var", ")", "in", "self", ".", "_consts"], "docstring": "Check whether the provided value is a valid enum constant.", "docstring_tokens": ["Check", "whether", "the", "provided", "value", "is", "a", "valid", "enum", "constant", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/utils/typechecks.py#L403-L406", "partition": "test", "index": 1372, "time": "2016-09-16 17:25:35"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/utils/config.py", "func_name": "H2OConfigReader.get_config", "original_string": "def get_config():\n        \"\"\"Retrieve the config as a dictionary of key-value pairs.\"\"\"\n        self = H2OConfigReader._get_instance()\n        if not self._config_loaded:\n            self._read_config()\n        return self._config", "language": "python", "code": "def get_config():\n        \"\"\"Retrieve the config as a dictionary of key-value pairs.\"\"\"\n        self = H2OConfigReader._get_instance()\n        if not self._config_loaded:\n            self._read_config()\n        return self._config", "code_tokens": ["def", "get_config", "(", ")", ":", "self", "=", "H2OConfigReader", ".", "_get_instance", "(", ")", "if", "not", "self", ".", "_config_loaded", ":", "self", ".", "_read_config", "(", ")", "return", "self", ".", "_config"], "docstring": "Retrieve the config as a dictionary of key-value pairs.", "docstring_tokens": ["Retrieve", "the", "config", "as", "a", "dictionary", "of", "key", "-", "value", "pairs", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/utils/config.py#L24-L29", "partition": "test", "index": 1373, "time": "2016-09-27 12:18:26"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/utils/shared_utils.py", "func_name": "slice_is_normalized", "original_string": "def slice_is_normalized(s):\n    \"\"\"Return True if slice ``s`` in \"normalized\" form.\"\"\"\n    return (s.start is not None and s.stop is not None and s.step is not None and s.start <= s.stop)", "language": "python", "code": "def slice_is_normalized(s):\n    \"\"\"Return True if slice ``s`` in \"normalized\" form.\"\"\"\n    return (s.start is not None and s.stop is not None and s.step is not None and s.start <= s.stop)", "code_tokens": ["def", "slice_is_normalized", "(", "s", ")", ":", "return", "(", "s", ".", "start", "is", "not", "None", "and", "s", ".", "stop", "is", "not", "None", "and", "s", ".", "step", "is", "not", "None", "and", "s", ".", "start", "<=", "s", ".", "stop", ")"], "docstring": "Return True if slice ``s`` in \"normalized\" form.", "docstring_tokens": ["Return", "True", "if", "slice", "s", "in", "normalized", "form", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/utils/shared_utils.py#L355-L357", "partition": "test", "index": 1479, "time": "2016-11-04 17:39:23"}
{"repo": "h2oai/h2o-3", "path": "py2/ec2_cmd.py", "func_name": "terminate_instances", "original_string": "def terminate_instances(instances, region):\n    '''terminate all the instances given by its ids'''\n    if not instances: return\n    conn = ec2_connect(region)\n    log(\"Terminating instances {0}.\".format(instances))\n    conn.terminate_instances(instances)\n    log(\"Done\")", "language": "python", "code": "def terminate_instances(instances, region):\n    '''terminate all the instances given by its ids'''\n    if not instances: return\n    conn = ec2_connect(region)\n    log(\"Terminating instances {0}.\".format(instances))\n    conn.terminate_instances(instances)\n    log(\"Done\")", "code_tokens": ["def", "terminate_instances", "(", "instances", ",", "region", ")", ":", "if", "not", "instances", ":", "return", "conn", "=", "ec2_connect", "(", "region", ")", "log", "(", "\"Terminating instances {0}.\"", ".", "format", "(", "instances", ")", ")", "conn", ".", "terminate_instances", "(", "instances", ")", "log", "(", "\"Done\"", ")"], "docstring": "terminate all the instances given by its ids", "docstring_tokens": ["terminate", "all", "the", "instances", "given", "by", "its", "ids"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/py2/ec2_cmd.py#L200-L206", "partition": "test", "index": 1336, "time": "2014-11-11 18:26:15"}
{"repo": "h2oai/h2o-3", "path": "py2/ec2_cmd.py", "func_name": "reboot_instances", "original_string": "def reboot_instances(instances, region):\n    '''Reboot all the instances given by its ids'''\n    if not instances: return\n    conn = ec2_connect(region)\n    log(\"Rebooting instances {0}.\".format(instances))\n    conn.reboot_instances(instances)\n    log(\"Done\")", "language": "python", "code": "def reboot_instances(instances, region):\n    '''Reboot all the instances given by its ids'''\n    if not instances: return\n    conn = ec2_connect(region)\n    log(\"Rebooting instances {0}.\".format(instances))\n    conn.reboot_instances(instances)\n    log(\"Done\")", "code_tokens": ["def", "reboot_instances", "(", "instances", ",", "region", ")", ":", "if", "not", "instances", ":", "return", "conn", "=", "ec2_connect", "(", "region", ")", "log", "(", "\"Rebooting instances {0}.\"", ".", "format", "(", "instances", ")", ")", "conn", ".", "reboot_instances", "(", "instances", ")", "log", "(", "\"Done\"", ")"], "docstring": "Reboot all the instances given by its ids", "docstring_tokens": ["Reboot", "all", "the", "instances", "given", "by", "its", "ids"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/py2/ec2_cmd.py#L224-L230", "partition": "test", "index": 1339, "time": "2014-11-11 18:26:15"}
{"repo": "h2oai/h2o-3", "path": "h2o-bindings/bin/gen_java.py", "func_name": "dedent", "original_string": "def dedent(ind, text):\n    \"\"\"\n    Dedent text to the specific indentation level.\n\n    :param ind: common indentation level for the resulting text (number of spaces to append to every line)\n    :param text: text that should be transformed.\n    :return: ``text`` with all common indentation removed, and then the specified amount of indentation added.\n    \"\"\"\n    text2 = textwrap.dedent(text)\n    if ind == 0:\n        return text2\n    indent_str = \" \" * ind\n    return \"\\n\".join(indent_str + line for line in text2.split(\"\\n\"))", "language": "python", "code": "def dedent(ind, text):\n    \"\"\"\n    Dedent text to the specific indentation level.\n\n    :param ind: common indentation level for the resulting text (number of spaces to append to every line)\n    :param text: text that should be transformed.\n    :return: ``text`` with all common indentation removed, and then the specified amount of indentation added.\n    \"\"\"\n    text2 = textwrap.dedent(text)\n    if ind == 0:\n        return text2\n    indent_str = \" \" * ind\n    return \"\\n\".join(indent_str + line for line in text2.split(\"\\n\"))", "code_tokens": ["def", "dedent", "(", "ind", ",", "text", ")", ":", "text2", "=", "textwrap", ".", "dedent", "(", "text", ")", "if", "ind", "==", "0", ":", "return", "text2", "indent_str", "=", "\" \"", "*", "ind", "return", "\"\\n\"", ".", "join", "(", "indent_str", "+", "line", "for", "line", "in", "text2", ".", "split", "(", "\"\\n\"", ")", ")"], "docstring": "Dedent text to the specific indentation level.", "docstring_tokens": ["Dedent", "text", "to", "the", "specific", "indentation", "level", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-bindings/bin/gen_java.py#L71-L83", "partition": "test", "index": 1495, "time": "2016-10-14 15:53:43"}
{"repo": "h2oai/h2o-3", "path": "scripts/extractGLRMRuntimeJavaLog.py", "func_name": "main", "original_string": "def main(argv):\n    \"\"\"\n    Main program.  Take user input, parse it and call other functions to execute the commands\n    and extract run summary and store run result in json file\n\n    @return: none\n    \"\"\"\n    global g_test_root_dir\n    global g_temp_filename\n\n    if len(argv) < 2:\n        print(\"invoke this script as python extractGLRMRuntimeJavaLog.py javatextlog.\\n\")\n        sys.exit(1)\n    else:   # we may be in business\n        javaLogText = argv[1]         # filename while java log is stored\n\n        print(\"your java text is {0}\".format(javaLogText))\n        extractRunInto(javaLogText)", "language": "python", "code": "def main(argv):\n    \"\"\"\n    Main program.  Take user input, parse it and call other functions to execute the commands\n    and extract run summary and store run result in json file\n\n    @return: none\n    \"\"\"\n    global g_test_root_dir\n    global g_temp_filename\n\n    if len(argv) < 2:\n        print(\"invoke this script as python extractGLRMRuntimeJavaLog.py javatextlog.\\n\")\n        sys.exit(1)\n    else:   # we may be in business\n        javaLogText = argv[1]         # filename while java log is stored\n\n        print(\"your java text is {0}\".format(javaLogText))\n        extractRunInto(javaLogText)", "code_tokens": ["def", "main", "(", "argv", ")", ":", "global", "g_test_root_dir", "global", "g_temp_filename", "if", "len", "(", "argv", ")", "<", "2", ":", "print", "(", "\"invoke this script as python extractGLRMRuntimeJavaLog.py javatextlog.\\n\"", ")", "sys", ".", "exit", "(", "1", ")", "else", ":", "# we may be in business", "javaLogText", "=", "argv", "[", "1", "]", "# filename while java log is stored", "print", "(", "\"your java text is {0}\"", ".", "format", "(", "javaLogText", ")", ")", "extractRunInto", "(", "javaLogText", ")"], "docstring": "Main program.  Take user input, parse it and call other functions to execute the commands\n    and extract run summary and store run result in json file\n\n    @return: none", "docstring_tokens": ["Main", "program", ".", "Take", "user", "input", "parse", "it", "and", "call", "other", "functions", "to", "execute", "the", "commands", "and", "extract", "run", "summary", "and", "store", "run", "result", "in", "json", "file"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/scripts/extractGLRMRuntimeJavaLog.py#L115-L132", "partition": "test", "index": 1497, "time": "2016-10-18 16:23:53"}
{"repo": "h2oai/h2o-3", "path": "scripts/extractGLRMRuntimeJavaLog.py", "func_name": "extractRunInto", "original_string": "def extractRunInto(javaLogText):\n    \"\"\"\n    This function will extract the various operation time for GLRM model building iterations.\n\n    :param javaLogText:\n    :return:\n    \"\"\"\n    global g_initialXY\n    global g_reguarlize_Y\n    global g_regularize_X_objective\n    global g_updateX\n    global g_updateY\n    global g_objective\n    global g_stepsize\n    global g_history\n\n\n    if os.path.isfile(javaLogText):\n\n        run_result = dict()\n        run_result[\"total time (ms)\"] = []\n        run_result[\"initialXY (ms)\"] = []\n        run_result[\"regularize Y (ms)\"] = []\n        run_result[\"regularize X and objective (ms)\"] = []\n        run_result[\"update X (ms)\"] = []\n        run_result[\"update Y (ms)\"] = []\n        run_result[\"objective (ms)\"] = []\n        run_result[\"step size (ms)\"] = []\n        run_result[\"update history (ms)\"] = []\n\n        total_run_time = -1\n        val = 0.0\n        with open(javaLogText, 'r') as thefile:   # go into tempfile and grab test run info\n            for each_line in thefile:\n                temp_string = each_line.split()\n\n                if len(temp_string) > 0:\n                    val = temp_string[-1].replace('\\\\','')\n\n                if g_initialXY in each_line:    # start of a new file\n                    if total_run_time > 0:  # update total run time\n                        run_result[\"total time (ms)\"].append(total_run_time)\n                        total_run_time = 0.0\n                    else:\n                        total_run_time = 0.0\n\n                    run_result[\"initialXY (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_reguarlize_Y in each_line:\n                    run_result[\"regularize Y (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_regularize_X_objective in each_line:\n                    run_result[\"regularize X and objective (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_updateX in each_line:\n                    run_result[\"update X (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_updateY in each_line:\n                    run_result[\"update Y (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_objective in each_line:\n                    run_result[\"objective (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_stepsize in each_line:\n                    run_result[\"step size (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_history in each_line:\n                    run_result[\"update history (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n        run_result[\"total time (ms)\"].append(total_run_time)    # save the last one\n        print(\"Run result summary: \\n {0}\".format(run_result))\n\n    else:\n        print(\"Cannot find your java log file.  Nothing is done.\\n\")", "language": "python", "code": "def extractRunInto(javaLogText):\n    \"\"\"\n    This function will extract the various operation time for GLRM model building iterations.\n\n    :param javaLogText:\n    :return:\n    \"\"\"\n    global g_initialXY\n    global g_reguarlize_Y\n    global g_regularize_X_objective\n    global g_updateX\n    global g_updateY\n    global g_objective\n    global g_stepsize\n    global g_history\n\n\n    if os.path.isfile(javaLogText):\n\n        run_result = dict()\n        run_result[\"total time (ms)\"] = []\n        run_result[\"initialXY (ms)\"] = []\n        run_result[\"regularize Y (ms)\"] = []\n        run_result[\"regularize X and objective (ms)\"] = []\n        run_result[\"update X (ms)\"] = []\n        run_result[\"update Y (ms)\"] = []\n        run_result[\"objective (ms)\"] = []\n        run_result[\"step size (ms)\"] = []\n        run_result[\"update history (ms)\"] = []\n\n        total_run_time = -1\n        val = 0.0\n        with open(javaLogText, 'r') as thefile:   # go into tempfile and grab test run info\n            for each_line in thefile:\n                temp_string = each_line.split()\n\n                if len(temp_string) > 0:\n                    val = temp_string[-1].replace('\\\\','')\n\n                if g_initialXY in each_line:    # start of a new file\n                    if total_run_time > 0:  # update total run time\n                        run_result[\"total time (ms)\"].append(total_run_time)\n                        total_run_time = 0.0\n                    else:\n                        total_run_time = 0.0\n\n                    run_result[\"initialXY (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_reguarlize_Y in each_line:\n                    run_result[\"regularize Y (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_regularize_X_objective in each_line:\n                    run_result[\"regularize X and objective (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_updateX in each_line:\n                    run_result[\"update X (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_updateY in each_line:\n                    run_result[\"update Y (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_objective in each_line:\n                    run_result[\"objective (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_stepsize in each_line:\n                    run_result[\"step size (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_history in each_line:\n                    run_result[\"update history (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n        run_result[\"total time (ms)\"].append(total_run_time)    # save the last one\n        print(\"Run result summary: \\n {0}\".format(run_result))\n\n    else:\n        print(\"Cannot find your java log file.  Nothing is done.\\n\")", "code_tokens": ["def", "extractRunInto", "(", "javaLogText", ")", ":", "global", "g_initialXY", "global", "g_reguarlize_Y", "global", "g_regularize_X_objective", "global", "g_updateX", "global", "g_updateY", "global", "g_objective", "global", "g_stepsize", "global", "g_history", "if", "os", ".", "path", ".", "isfile", "(", "javaLogText", ")", ":", "run_result", "=", "dict", "(", ")", "run_result", "[", "\"total time (ms)\"", "]", "=", "[", "]", "run_result", "[", "\"initialXY (ms)\"", "]", "=", "[", "]", "run_result", "[", "\"regularize Y (ms)\"", "]", "=", "[", "]", "run_result", "[", "\"regularize X and objective (ms)\"", "]", "=", "[", "]", "run_result", "[", "\"update X (ms)\"", "]", "=", "[", "]", "run_result", "[", "\"update Y (ms)\"", "]", "=", "[", "]", "run_result", "[", "\"objective (ms)\"", "]", "=", "[", "]", "run_result", "[", "\"step size (ms)\"", "]", "=", "[", "]", "run_result", "[", "\"update history (ms)\"", "]", "=", "[", "]", "total_run_time", "=", "-", "1", "val", "=", "0.0", "with", "open", "(", "javaLogText", ",", "'r'", ")", "as", "thefile", ":", "# go into tempfile and grab test run info", "for", "each_line", "in", "thefile", ":", "temp_string", "=", "each_line", ".", "split", "(", ")", "if", "len", "(", "temp_string", ")", ">", "0", ":", "val", "=", "temp_string", "[", "-", "1", "]", ".", "replace", "(", "'\\\\'", ",", "''", ")", "if", "g_initialXY", "in", "each_line", ":", "# start of a new file", "if", "total_run_time", ">", "0", ":", "# update total run time", "run_result", "[", "\"total time (ms)\"", "]", ".", "append", "(", "total_run_time", ")", "total_run_time", "=", "0.0", "else", ":", "total_run_time", "=", "0.0", "run_result", "[", "\"initialXY (ms)\"", "]", ".", "append", "(", "float", "(", "val", ")", ")", "total_run_time", "=", "total_run_time", "+", "float", "(", "val", ")", "if", "g_reguarlize_Y", "in", "each_line", ":", "run_result", "[", "\"regularize Y (ms)\"", "]", ".", "append", "(", "float", "(", "val", ")", ")", "total_run_time", "=", "total_run_time", "+", "float", "(", "val", ")", "if", "g_regularize_X_objective", "in", "each_line", ":", "run_result", "[", "\"regularize X and objective (ms)\"", "]", ".", "append", "(", "float", "(", "val", ")", ")", "total_run_time", "=", "total_run_time", "+", "float", "(", "val", ")", "if", "g_updateX", "in", "each_line", ":", "run_result", "[", "\"update X (ms)\"", "]", ".", "append", "(", "float", "(", "val", ")", ")", "total_run_time", "=", "total_run_time", "+", "float", "(", "val", ")", "if", "g_updateY", "in", "each_line", ":", "run_result", "[", "\"update Y (ms)\"", "]", ".", "append", "(", "float", "(", "val", ")", ")", "total_run_time", "=", "total_run_time", "+", "float", "(", "val", ")", "if", "g_objective", "in", "each_line", ":", "run_result", "[", "\"objective (ms)\"", "]", ".", "append", "(", "float", "(", "val", ")", ")", "total_run_time", "=", "total_run_time", "+", "float", "(", "val", ")", "if", "g_stepsize", "in", "each_line", ":", "run_result", "[", "\"step size (ms)\"", "]", ".", "append", "(", "float", "(", "val", ")", ")", "total_run_time", "=", "total_run_time", "+", "float", "(", "val", ")", "if", "g_history", "in", "each_line", ":", "run_result", "[", "\"update history (ms)\"", "]", ".", "append", "(", "float", "(", "val", ")", ")", "total_run_time", "=", "total_run_time", "+", "float", "(", "val", ")", "run_result", "[", "\"total time (ms)\"", "]", ".", "append", "(", "total_run_time", ")", "# save the last one", "print", "(", "\"Run result summary: \\n {0}\"", ".", "format", "(", "run_result", ")", ")", "else", ":", "print", "(", "\"Cannot find your java log file.  Nothing is done.\\n\"", ")"], "docstring": "This function will extract the various operation time for GLRM model building iterations.\n\n    :param javaLogText:\n    :return:", "docstring_tokens": ["This", "function", "will", "extract", "the", "various", "operation", "time", "for", "GLRM", "model", "building", "iterations", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/scripts/extractGLRMRuntimeJavaLog.py#L31-L112", "partition": "test", "index": 1496, "time": "2016-10-18 16:23:53"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/utils/shared_utils.py", "func_name": "normalize_slice", "original_string": "def normalize_slice(s, total):\n    \"\"\"\n    Return a \"canonical\" version of slice ``s``.\n\n    :param slice s: the original slice expression\n    :param total int: total number of elements in the collection sliced by ``s``\n    :return slice: a slice equivalent to ``s`` but not containing any negative indices or Nones.\n    \"\"\"\n    newstart = 0 if s.start is None else max(0, s.start + total) if s.start < 0 else min(s.start, total)\n    newstop = total if s.stop is None else max(0, s.stop + total) if s.stop < 0 else min(s.stop, total)\n    newstep = 1 if s.step is None else s.step\n    return slice(newstart, newstop, newstep)", "language": "python", "code": "def normalize_slice(s, total):\n    \"\"\"\n    Return a \"canonical\" version of slice ``s``.\n\n    :param slice s: the original slice expression\n    :param total int: total number of elements in the collection sliced by ``s``\n    :return slice: a slice equivalent to ``s`` but not containing any negative indices or Nones.\n    \"\"\"\n    newstart = 0 if s.start is None else max(0, s.start + total) if s.start < 0 else min(s.start, total)\n    newstop = total if s.stop is None else max(0, s.stop + total) if s.stop < 0 else min(s.stop, total)\n    newstep = 1 if s.step is None else s.step\n    return slice(newstart, newstop, newstep)", "code_tokens": ["def", "normalize_slice", "(", "s", ",", "total", ")", ":", "newstart", "=", "0", "if", "s", ".", "start", "is", "None", "else", "max", "(", "0", ",", "s", ".", "start", "+", "total", ")", "if", "s", ".", "start", "<", "0", "else", "min", "(", "s", ".", "start", ",", "total", ")", "newstop", "=", "total", "if", "s", ".", "stop", "is", "None", "else", "max", "(", "0", ",", "s", ".", "stop", "+", "total", ")", "if", "s", ".", "stop", "<", "0", "else", "min", "(", "s", ".", "stop", ",", "total", ")", "newstep", "=", "1", "if", "s", ".", "step", "is", "None", "else", "s", ".", "step", "return", "slice", "(", "newstart", ",", "newstop", ",", "newstep", ")"], "docstring": "Return a \"canonical\" version of slice.", "docstring_tokens": ["Return", "a", "canonical", "version", "of", "slice", "s", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/utils/shared_utils.py#L341-L352", "partition": "test", "index": 1478, "time": "2016-11-04 17:39:23"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/utils/shared_utils.py", "func_name": "check_frame_id", "original_string": "def check_frame_id(frame_id):\n    \"\"\"Check that the provided frame id is valid in Rapids language.\"\"\"\n    if frame_id is None:\n        return\n    if frame_id.strip() == \"\":\n        raise H2OValueError(\"Frame id cannot be an empty string: %r\" % frame_id)\n    for i, ch in enumerate(frame_id):\n        # '$' character has special meaning at the beginning of the string; and prohibited anywhere else\n        if ch == \"$\" and i == 0: continue\n        if ch not in _id_allowed_characters:\n            raise H2OValueError(\"Character '%s' is illegal in frame id: %s\" % (ch, frame_id))\n    if re.match(r\"-?[0-9]\", frame_id):\n        raise H2OValueError(\"Frame id cannot start with a number: %s\" % frame_id)", "language": "python", "code": "def check_frame_id(frame_id):\n    \"\"\"Check that the provided frame id is valid in Rapids language.\"\"\"\n    if frame_id is None:\n        return\n    if frame_id.strip() == \"\":\n        raise H2OValueError(\"Frame id cannot be an empty string: %r\" % frame_id)\n    for i, ch in enumerate(frame_id):\n        # '$' character has special meaning at the beginning of the string; and prohibited anywhere else\n        if ch == \"$\" and i == 0: continue\n        if ch not in _id_allowed_characters:\n            raise H2OValueError(\"Character '%s' is illegal in frame id: %s\" % (ch, frame_id))\n    if re.match(r\"-?[0-9]\", frame_id):\n        raise H2OValueError(\"Frame id cannot start with a number: %s\" % frame_id)", "code_tokens": ["def", "check_frame_id", "(", "frame_id", ")", ":", "if", "frame_id", "is", "None", ":", "return", "if", "frame_id", ".", "strip", "(", ")", "==", "\"\"", ":", "raise", "H2OValueError", "(", "\"Frame id cannot be an empty string: %r\"", "%", "frame_id", ")", "for", "i", ",", "ch", "in", "enumerate", "(", "frame_id", ")", ":", "# '$' character has special meaning at the beginning of the string; and prohibited anywhere else", "if", "ch", "==", "\"$\"", "and", "i", "==", "0", ":", "continue", "if", "ch", "not", "in", "_id_allowed_characters", ":", "raise", "H2OValueError", "(", "\"Character '%s' is illegal in frame id: %s\"", "%", "(", "ch", ",", "frame_id", ")", ")", "if", "re", ".", "match", "(", "r\"-?[0-9]\"", ",", "frame_id", ")", ":", "raise", "H2OValueError", "(", "\"Frame id cannot start with a number: %s\"", "%", "frame_id", ")"], "docstring": "Check that the provided frame id is valid in Rapids language.", "docstring_tokens": ["Check", "that", "the", "provided", "frame", "id", "is", "valid", "in", "Rapids", "language", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/utils/shared_utils.py#L46-L58", "partition": "test", "index": 1476, "time": "2016-11-04 19:13:04"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/frame.py", "func_name": "H2OFrame.type", "original_string": "def type(self, col):\n        \"\"\"\n        The type for the given column.\n\n        :param col: either a name, or an index of the column to look up\n        :returns: type of the column, one of: ``str``, ``int``, ``real``, ``enum``, ``time``, ``bool``.\n        :raises H2OValueError: if such column does not exist in the frame.\n        \"\"\"\n        assert_is_type(col, int, str)\n        if not self._ex._cache.types_valid() or not self._ex._cache.names_valid():\n            self._ex._cache.flush()\n            self._frame(fill_cache=True)\n        types = self._ex._cache.types\n        if is_type(col, str):\n            if col in types:\n                return types[col]\n        else:\n            names = self._ex._cache.names\n            if -len(names) <= col < len(names):\n                return types[names[col]]\n        raise H2OValueError(\"Column '%r' does not exist in the frame\" % col)", "language": "python", "code": "def type(self, col):\n        \"\"\"\n        The type for the given column.\n\n        :param col: either a name, or an index of the column to look up\n        :returns: type of the column, one of: ``str``, ``int``, ``real``, ``enum``, ``time``, ``bool``.\n        :raises H2OValueError: if such column does not exist in the frame.\n        \"\"\"\n        assert_is_type(col, int, str)\n        if not self._ex._cache.types_valid() or not self._ex._cache.names_valid():\n            self._ex._cache.flush()\n            self._frame(fill_cache=True)\n        types = self._ex._cache.types\n        if is_type(col, str):\n            if col in types:\n                return types[col]\n        else:\n            names = self._ex._cache.names\n            if -len(names) <= col < len(names):\n                return types[names[col]]\n        raise H2OValueError(\"Column '%r' does not exist in the frame\" % col)", "code_tokens": ["def", "type", "(", "self", ",", "col", ")", ":", "assert_is_type", "(", "col", ",", "int", ",", "str", ")", "if", "not", "self", ".", "_ex", ".", "_cache", ".", "types_valid", "(", ")", "or", "not", "self", ".", "_ex", ".", "_cache", ".", "names_valid", "(", ")", ":", "self", ".", "_ex", ".", "_cache", ".", "flush", "(", ")", "self", ".", "_frame", "(", "fill_cache", "=", "True", ")", "types", "=", "self", ".", "_ex", ".", "_cache", ".", "types", "if", "is_type", "(", "col", ",", "str", ")", ":", "if", "col", "in", "types", ":", "return", "types", "[", "col", "]", "else", ":", "names", "=", "self", ".", "_ex", ".", "_cache", ".", "names", "if", "-", "len", "(", "names", ")", "<=", "col", "<", "len", "(", "names", ")", ":", "return", "types", "[", "names", "[", "col", "]", "]", "raise", "H2OValueError", "(", "\"Column '%r' does not exist in the frame\"", "%", "col", ")"], "docstring": "The type for the given column.\n\n        :param col: either a name, or an index of the column to look up\n        :returns: type of the column, one of: ``str``, ``int``, ``real``, ``enum``, ``time``, ``bool``.\n        :raises H2OValueError: if such column does not exist in the frame.", "docstring_tokens": ["The", "type", "for", "the", "given", "column", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/frame.py#L289-L309", "partition": "test", "index": 1390, "time": "2016-11-23 15:05:04"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/model/word_embedding.py", "func_name": "H2OWordEmbeddingModel.find_synonyms", "original_string": "def find_synonyms(self, word, count=20):\n        \"\"\"\n        Find synonyms using a word2vec model.\n\n        :param str word: A single word to find synonyms for.\n        :param int count: The first \"count\" synonyms will be returned.\n\n        :returns: the approximate reconstruction of the training data.\n        \"\"\"\n        j = h2o.api(\"GET /3/Word2VecSynonyms\", data={'model': self.model_id, 'word': word, 'count': count})\n        return OrderedDict(sorted(zip(j['synonyms'], j['scores']), key=lambda t: t[1], reverse=True))", "language": "python", "code": "def find_synonyms(self, word, count=20):\n        \"\"\"\n        Find synonyms using a word2vec model.\n\n        :param str word: A single word to find synonyms for.\n        :param int count: The first \"count\" synonyms will be returned.\n\n        :returns: the approximate reconstruction of the training data.\n        \"\"\"\n        j = h2o.api(\"GET /3/Word2VecSynonyms\", data={'model': self.model_id, 'word': word, 'count': count})\n        return OrderedDict(sorted(zip(j['synonyms'], j['scores']), key=lambda t: t[1], reverse=True))", "code_tokens": ["def", "find_synonyms", "(", "self", ",", "word", ",", "count", "=", "20", ")", ":", "j", "=", "h2o", ".", "api", "(", "\"GET /3/Word2VecSynonyms\"", ",", "data", "=", "{", "'model'", ":", "self", ".", "model_id", ",", "'word'", ":", "word", ",", "'count'", ":", "count", "}", ")", "return", "OrderedDict", "(", "sorted", "(", "zip", "(", "j", "[", "'synonyms'", "]", ",", "j", "[", "'scores'", "]", ")", ",", "key", "=", "lambda", "t", ":", "t", "[", "1", "]", ",", "reverse", "=", "True", ")", ")"], "docstring": "Find synonyms using a word2vec model.\n\n        :param str word: A single word to find synonyms for.\n        :param int count: The first \"count\" synonyms will be returned.\n\n        :returns: the approximate reconstruction of the training data.", "docstring_tokens": ["Find", "synonyms", "using", "a", "word2vec", "model", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/model/word_embedding.py#L17-L27", "partition": "test", "index": 1528, "time": "2017-01-06 16:37:08"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/frame.py", "func_name": "H2OFrame.minute", "original_string": "def minute(self):\n        \"\"\"\n        Extract the \"minute\" part from a date column.\n\n        :returns: a single-column H2OFrame containing the \"minute\" part from the source frame.\n        \"\"\"\n        fr = H2OFrame._expr(expr=ExprNode(\"minute\", self), cache=self._ex._cache)\n        if fr._ex._cache.types_valid():\n            fr._ex._cache.types = {k: \"int\" for k in self._ex._cache.types.keys()}\n        return fr", "language": "python", "code": "def minute(self):\n        \"\"\"\n        Extract the \"minute\" part from a date column.\n\n        :returns: a single-column H2OFrame containing the \"minute\" part from the source frame.\n        \"\"\"\n        fr = H2OFrame._expr(expr=ExprNode(\"minute\", self), cache=self._ex._cache)\n        if fr._ex._cache.types_valid():\n            fr._ex._cache.types = {k: \"int\" for k in self._ex._cache.types.keys()}\n        return fr", "code_tokens": ["def", "minute", "(", "self", ")", ":", "fr", "=", "H2OFrame", ".", "_expr", "(", "expr", "=", "ExprNode", "(", "\"minute\"", ",", "self", ")", ",", "cache", "=", "self", ".", "_ex", ".", "_cache", ")", "if", "fr", ".", "_ex", ".", "_cache", ".", "types_valid", "(", ")", ":", "fr", ".", "_ex", ".", "_cache", ".", "types", "=", "{", "k", ":", "\"int\"", "for", "k", "in", "self", ".", "_ex", ".", "_cache", ".", "types", ".", "keys", "(", ")", "}", "return", "fr"], "docstring": "Extract the \"minute\" part from a date column.\n\n        :returns: a single-column H2OFrame containing the \"minute\" part from the source frame.", "docstring_tokens": ["Extract", "the", "minute", "part", "from", "a", "date", "column", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/frame.py#L3143-L3152", "partition": "test", "index": 1439, "time": "2017-01-19 17:45:19"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/model/model_base.py", "func_name": "ModelBase.save_model_details", "original_string": "def save_model_details(self, path=\"\", force=False):\n        \"\"\"\n        Save Model Details of an H2O Model in JSON Format to disk.\n\n        :param model: The model object to save.\n        :param path: a path to save the model details at (hdfs, s3, local)\n        :param force: if True overwrite destination directory in case it exists, or throw exception if set to False.\n\n        :returns str: the path of the saved model details\n        \"\"\"\n        assert_is_type(path, str)\n        assert_is_type(force, bool)\n        path = os.path.join(os.getcwd() if path == \"\" else path, self.model_id + \".json\")\n        return h2o.api(\"GET /99/Models/%s/json\" % self.model_id, data={\"dir\": path, \"force\": force})[\"dir\"]", "language": "python", "code": "def save_model_details(self, path=\"\", force=False):\n        \"\"\"\n        Save Model Details of an H2O Model in JSON Format to disk.\n\n        :param model: The model object to save.\n        :param path: a path to save the model details at (hdfs, s3, local)\n        :param force: if True overwrite destination directory in case it exists, or throw exception if set to False.\n\n        :returns str: the path of the saved model details\n        \"\"\"\n        assert_is_type(path, str)\n        assert_is_type(force, bool)\n        path = os.path.join(os.getcwd() if path == \"\" else path, self.model_id + \".json\")\n        return h2o.api(\"GET /99/Models/%s/json\" % self.model_id, data={\"dir\": path, \"force\": force})[\"dir\"]", "code_tokens": ["def", "save_model_details", "(", "self", ",", "path", "=", "\"\"", ",", "force", "=", "False", ")", ":", "assert_is_type", "(", "path", ",", "str", ")", "assert_is_type", "(", "force", ",", "bool", ")", "path", "=", "os", ".", "path", ".", "join", "(", "os", ".", "getcwd", "(", ")", "if", "path", "==", "\"\"", "else", "path", ",", "self", ".", "model_id", "+", "\".json\"", ")", "return", "h2o", ".", "api", "(", "\"GET /99/Models/%s/json\"", "%", "self", ".", "model_id", ",", "data", "=", "{", "\"dir\"", ":", "path", ",", "\"force\"", ":", "force", "}", ")", "[", "\"dir\"", "]"], "docstring": "Save Model Details of an H2O Model in JSON Format to disk.", "docstring_tokens": ["Save", "Model", "Details", "of", "an", "H2O", "Model", "in", "JSON", "Format", "to", "disk", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/model/model_base.py#L840-L853", "partition": "test", "index": 1543, "time": "2017-02-01 16:15:11"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/frame.py", "func_name": "H2OFrame.distance", "original_string": "def distance(self, y, measure=None):\n        \"\"\"\n        Compute a pairwise distance measure between all rows of two numeric H2OFrames.\n\n        :param H2OFrame y: Frame containing queries (small)\n        :param str use: A string indicating what distance measure to use. Must be one of:\n\n            - ``\"l1\"``:        Absolute distance (L1-norm, >=0)\n            - ``\"l2\"``:        Euclidean distance (L2-norm, >=0)\n            - ``\"cosine\"``:    Cosine similarity (-1...1)\n            - ``\"cosine_sq\"``: Squared Cosine similarity (0...1)\n\n        :examples:\n          >>>\n          >>> iris_h2o = h2o.import_file(path=pyunit_utils.locate(\"smalldata/iris/iris.csv\"))\n          >>> references = iris_h2o[10:150,0:4\n          >>> queries    = iris_h2o[0:10,0:4]\n          >>> A = references.distance(queries, \"l1\")\n          >>> B = references.distance(queries, \"l2\")\n          >>> C = references.distance(queries, \"cosine\")\n          >>> D = references.distance(queries, \"cosine_sq\")\n          >>> E = queries.distance(references, \"l1\")\n          >>> (E.transpose() == A).all()\n\n        :returns: An H2OFrame of the matrix containing pairwise distance / similarity between the \n            rows of this frame (N x p) and ``y`` (M x p), with dimensions (N x M).\n        \"\"\"\n        assert_is_type(y, H2OFrame)\n        if measure is None: measure = \"l2\"\n        return H2OFrame._expr(expr=ExprNode(\"distance\", self, y, measure))._frame()", "language": "python", "code": "def distance(self, y, measure=None):\n        \"\"\"\n        Compute a pairwise distance measure between all rows of two numeric H2OFrames.\n\n        :param H2OFrame y: Frame containing queries (small)\n        :param str use: A string indicating what distance measure to use. Must be one of:\n\n            - ``\"l1\"``:        Absolute distance (L1-norm, >=0)\n            - ``\"l2\"``:        Euclidean distance (L2-norm, >=0)\n            - ``\"cosine\"``:    Cosine similarity (-1...1)\n            - ``\"cosine_sq\"``: Squared Cosine similarity (0...1)\n\n        :examples:\n          >>>\n          >>> iris_h2o = h2o.import_file(path=pyunit_utils.locate(\"smalldata/iris/iris.csv\"))\n          >>> references = iris_h2o[10:150,0:4\n          >>> queries    = iris_h2o[0:10,0:4]\n          >>> A = references.distance(queries, \"l1\")\n          >>> B = references.distance(queries, \"l2\")\n          >>> C = references.distance(queries, \"cosine\")\n          >>> D = references.distance(queries, \"cosine_sq\")\n          >>> E = queries.distance(references, \"l1\")\n          >>> (E.transpose() == A).all()\n\n        :returns: An H2OFrame of the matrix containing pairwise distance / similarity between the \n            rows of this frame (N x p) and ``y`` (M x p), with dimensions (N x M).\n        \"\"\"\n        assert_is_type(y, H2OFrame)\n        if measure is None: measure = \"l2\"\n        return H2OFrame._expr(expr=ExprNode(\"distance\", self, y, measure))._frame()", "code_tokens": ["def", "distance", "(", "self", ",", "y", ",", "measure", "=", "None", ")", ":", "assert_is_type", "(", "y", ",", "H2OFrame", ")", "if", "measure", "is", "None", ":", "measure", "=", "\"l2\"", "return", "H2OFrame", ".", "_expr", "(", "expr", "=", "ExprNode", "(", "\"distance\"", ",", "self", ",", "y", ",", "measure", ")", ")", ".", "_frame", "(", ")"], "docstring": "Compute a pairwise distance measure between all rows of two numeric H2OFrames.", "docstring_tokens": ["Compute", "a", "pairwise", "distance", "measure", "between", "all", "rows", "of", "two", "numeric", "H2OFrames", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/frame.py#L2214-L2243", "partition": "test", "index": 1422, "time": "2017-03-15 18:50:55"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/frame.py", "func_name": "H2OFrame.idxmax", "original_string": "def idxmax(self,skipna=True, axis=0):\n        \"\"\"\n        Get the index of the max value in a column or row\n\n        :param bool skipna: If True (default), then NAs are ignored during the search. Otherwise presence\n            of NAs renders the entire result NA.\n        :param int axis: Direction of finding the max index. If 0 (default), then the max index is searched columnwise, and the\n            result is a frame with 1 row and number of columns as in the original frame. If 1, then the max index is searched\n            rowwise and the result is a frame with 1 column, and number of rows equal to the number of rows in the original frame.\n        :returns: either a list of max index values per-column or an H2OFrame containing max index values\n                  per-row from the original frame.\n        \"\"\"\n        return H2OFrame._expr(expr=ExprNode(\"which.max\", self, skipna, axis))", "language": "python", "code": "def idxmax(self,skipna=True, axis=0):\n        \"\"\"\n        Get the index of the max value in a column or row\n\n        :param bool skipna: If True (default), then NAs are ignored during the search. Otherwise presence\n            of NAs renders the entire result NA.\n        :param int axis: Direction of finding the max index. If 0 (default), then the max index is searched columnwise, and the\n            result is a frame with 1 row and number of columns as in the original frame. If 1, then the max index is searched\n            rowwise and the result is a frame with 1 column, and number of rows equal to the number of rows in the original frame.\n        :returns: either a list of max index values per-column or an H2OFrame containing max index values\n                  per-row from the original frame.\n        \"\"\"\n        return H2OFrame._expr(expr=ExprNode(\"which.max\", self, skipna, axis))", "code_tokens": ["def", "idxmax", "(", "self", ",", "skipna", "=", "True", ",", "axis", "=", "0", ")", ":", "return", "H2OFrame", ".", "_expr", "(", "expr", "=", "ExprNode", "(", "\"which.max\"", ",", "self", ",", "skipna", ",", "axis", ")", ")"], "docstring": "Get the index of the max value in a column or row", "docstring_tokens": ["Get", "the", "index", "of", "the", "max", "value", "in", "a", "column", "or", "row"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/frame.py#L3256-L3268", "partition": "test", "index": 1443, "time": "2017-03-16 19:19:22"}
{"repo": "h2oai/h2o-3", "path": "scripts/scrapeForIntermittents.py", "func_name": "trim_data_back_to", "original_string": "def trim_data_back_to(monthToKeep):\n    \"\"\"\n    This method will remove data from the summary text file and the dictionary file for tests that occurs before\n    the number of months specified by monthToKeep.\n\n    :param monthToKeep:\n    :return:\n    \"\"\"\n    global g_failed_tests_info_dict\n    current_time = time.time()      # unit in seconds\n\n    oldest_time_allowed = current_time - monthToKeep*30*24*3600 # in seconds\n\n    clean_up_failed_test_dict(oldest_time_allowed)\n    clean_up_summary_text(oldest_time_allowed)", "language": "python", "code": "def trim_data_back_to(monthToKeep):\n    \"\"\"\n    This method will remove data from the summary text file and the dictionary file for tests that occurs before\n    the number of months specified by monthToKeep.\n\n    :param monthToKeep:\n    :return:\n    \"\"\"\n    global g_failed_tests_info_dict\n    current_time = time.time()      # unit in seconds\n\n    oldest_time_allowed = current_time - monthToKeep*30*24*3600 # in seconds\n\n    clean_up_failed_test_dict(oldest_time_allowed)\n    clean_up_summary_text(oldest_time_allowed)", "code_tokens": ["def", "trim_data_back_to", "(", "monthToKeep", ")", ":", "global", "g_failed_tests_info_dict", "current_time", "=", "time", ".", "time", "(", ")", "# unit in seconds", "oldest_time_allowed", "=", "current_time", "-", "monthToKeep", "*", "30", "*", "24", "*", "3600", "# in seconds", "clean_up_failed_test_dict", "(", "oldest_time_allowed", ")", "clean_up_summary_text", "(", "oldest_time_allowed", ")"], "docstring": "This method will remove data from the summary text file and the dictionary file for tests that occurs before\n    the number of months specified by monthToKeep.\n\n    :param monthToKeep:\n    :return:", "docstring_tokens": ["This", "method", "will", "remove", "data", "from", "the", "summary", "text", "file", "and", "the", "dictionary", "file", "for", "tests", "that", "occurs", "before", "the", "number", "of", "months", "specified", "by", "monthToKeep", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/scripts/scrapeForIntermittents.py#L231-L245", "partition": "test", "index": 1582, "time": "2017-03-29 09:53:43"}
{"repo": "h2oai/h2o-3", "path": "scripts/summarizeIntermittens.py", "func_name": "extractPrintSaveIntermittens", "original_string": "def extractPrintSaveIntermittens():\n    \"\"\"\n    This function will print out the intermittents onto the screen for casual viewing.  It will also print out\n    where the giant summary dictionary is going to be stored.\n\n    :return: None\n    \"\"\"\n    # extract intermittents from collected failed tests\n    global g_summary_dict_intermittents\n\n    localtz = time.tzname[0]\n\n\n    for ind in range(len(g_summary_dict_all[\"TestName\"])):\n        if g_summary_dict_all[\"TestInfo\"][ind][\"FailureCount\"] >= g_threshold_failure:\n            addFailedTests(g_summary_dict_intermittents, g_summary_dict_all, ind)\n\n    # save dict in file\n    if len(g_summary_dict_intermittents[\"TestName\"]) > 0:\n        json.dump(g_summary_dict_intermittents, open(g_summary_dict_name, 'w'))\n\n        with open(g_summary_csv_filename, 'w') as summaryFile:\n            for ind in range(len(g_summary_dict_intermittents[\"TestName\"])):\n                testName = g_summary_dict_intermittents[\"TestName\"][ind]\n                numberFailure = g_summary_dict_intermittents[\"TestInfo\"][ind][\"FailureCount\"]\n                firstFailedTS  = parser.parse(time.ctime(min(g_summary_dict_intermittents[\"TestInfo\"][ind][\"Timestamp\"]))+\n                                              ' '+localtz)\n                firstFailedStr = firstFailedTS.strftime(\"%a %b %d %H:%M:%S %Y %Z\")\n                recentFail = parser.parse(time.ctime(max(g_summary_dict_intermittents[\"TestInfo\"][ind][\"Timestamp\"]))+\n                                          ' '+localtz)\n                recentFailStr = recentFail.strftime(\"%a %b %d %H:%M:%S %Y %Z\")\n                eachTest = \"{0}, {1}, {2}, {3}\\n\".format(testName, recentFailStr, numberFailure,\n                                                       g_summary_dict_intermittents[\"TestInfo\"][ind][\"TestCategory\"][0])\n                summaryFile.write(eachTest)\n                print(\"Intermittent: {0}, Last failed: {1}, Failed {2} times since \"\n                      \"{3}\".format(testName, recentFailStr, numberFailure, firstFailedStr))", "language": "python", "code": "def extractPrintSaveIntermittens():\n    \"\"\"\n    This function will print out the intermittents onto the screen for casual viewing.  It will also print out\n    where the giant summary dictionary is going to be stored.\n\n    :return: None\n    \"\"\"\n    # extract intermittents from collected failed tests\n    global g_summary_dict_intermittents\n\n    localtz = time.tzname[0]\n\n\n    for ind in range(len(g_summary_dict_all[\"TestName\"])):\n        if g_summary_dict_all[\"TestInfo\"][ind][\"FailureCount\"] >= g_threshold_failure:\n            addFailedTests(g_summary_dict_intermittents, g_summary_dict_all, ind)\n\n    # save dict in file\n    if len(g_summary_dict_intermittents[\"TestName\"]) > 0:\n        json.dump(g_summary_dict_intermittents, open(g_summary_dict_name, 'w'))\n\n        with open(g_summary_csv_filename, 'w') as summaryFile:\n            for ind in range(len(g_summary_dict_intermittents[\"TestName\"])):\n                testName = g_summary_dict_intermittents[\"TestName\"][ind]\n                numberFailure = g_summary_dict_intermittents[\"TestInfo\"][ind][\"FailureCount\"]\n                firstFailedTS  = parser.parse(time.ctime(min(g_summary_dict_intermittents[\"TestInfo\"][ind][\"Timestamp\"]))+\n                                              ' '+localtz)\n                firstFailedStr = firstFailedTS.strftime(\"%a %b %d %H:%M:%S %Y %Z\")\n                recentFail = parser.parse(time.ctime(max(g_summary_dict_intermittents[\"TestInfo\"][ind][\"Timestamp\"]))+\n                                          ' '+localtz)\n                recentFailStr = recentFail.strftime(\"%a %b %d %H:%M:%S %Y %Z\")\n                eachTest = \"{0}, {1}, {2}, {3}\\n\".format(testName, recentFailStr, numberFailure,\n                                                       g_summary_dict_intermittents[\"TestInfo\"][ind][\"TestCategory\"][0])\n                summaryFile.write(eachTest)\n                print(\"Intermittent: {0}, Last failed: {1}, Failed {2} times since \"\n                      \"{3}\".format(testName, recentFailStr, numberFailure, firstFailedStr))", "code_tokens": ["def", "extractPrintSaveIntermittens", "(", ")", ":", "# extract intermittents from collected failed tests", "global", "g_summary_dict_intermittents", "localtz", "=", "time", ".", "tzname", "[", "0", "]", "for", "ind", "in", "range", "(", "len", "(", "g_summary_dict_all", "[", "\"TestName\"", "]", ")", ")", ":", "if", "g_summary_dict_all", "[", "\"TestInfo\"", "]", "[", "ind", "]", "[", "\"FailureCount\"", "]", ">=", "g_threshold_failure", ":", "addFailedTests", "(", "g_summary_dict_intermittents", ",", "g_summary_dict_all", ",", "ind", ")", "# save dict in file", "if", "len", "(", "g_summary_dict_intermittents", "[", "\"TestName\"", "]", ")", ">", "0", ":", "json", ".", "dump", "(", "g_summary_dict_intermittents", ",", "open", "(", "g_summary_dict_name", ",", "'w'", ")", ")", "with", "open", "(", "g_summary_csv_filename", ",", "'w'", ")", "as", "summaryFile", ":", "for", "ind", "in", "range", "(", "len", "(", "g_summary_dict_intermittents", "[", "\"TestName\"", "]", ")", ")", ":", "testName", "=", "g_summary_dict_intermittents", "[", "\"TestName\"", "]", "[", "ind", "]", "numberFailure", "=", "g_summary_dict_intermittents", "[", "\"TestInfo\"", "]", "[", "ind", "]", "[", "\"FailureCount\"", "]", "firstFailedTS", "=", "parser", ".", "parse", "(", "time", ".", "ctime", "(", "min", "(", "g_summary_dict_intermittents", "[", "\"TestInfo\"", "]", "[", "ind", "]", "[", "\"Timestamp\"", "]", ")", ")", "+", "' '", "+", "localtz", ")", "firstFailedStr", "=", "firstFailedTS", ".", "strftime", "(", "\"%a %b %d %H:%M:%S %Y %Z\"", ")", "recentFail", "=", "parser", ".", "parse", "(", "time", ".", "ctime", "(", "max", "(", "g_summary_dict_intermittents", "[", "\"TestInfo\"", "]", "[", "ind", "]", "[", "\"Timestamp\"", "]", ")", ")", "+", "' '", "+", "localtz", ")", "recentFailStr", "=", "recentFail", ".", "strftime", "(", "\"%a %b %d %H:%M:%S %Y %Z\"", ")", "eachTest", "=", "\"{0}, {1}, {2}, {3}\\n\"", ".", "format", "(", "testName", ",", "recentFailStr", ",", "numberFailure", ",", "g_summary_dict_intermittents", "[", "\"TestInfo\"", "]", "[", "ind", "]", "[", "\"TestCategory\"", "]", "[", "0", "]", ")", "summaryFile", ".", "write", "(", "eachTest", ")", "print", "(", "\"Intermittent: {0}, Last failed: {1}, Failed {2} times since \"", "\"{3}\"", ".", "format", "(", "testName", ",", "recentFailStr", ",", "numberFailure", ",", "firstFailedStr", ")", ")"], "docstring": "This function will print out the intermittents onto the screen for casual viewing.  It will also print out\n    where the giant summary dictionary is going to be stored.\n\n    :return: None", "docstring_tokens": ["This", "function", "will", "print", "out", "the", "intermittents", "onto", "the", "screen", "for", "casual", "viewing", ".", "It", "will", "also", "print", "out", "where", "the", "giant", "summary", "dictionary", "is", "going", "to", "be", "stored", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/scripts/summarizeIntermittens.py#L144-L179", "partition": "test", "index": 1578, "time": "2017-03-29 09:53:43"}
{"repo": "h2oai/h2o-3", "path": "scripts/summarizeIntermittens.py", "func_name": "summarizeFailedRuns", "original_string": "def summarizeFailedRuns():\n    \"\"\"\n    This function will look at the local directory and pick out files that have the correct start name and\n    summarize the results into one giant dict.\n\n    :return: None\n    \"\"\"\n    global g_summary_dict_all\n\n    onlyFiles = [x for x in listdir(g_test_root_dir) if isfile(join(g_test_root_dir, x))]   # grab files\n\n    for f in onlyFiles:\n        for fileStart in g_file_start:\n            if (fileStart in f) and (os.path.getsize(f) > 10):  # found the file containing failed tests\n                fFullPath = os.path.join(g_test_root_dir, f)\n                try:\n                    temp_dict = json.load(open(fFullPath,'r'))\n\n                    # scrape through temp_dict and see if we need to add the test to intermittents\n                    for ind in range(len(temp_dict[\"TestName\"])):\n                        addFailedTests(g_summary_dict_all, temp_dict, ind)\n                except:\n                    continue\n                break", "language": "python", "code": "def summarizeFailedRuns():\n    \"\"\"\n    This function will look at the local directory and pick out files that have the correct start name and\n    summarize the results into one giant dict.\n\n    :return: None\n    \"\"\"\n    global g_summary_dict_all\n\n    onlyFiles = [x for x in listdir(g_test_root_dir) if isfile(join(g_test_root_dir, x))]   # grab files\n\n    for f in onlyFiles:\n        for fileStart in g_file_start:\n            if (fileStart in f) and (os.path.getsize(f) > 10):  # found the file containing failed tests\n                fFullPath = os.path.join(g_test_root_dir, f)\n                try:\n                    temp_dict = json.load(open(fFullPath,'r'))\n\n                    # scrape through temp_dict and see if we need to add the test to intermittents\n                    for ind in range(len(temp_dict[\"TestName\"])):\n                        addFailedTests(g_summary_dict_all, temp_dict, ind)\n                except:\n                    continue\n                break", "code_tokens": ["def", "summarizeFailedRuns", "(", ")", ":", "global", "g_summary_dict_all", "onlyFiles", "=", "[", "x", "for", "x", "in", "listdir", "(", "g_test_root_dir", ")", "if", "isfile", "(", "join", "(", "g_test_root_dir", ",", "x", ")", ")", "]", "# grab files", "for", "f", "in", "onlyFiles", ":", "for", "fileStart", "in", "g_file_start", ":", "if", "(", "fileStart", "in", "f", ")", "and", "(", "os", ".", "path", ".", "getsize", "(", "f", ")", ">", "10", ")", ":", "# found the file containing failed tests", "fFullPath", "=", "os", ".", "path", ".", "join", "(", "g_test_root_dir", ",", "f", ")", "try", ":", "temp_dict", "=", "json", ".", "load", "(", "open", "(", "fFullPath", ",", "'r'", ")", ")", "# scrape through temp_dict and see if we need to add the test to intermittents", "for", "ind", "in", "range", "(", "len", "(", "temp_dict", "[", "\"TestName\"", "]", ")", ")", ":", "addFailedTests", "(", "g_summary_dict_all", ",", "temp_dict", ",", "ind", ")", "except", ":", "continue", "break"], "docstring": "This function will look at the local directory and pick out files that have the correct start name and\n    summarize the results into one giant dict.\n\n    :return: None", "docstring_tokens": ["This", "function", "will", "look", "at", "the", "local", "directory", "and", "pick", "out", "files", "that", "have", "the", "correct", "start", "name", "and", "summarize", "the", "results", "into", "one", "giant", "dict", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/scripts/summarizeIntermittens.py#L69-L92", "partition": "test", "index": 1577, "time": "2017-03-29 09:53:43"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/frame.py", "func_name": "H2OFrame.grep", "original_string": "def grep(self,pattern, ignore_case = False, invert = False, output_logical = False):\n        \"\"\"\n        Searches for matches to argument `pattern` within each element\n        of a string column.\n\n        Default behavior is to return indices of the elements matching the pattern. Parameter\n        `output_logical` can be used to return a logical vector indicating if the element matches\n        the pattern (1) or not (0).\n\n        :param str pattern: A character string containing a regular expression.\n        :param bool ignore_case: If True, then case is ignored during matching.\n        :param bool invert:  If True, then identify elements that do not match the pattern.\n        :param bool output_logical: If True, then return logical vector of indicators instead of list of matching positions\n        :return: H2OFrame holding the matching positions or a logical list if `output_logical` is enabled.\n        \"\"\"\n        return H2OFrame._expr(expr=ExprNode(\"grep\", self, pattern, ignore_case, invert, output_logical))", "language": "python", "code": "def grep(self,pattern, ignore_case = False, invert = False, output_logical = False):\n        \"\"\"\n        Searches for matches to argument `pattern` within each element\n        of a string column.\n\n        Default behavior is to return indices of the elements matching the pattern. Parameter\n        `output_logical` can be used to return a logical vector indicating if the element matches\n        the pattern (1) or not (0).\n\n        :param str pattern: A character string containing a regular expression.\n        :param bool ignore_case: If True, then case is ignored during matching.\n        :param bool invert:  If True, then identify elements that do not match the pattern.\n        :param bool output_logical: If True, then return logical vector of indicators instead of list of matching positions\n        :return: H2OFrame holding the matching positions or a logical list if `output_logical` is enabled.\n        \"\"\"\n        return H2OFrame._expr(expr=ExprNode(\"grep\", self, pattern, ignore_case, invert, output_logical))", "code_tokens": ["def", "grep", "(", "self", ",", "pattern", ",", "ignore_case", "=", "False", ",", "invert", "=", "False", ",", "output_logical", "=", "False", ")", ":", "return", "H2OFrame", ".", "_expr", "(", "expr", "=", "ExprNode", "(", "\"grep\"", ",", "self", ",", "pattern", ",", "ignore_case", ",", "invert", ",", "output_logical", ")", ")"], "docstring": "Searches for matches to argument `pattern` within each element of a string column.", "docstring_tokens": ["Searches", "for", "matches", "to", "argument", "pattern", "within", "each", "element", "of", "a", "string", "column", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/frame.py#L2932-L2947", "partition": "test", "index": 1435, "time": "2017-04-06 10:31:10"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/model/dim_reduction.py", "func_name": "H2ODimReductionModel.varimp", "original_string": "def varimp(self, use_pandas=False):\n        \"\"\"\n        Return the Importance of components associcated with a pca model.\n\n        use_pandas: ``bool``  (default: ``False``).\n        \"\"\"\n        model = self._model_json[\"output\"]\n        if \"importance\" in list(model.keys()) and model[\"importance\"]:\n            vals = model[\"importance\"].cell_values\n            header = model[\"importance\"].col_header\n            if use_pandas and can_use_pandas():\n                import pandas\n                return pandas.DataFrame(vals, columns=header)\n            else:\n                return vals\n        else:\n            print(\"Warning: This model doesn't have importances of components.\")", "language": "python", "code": "def varimp(self, use_pandas=False):\n        \"\"\"\n        Return the Importance of components associcated with a pca model.\n\n        use_pandas: ``bool``  (default: ``False``).\n        \"\"\"\n        model = self._model_json[\"output\"]\n        if \"importance\" in list(model.keys()) and model[\"importance\"]:\n            vals = model[\"importance\"].cell_values\n            header = model[\"importance\"].col_header\n            if use_pandas and can_use_pandas():\n                import pandas\n                return pandas.DataFrame(vals, columns=header)\n            else:\n                return vals\n        else:\n            print(\"Warning: This model doesn't have importances of components.\")", "code_tokens": ["def", "varimp", "(", "self", ",", "use_pandas", "=", "False", ")", ":", "model", "=", "self", ".", "_model_json", "[", "\"output\"", "]", "if", "\"importance\"", "in", "list", "(", "model", ".", "keys", "(", ")", ")", "and", "model", "[", "\"importance\"", "]", ":", "vals", "=", "model", "[", "\"importance\"", "]", ".", "cell_values", "header", "=", "model", "[", "\"importance\"", "]", ".", "col_header", "if", "use_pandas", "and", "can_use_pandas", "(", ")", ":", "import", "pandas", "return", "pandas", ".", "DataFrame", "(", "vals", ",", "columns", "=", "header", ")", "else", ":", "return", "vals", "else", ":", "print", "(", "\"Warning: This model doesn't have importances of components.\"", ")"], "docstring": "Return the Importance of components associcated with a pca model.\n\n        use_pandas: ``bool``  (default: ``False``).", "docstring_tokens": ["Return", "the", "Importance", "of", "components", "associcated", "with", "a", "pca", "model", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/model/dim_reduction.py#L17-L33", "partition": "test", "index": 1491, "time": "2017-05-09 10:08:52"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/frame.py", "func_name": "H2OFrame.fillna", "original_string": "def fillna(self,method=\"forward\",axis=0,maxlen=1):\n        \"\"\"\n        Return a new Frame that fills NA along a given axis and along a given direction with a maximum fill length\n\n        :param method: ``\"forward\"`` or ``\"backward\"``\n        :param axis:  0 for columnar-wise or 1 for row-wise fill\n        :param maxlen: Max number of consecutive NA's to fill\n        \n        :return: \n        \"\"\"\n        assert_is_type(axis, 0, 1)\n        assert_is_type(method,str)\n        assert_is_type(maxlen, int)\n        return H2OFrame._expr(expr=ExprNode(\"h2o.fillna\",self,method,axis,maxlen))", "language": "python", "code": "def fillna(self,method=\"forward\",axis=0,maxlen=1):\n        \"\"\"\n        Return a new Frame that fills NA along a given axis and along a given direction with a maximum fill length\n\n        :param method: ``\"forward\"`` or ``\"backward\"``\n        :param axis:  0 for columnar-wise or 1 for row-wise fill\n        :param maxlen: Max number of consecutive NA's to fill\n        \n        :return: \n        \"\"\"\n        assert_is_type(axis, 0, 1)\n        assert_is_type(method,str)\n        assert_is_type(maxlen, int)\n        return H2OFrame._expr(expr=ExprNode(\"h2o.fillna\",self,method,axis,maxlen))", "code_tokens": ["def", "fillna", "(", "self", ",", "method", "=", "\"forward\"", ",", "axis", "=", "0", ",", "maxlen", "=", "1", ")", ":", "assert_is_type", "(", "axis", ",", "0", ",", "1", ")", "assert_is_type", "(", "method", ",", "str", ")", "assert_is_type", "(", "maxlen", ",", "int", ")", "return", "H2OFrame", ".", "_expr", "(", "expr", "=", "ExprNode", "(", "\"h2o.fillna\"", ",", "self", ",", "method", ",", "axis", ",", "maxlen", ")", ")"], "docstring": "Return a new Frame that fills NA along a given axis and along a given direction with a maximum fill length", "docstring_tokens": ["Return", "a", "new", "Frame", "that", "fills", "NA", "along", "a", "given", "axis", "and", "along", "a", "given", "direction", "with", "a", "maximum", "fill", "length"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/frame.py#L1868-L1881", "partition": "test", "index": 1415, "time": "2017-06-03 23:45:31"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/h2o.py", "func_name": "upload_custom_metric", "original_string": "def upload_custom_metric(func, func_file=\"metrics.py\", func_name=None, class_name=None, source_provider=None):\n    \"\"\"\n    Upload given metrics function into H2O cluster.\n\n    The metrics can have different representation:\n      - class: needs to implement map(pred, act, weight, offset, model), reduce(l, r) and metric(l) methods\n      - string: the same as in class case, but the class is given as a string\n\n    :param func:  metric representation: string, class\n    :param func_file:  internal name of file to save given metrics representation\n    :param func_name:  name for h2o key under which the given metric is saved\n    :param class_name: name of class wrapping the metrics function (when supplied as string)\n    :param source_provider: a function which provides a source code for given function\n    :return: reference to uploaded metrics function\n\n    :examples:\n        >>> class CustomMaeFunc:\n        >>>     def map(self, pred, act, w, o, model):\n        >>>         return [abs(act[0] - pred[0]), 1]\n        >>>\n        >>>     def reduce(self, l, r):\n        >>>         return [l[0] + r[0], l[1] + r[1]]\n        >>>\n        >>>     def metric(self, l):\n        >>>         return l[0] / l[1]\n        >>>\n        >>>\n        >>> h2o.upload_custom_metric(CustomMaeFunc, func_name=\"mae\")\n        >>>\n        >>> custom_func_str = '''class CustomMaeFunc:\n        >>>     def map(self, pred, act, w, o, model):\n        >>>         return [abs(act[0] - pred[0]), 1]\n        >>>\n        >>>     def reduce(self, l, r):\n        >>>         return [l[0] + r[0], l[1] + r[1]]\n        >>>\n        >>>     def metric(self, l):\n        >>>         return l[0] / l[1]'''\n        >>>\n        >>>\n        >>> h2o.upload_custom_metric(custom_func_str, class_name=\"CustomMaeFunc\", func_name=\"mae\")\n    \"\"\"\n    import tempfile\n    import inspect\n\n    # Use default source provider\n    if not source_provider:\n        source_provider = _default_source_provider\n\n    # The template wraps given metrics representation\n    _CFUNC_CODE_TEMPLATE = \"\"\"# Generated code\nimport water.udf.CMetricFunc as MetricFunc\n\n# User given metric function as a class implementing\n# 3 methods defined by interface CMetricFunc\n{}\n\n# Generated user metric which satisfies the interface\n# of Java MetricFunc\nclass {}Wrapper({}, MetricFunc, object):\n    pass\n\n\"\"\"\n\n    assert_satisfies(func, inspect.isclass(func) or isinstance(func, str),\n                     \"The argument func needs to be string or class !\")\n    assert_satisfies(func_file, func_file is not None,\n                     \"The argument func_file is missing!\")\n    assert_satisfies(func_file, func_file.endswith('.py'),\n                     \"The argument func_file needs to end with '.py'\")\n    code = None\n    derived_func_name = None\n    module_name = func_file[:-3]\n    if isinstance(func, str):\n        assert_satisfies(class_name, class_name is not None,\n                         \"The argument class_name is missing! \" +\n                         \"It needs to reference the class in given string!\")\n        code = _CFUNC_CODE_TEMPLATE.format(func, class_name, class_name)\n        derived_func_name = \"metrics_{}\".format(class_name)\n        class_name = \"{}.{}Wrapper\".format(module_name, class_name)\n    else:\n        assert_satisfies(func, inspect.isclass(func), \"The parameter `func` should be str or class\")\n        for method in ['map', 'reduce', 'metric']:\n            assert_satisfies(func, method in func.__dict__, \"The class `func` needs to define method `{}`\".format(method))\n\n        assert_satisfies(class_name, class_name is None,\n                         \"If class is specified then class_name parameter needs to be None\")\n\n        class_name = \"{}.{}Wrapper\".format(module_name, func.__name__)\n        derived_func_name = \"metrics_{}\".format(func.__name__)\n        code = _CFUNC_CODE_TEMPLATE.format(source_provider(func), func.__name__, func.__name__)\n\n    # If the func name is not given, use whatever we can derived from given definition\n    if not func_name:\n        func_name = derived_func_name\n    # Saved into jar file\n    tmpdir = tempfile.mkdtemp(prefix=\"h2o-func\")\n    func_arch_file = _create_zip_file(\"{}/func.jar\".format(tmpdir), (func_file, code))\n    # Upload into K/V\n    dest_key = _put_key(func_arch_file, dest_key=func_name)\n    # Reference\n    return \"python:{}={}\".format(dest_key, class_name)", "language": "python", "code": "def upload_custom_metric(func, func_file=\"metrics.py\", func_name=None, class_name=None, source_provider=None):\n    \"\"\"\n    Upload given metrics function into H2O cluster.\n\n    The metrics can have different representation:\n      - class: needs to implement map(pred, act, weight, offset, model), reduce(l, r) and metric(l) methods\n      - string: the same as in class case, but the class is given as a string\n\n    :param func:  metric representation: string, class\n    :param func_file:  internal name of file to save given metrics representation\n    :param func_name:  name for h2o key under which the given metric is saved\n    :param class_name: name of class wrapping the metrics function (when supplied as string)\n    :param source_provider: a function which provides a source code for given function\n    :return: reference to uploaded metrics function\n\n    :examples:\n        >>> class CustomMaeFunc:\n        >>>     def map(self, pred, act, w, o, model):\n        >>>         return [abs(act[0] - pred[0]), 1]\n        >>>\n        >>>     def reduce(self, l, r):\n        >>>         return [l[0] + r[0], l[1] + r[1]]\n        >>>\n        >>>     def metric(self, l):\n        >>>         return l[0] / l[1]\n        >>>\n        >>>\n        >>> h2o.upload_custom_metric(CustomMaeFunc, func_name=\"mae\")\n        >>>\n        >>> custom_func_str = '''class CustomMaeFunc:\n        >>>     def map(self, pred, act, w, o, model):\n        >>>         return [abs(act[0] - pred[0]), 1]\n        >>>\n        >>>     def reduce(self, l, r):\n        >>>         return [l[0] + r[0], l[1] + r[1]]\n        >>>\n        >>>     def metric(self, l):\n        >>>         return l[0] / l[1]'''\n        >>>\n        >>>\n        >>> h2o.upload_custom_metric(custom_func_str, class_name=\"CustomMaeFunc\", func_name=\"mae\")\n    \"\"\"\n    import tempfile\n    import inspect\n\n    # Use default source provider\n    if not source_provider:\n        source_provider = _default_source_provider\n\n    # The template wraps given metrics representation\n    _CFUNC_CODE_TEMPLATE = \"\"\"# Generated code\nimport water.udf.CMetricFunc as MetricFunc\n\n# User given metric function as a class implementing\n# 3 methods defined by interface CMetricFunc\n{}\n\n# Generated user metric which satisfies the interface\n# of Java MetricFunc\nclass {}Wrapper({}, MetricFunc, object):\n    pass\n\n\"\"\"\n\n    assert_satisfies(func, inspect.isclass(func) or isinstance(func, str),\n                     \"The argument func needs to be string or class !\")\n    assert_satisfies(func_file, func_file is not None,\n                     \"The argument func_file is missing!\")\n    assert_satisfies(func_file, func_file.endswith('.py'),\n                     \"The argument func_file needs to end with '.py'\")\n    code = None\n    derived_func_name = None\n    module_name = func_file[:-3]\n    if isinstance(func, str):\n        assert_satisfies(class_name, class_name is not None,\n                         \"The argument class_name is missing! \" +\n                         \"It needs to reference the class in given string!\")\n        code = _CFUNC_CODE_TEMPLATE.format(func, class_name, class_name)\n        derived_func_name = \"metrics_{}\".format(class_name)\n        class_name = \"{}.{}Wrapper\".format(module_name, class_name)\n    else:\n        assert_satisfies(func, inspect.isclass(func), \"The parameter `func` should be str or class\")\n        for method in ['map', 'reduce', 'metric']:\n            assert_satisfies(func, method in func.__dict__, \"The class `func` needs to define method `{}`\".format(method))\n\n        assert_satisfies(class_name, class_name is None,\n                         \"If class is specified then class_name parameter needs to be None\")\n\n        class_name = \"{}.{}Wrapper\".format(module_name, func.__name__)\n        derived_func_name = \"metrics_{}\".format(func.__name__)\n        code = _CFUNC_CODE_TEMPLATE.format(source_provider(func), func.__name__, func.__name__)\n\n    # If the func name is not given, use whatever we can derived from given definition\n    if not func_name:\n        func_name = derived_func_name\n    # Saved into jar file\n    tmpdir = tempfile.mkdtemp(prefix=\"h2o-func\")\n    func_arch_file = _create_zip_file(\"{}/func.jar\".format(tmpdir), (func_file, code))\n    # Upload into K/V\n    dest_key = _put_key(func_arch_file, dest_key=func_name)\n    # Reference\n    return \"python:{}={}\".format(dest_key, class_name)", "code_tokens": ["def", "upload_custom_metric", "(", "func", ",", "func_file", "=", "\"metrics.py\"", ",", "func_name", "=", "None", ",", "class_name", "=", "None", ",", "source_provider", "=", "None", ")", ":", "import", "tempfile", "import", "inspect", "# Use default source provider", "if", "not", "source_provider", ":", "source_provider", "=", "_default_source_provider", "# The template wraps given metrics representation", "_CFUNC_CODE_TEMPLATE", "=", "\"\"\"# Generated code\nimport water.udf.CMetricFunc as MetricFunc\n\n# User given metric function as a class implementing\n# 3 methods defined by interface CMetricFunc\n{}\n\n# Generated user metric which satisfies the interface\n# of Java MetricFunc\nclass {}Wrapper({}, MetricFunc, object):\n    pass\n\n\"\"\"", "assert_satisfies", "(", "func", ",", "inspect", ".", "isclass", "(", "func", ")", "or", "isinstance", "(", "func", ",", "str", ")", ",", "\"The argument func needs to be string or class !\"", ")", "assert_satisfies", "(", "func_file", ",", "func_file", "is", "not", "None", ",", "\"The argument func_file is missing!\"", ")", "assert_satisfies", "(", "func_file", ",", "func_file", ".", "endswith", "(", "'.py'", ")", ",", "\"The argument func_file needs to end with '.py'\"", ")", "code", "=", "None", "derived_func_name", "=", "None", "module_name", "=", "func_file", "[", ":", "-", "3", "]", "if", "isinstance", "(", "func", ",", "str", ")", ":", "assert_satisfies", "(", "class_name", ",", "class_name", "is", "not", "None", ",", "\"The argument class_name is missing! \"", "+", "\"It needs to reference the class in given string!\"", ")", "code", "=", "_CFUNC_CODE_TEMPLATE", ".", "format", "(", "func", ",", "class_name", ",", "class_name", ")", "derived_func_name", "=", "\"metrics_{}\"", ".", "format", "(", "class_name", ")", "class_name", "=", "\"{}.{}Wrapper\"", ".", "format", "(", "module_name", ",", "class_name", ")", "else", ":", "assert_satisfies", "(", "func", ",", "inspect", ".", "isclass", "(", "func", ")", ",", "\"The parameter `func` should be str or class\"", ")", "for", "method", "in", "[", "'map'", ",", "'reduce'", ",", "'metric'", "]", ":", "assert_satisfies", "(", "func", ",", "method", "in", "func", ".", "__dict__", ",", "\"The class `func` needs to define method `{}`\"", ".", "format", "(", "method", ")", ")", "assert_satisfies", "(", "class_name", ",", "class_name", "is", "None", ",", "\"If class is specified then class_name parameter needs to be None\"", ")", "class_name", "=", "\"{}.{}Wrapper\"", ".", "format", "(", "module_name", ",", "func", ".", "__name__", ")", "derived_func_name", "=", "\"metrics_{}\"", ".", "format", "(", "func", ".", "__name__", ")", "code", "=", "_CFUNC_CODE_TEMPLATE", ".", "format", "(", "source_provider", "(", "func", ")", ",", "func", ".", "__name__", ",", "func", ".", "__name__", ")", "# If the func name is not given, use whatever we can derived from given definition", "if", "not", "func_name", ":", "func_name", "=", "derived_func_name", "# Saved into jar file", "tmpdir", "=", "tempfile", ".", "mkdtemp", "(", "prefix", "=", "\"h2o-func\"", ")", "func_arch_file", "=", "_create_zip_file", "(", "\"{}/func.jar\"", ".", "format", "(", "tmpdir", ")", ",", "(", "func_file", ",", "code", ")", ")", "# Upload into K/V", "dest_key", "=", "_put_key", "(", "func_arch_file", ",", "dest_key", "=", "func_name", ")", "# Reference", "return", "\"python:{}={}\"", ".", "format", "(", "dest_key", ",", "class_name", ")"], "docstring": "Upload given metrics function into H2O cluster.", "docstring_tokens": ["Upload", "given", "metrics", "function", "into", "H2O", "cluster", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/h2o.py#L1430-L1531", "partition": "test", "index": 1475, "time": "2017-11-22 17:20:18"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/h2o.py", "func_name": "_put_key", "original_string": "def _put_key(file_path, dest_key=None, overwrite=True):\n    \"\"\"\n    Upload given file into DKV and save it under give key as raw object.\n\n    :param dest_key:  name of destination key in DKV\n    :param file_path:  path to file to upload\n    :return: key name if object was uploaded successfully\n    \"\"\"\n    ret = api(\"POST /3/PutKey?destination_key={}&overwrite={}\".format(dest_key if dest_key else '', overwrite),\n              filename=file_path)\n    return ret[\"destination_key\"]", "language": "python", "code": "def _put_key(file_path, dest_key=None, overwrite=True):\n    \"\"\"\n    Upload given file into DKV and save it under give key as raw object.\n\n    :param dest_key:  name of destination key in DKV\n    :param file_path:  path to file to upload\n    :return: key name if object was uploaded successfully\n    \"\"\"\n    ret = api(\"POST /3/PutKey?destination_key={}&overwrite={}\".format(dest_key if dest_key else '', overwrite),\n              filename=file_path)\n    return ret[\"destination_key\"]", "code_tokens": ["def", "_put_key", "(", "file_path", ",", "dest_key", "=", "None", ",", "overwrite", "=", "True", ")", ":", "ret", "=", "api", "(", "\"POST /3/PutKey?destination_key={}&overwrite={}\"", ".", "format", "(", "dest_key", "if", "dest_key", "else", "''", ",", "overwrite", ")", ",", "filename", "=", "file_path", ")", "return", "ret", "[", "\"destination_key\"", "]"], "docstring": "Upload given file into DKV and save it under give key as raw object.", "docstring_tokens": ["Upload", "given", "file", "into", "DKV", "and", "save", "it", "under", "give", "key", "as", "raw", "object", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/h2o.py#L1388-L1398", "partition": "test", "index": 1474, "time": "2017-11-22 17:20:18"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/estimators/word2vec.py", "func_name": "H2OWord2vecEstimator._determine_vec_size", "original_string": "def _determine_vec_size(self):\n        \"\"\"\n        Determines vec_size for a pre-trained model after basic model verification.\n        \"\"\"\n        first_column = self.pre_trained.types[self.pre_trained.columns[0]]\n\n        if first_column != 'string':\n            raise H2OValueError(\"First column of given pre_trained model %s is required to be a String\",\n                                self.pre_trained.frame_id)\n\n        if list(self.pre_trained.types.values()).count('string') > 1:\n            raise H2OValueError(\"There are multiple columns in given pre_trained model %s with a String type.\",\n                                self.pre_trained.frame_id)\n\n        self.vec_size = self.pre_trained.dim[1] - 1;", "language": "python", "code": "def _determine_vec_size(self):\n        \"\"\"\n        Determines vec_size for a pre-trained model after basic model verification.\n        \"\"\"\n        first_column = self.pre_trained.types[self.pre_trained.columns[0]]\n\n        if first_column != 'string':\n            raise H2OValueError(\"First column of given pre_trained model %s is required to be a String\",\n                                self.pre_trained.frame_id)\n\n        if list(self.pre_trained.types.values()).count('string') > 1:\n            raise H2OValueError(\"There are multiple columns in given pre_trained model %s with a String type.\",\n                                self.pre_trained.frame_id)\n\n        self.vec_size = self.pre_trained.dim[1] - 1;", "code_tokens": ["def", "_determine_vec_size", "(", "self", ")", ":", "first_column", "=", "self", ".", "pre_trained", ".", "types", "[", "self", ".", "pre_trained", ".", "columns", "[", "0", "]", "]", "if", "first_column", "!=", "'string'", ":", "raise", "H2OValueError", "(", "\"First column of given pre_trained model %s is required to be a String\"", ",", "self", ".", "pre_trained", ".", "frame_id", ")", "if", "list", "(", "self", ".", "pre_trained", ".", "types", ".", "values", "(", ")", ")", ".", "count", "(", "'string'", ")", ">", "1", ":", "raise", "H2OValueError", "(", "\"There are multiple columns in given pre_trained model %s with a String type.\"", ",", "self", ".", "pre_trained", ".", "frame_id", ")", "self", ".", "vec_size", "=", "self", ".", "pre_trained", ".", "dim", "[", "1", "]", "-", "1"], "docstring": "Determines vec_size for a pre-trained model after basic model verification.", "docstring_tokens": ["Determines", "vec_size", "for", "a", "pre", "-", "trained", "model", "after", "basic", "model", "verification", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/estimators/word2vec.py#L244-L258", "partition": "test", "index": 1359, "time": "2018-01-13 15:56:42"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/estimators/stackedensemble.py", "func_name": "H2OStackedEnsembleEstimator.metalearner_params", "original_string": "def metalearner_params(self):\n        \"\"\"\n        Parameters for metalearner algorithm\n\n        Type: ``dict``  (default: ``None``).\n        Example: metalearner_gbm_params = {'max_depth': 2, 'col_sample_rate': 0.3}\n        \"\"\"\n        if self._parms.get(\"metalearner_params\") != None:\n            metalearner_params_dict =  ast.literal_eval(self._parms.get(\"metalearner_params\"))\n            for k in metalearner_params_dict:\n                if len(metalearner_params_dict[k]) == 1: #single parameter\n                    metalearner_params_dict[k] = metalearner_params_dict[k][0]\n            return metalearner_params_dict\n        else:\n            return self._parms.get(\"metalearner_params\")", "language": "python", "code": "def metalearner_params(self):\n        \"\"\"\n        Parameters for metalearner algorithm\n\n        Type: ``dict``  (default: ``None``).\n        Example: metalearner_gbm_params = {'max_depth': 2, 'col_sample_rate': 0.3}\n        \"\"\"\n        if self._parms.get(\"metalearner_params\") != None:\n            metalearner_params_dict =  ast.literal_eval(self._parms.get(\"metalearner_params\"))\n            for k in metalearner_params_dict:\n                if len(metalearner_params_dict[k]) == 1: #single parameter\n                    metalearner_params_dict[k] = metalearner_params_dict[k][0]\n            return metalearner_params_dict\n        else:\n            return self._parms.get(\"metalearner_params\")", "code_tokens": ["def", "metalearner_params", "(", "self", ")", ":", "if", "self", ".", "_parms", ".", "get", "(", "\"metalearner_params\"", ")", "!=", "None", ":", "metalearner_params_dict", "=", "ast", ".", "literal_eval", "(", "self", ".", "_parms", ".", "get", "(", "\"metalearner_params\"", ")", ")", "for", "k", "in", "metalearner_params_dict", ":", "if", "len", "(", "metalearner_params_dict", "[", "k", "]", ")", "==", "1", ":", "#single parameter", "metalearner_params_dict", "[", "k", "]", "=", "metalearner_params_dict", "[", "k", "]", "[", "0", "]", "return", "metalearner_params_dict", "else", ":", "return", "self", ".", "_parms", ".", "get", "(", "\"metalearner_params\"", ")"], "docstring": "Parameters for metalearner algorithm\n\n        Type: ``dict``  (default: ``None``).\n        Example: metalearner_gbm_params = {'max_depth': 2, 'col_sample_rate': 0.3}", "docstring_tokens": ["Parameters", "for", "metalearner", "algorithm"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/estimators/stackedensemble.py#L216-L230", "partition": "test", "index": 1325, "time": "2018-02-01 16:33:18"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/frame.py", "func_name": "H2OFrame.rename", "original_string": "def rename(self, columns=None):\n        \"\"\"\n        Change names of columns in the frame.\n\n        Dict key is an index or name of the column whose name is to be set.\n        Dict value is the new name of the column.\n\n        :param columns: dict-like transformations to apply to the column names\n        \"\"\"\n        assert_is_type(columns, None, dict)\n        new_names = self.names\n        ncols = self.ncols\n\n        for col, name in columns.items():\n            col_index = None\n            if is_type(col, int) and (-ncols <= col < ncols):\n                col_index = (col + ncols) % ncols  # handle negative indices\n            elif is_type(col, str) and col in self.names:\n                col_index = self.names.index(col)  # lookup the name\n\n            if col_index is not None:\n                new_names[col_index] = name\n\n        return self.set_names(new_names)", "language": "python", "code": "def rename(self, columns=None):\n        \"\"\"\n        Change names of columns in the frame.\n\n        Dict key is an index or name of the column whose name is to be set.\n        Dict value is the new name of the column.\n\n        :param columns: dict-like transformations to apply to the column names\n        \"\"\"\n        assert_is_type(columns, None, dict)\n        new_names = self.names\n        ncols = self.ncols\n\n        for col, name in columns.items():\n            col_index = None\n            if is_type(col, int) and (-ncols <= col < ncols):\n                col_index = (col + ncols) % ncols  # handle negative indices\n            elif is_type(col, str) and col in self.names:\n                col_index = self.names.index(col)  # lookup the name\n\n            if col_index is not None:\n                new_names[col_index] = name\n\n        return self.set_names(new_names)", "code_tokens": ["def", "rename", "(", "self", ",", "columns", "=", "None", ")", ":", "assert_is_type", "(", "columns", ",", "None", ",", "dict", ")", "new_names", "=", "self", ".", "names", "ncols", "=", "self", ".", "ncols", "for", "col", ",", "name", "in", "columns", ".", "items", "(", ")", ":", "col_index", "=", "None", "if", "is_type", "(", "col", ",", "int", ")", "and", "(", "-", "ncols", "<=", "col", "<", "ncols", ")", ":", "col_index", "=", "(", "col", "+", "ncols", ")", "%", "ncols", "# handle negative indices", "elif", "is_type", "(", "col", ",", "str", ")", "and", "col", "in", "self", ".", "names", ":", "col_index", "=", "self", ".", "names", ".", "index", "(", "col", ")", "# lookup the name", "if", "col_index", "is", "not", "None", ":", "new_names", "[", "col_index", "]", "=", "name", "return", "self", ".", "set_names", "(", "new_names", ")"], "docstring": "Change names of columns in the frame.", "docstring_tokens": ["Change", "names", "of", "columns", "in", "the", "frame", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/frame.py#L1035-L1058", "partition": "test", "index": 1400, "time": "2018-02-23 19:01:14"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/utils/shared_utils.py", "func_name": "mojo_predict_pandas", "original_string": "def mojo_predict_pandas(dataframe, mojo_zip_path, genmodel_jar_path=None, classpath=None, java_options=None, verbose=False):\n    \"\"\"\n    MOJO scoring function to take a Pandas frame and use MOJO model as zip file to score.\n\n    :param dataframe: Pandas frame to score.\n    :param mojo_zip_path: Path to MOJO zip downloaded from H2O.\n    :param genmodel_jar_path: Optional, path to genmodel jar file. If None (default) then the h2o-genmodel.jar in the same\n        folder as the MOJO zip will be used.\n    :param classpath: Optional, specifies custom user defined classpath which will be used when scoring. If None\n        (default) then the default classpath for this MOJO model will be used.\n    :param java_options: Optional, custom user defined options for Java. By default ``-Xmx4g`` is used.\n    :param verbose: Optional, if True, then additional debug information will be printed. False by default.\n    :return: Pandas frame with predictions\n    \"\"\"\n    tmp_dir = tempfile.mkdtemp()\n    try:\n        if not can_use_pandas():\n            raise RuntimeException('Cannot import pandas')\n        import pandas\n        assert_is_type(dataframe, pandas.DataFrame)\n        input_csv_path = os.path.join(tmp_dir, 'input.csv')\n        prediction_csv_path = os.path.join(tmp_dir, 'prediction.csv')\n        dataframe.to_csv(input_csv_path)\n        mojo_predict_csv(input_csv_path=input_csv_path, mojo_zip_path=mojo_zip_path,\n                         output_csv_path=prediction_csv_path, genmodel_jar_path=genmodel_jar_path,\n                         classpath=classpath, java_options=java_options, verbose=verbose)\n        return pandas.read_csv(prediction_csv_path)\n    finally:\n        shutil.rmtree(tmp_dir)", "language": "python", "code": "def mojo_predict_pandas(dataframe, mojo_zip_path, genmodel_jar_path=None, classpath=None, java_options=None, verbose=False):\n    \"\"\"\n    MOJO scoring function to take a Pandas frame and use MOJO model as zip file to score.\n\n    :param dataframe: Pandas frame to score.\n    :param mojo_zip_path: Path to MOJO zip downloaded from H2O.\n    :param genmodel_jar_path: Optional, path to genmodel jar file. If None (default) then the h2o-genmodel.jar in the same\n        folder as the MOJO zip will be used.\n    :param classpath: Optional, specifies custom user defined classpath which will be used when scoring. If None\n        (default) then the default classpath for this MOJO model will be used.\n    :param java_options: Optional, custom user defined options for Java. By default ``-Xmx4g`` is used.\n    :param verbose: Optional, if True, then additional debug information will be printed. False by default.\n    :return: Pandas frame with predictions\n    \"\"\"\n    tmp_dir = tempfile.mkdtemp()\n    try:\n        if not can_use_pandas():\n            raise RuntimeException('Cannot import pandas')\n        import pandas\n        assert_is_type(dataframe, pandas.DataFrame)\n        input_csv_path = os.path.join(tmp_dir, 'input.csv')\n        prediction_csv_path = os.path.join(tmp_dir, 'prediction.csv')\n        dataframe.to_csv(input_csv_path)\n        mojo_predict_csv(input_csv_path=input_csv_path, mojo_zip_path=mojo_zip_path,\n                         output_csv_path=prediction_csv_path, genmodel_jar_path=genmodel_jar_path,\n                         classpath=classpath, java_options=java_options, verbose=verbose)\n        return pandas.read_csv(prediction_csv_path)\n    finally:\n        shutil.rmtree(tmp_dir)", "code_tokens": ["def", "mojo_predict_pandas", "(", "dataframe", ",", "mojo_zip_path", ",", "genmodel_jar_path", "=", "None", ",", "classpath", "=", "None", ",", "java_options", "=", "None", ",", "verbose", "=", "False", ")", ":", "tmp_dir", "=", "tempfile", ".", "mkdtemp", "(", ")", "try", ":", "if", "not", "can_use_pandas", "(", ")", ":", "raise", "RuntimeException", "(", "'Cannot import pandas'", ")", "import", "pandas", "assert_is_type", "(", "dataframe", ",", "pandas", ".", "DataFrame", ")", "input_csv_path", "=", "os", ".", "path", ".", "join", "(", "tmp_dir", ",", "'input.csv'", ")", "prediction_csv_path", "=", "os", ".", "path", ".", "join", "(", "tmp_dir", ",", "'prediction.csv'", ")", "dataframe", ".", "to_csv", "(", "input_csv_path", ")", "mojo_predict_csv", "(", "input_csv_path", "=", "input_csv_path", ",", "mojo_zip_path", "=", "mojo_zip_path", ",", "output_csv_path", "=", "prediction_csv_path", ",", "genmodel_jar_path", "=", "genmodel_jar_path", ",", "classpath", "=", "classpath", ",", "java_options", "=", "java_options", ",", "verbose", "=", "verbose", ")", "return", "pandas", ".", "read_csv", "(", "prediction_csv_path", ")", "finally", ":", "shutil", ".", "rmtree", "(", "tmp_dir", ")"], "docstring": "MOJO scoring function to take a Pandas frame and use MOJO model as zip file to score.", "docstring_tokens": ["MOJO", "scoring", "function", "to", "take", "a", "Pandas", "frame", "and", "use", "MOJO", "model", "as", "zip", "file", "to", "score", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/utils/shared_utils.py#L379-L407", "partition": "test", "index": 1480, "time": "2018-03-16 13:42:47"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/utils/shared_utils.py", "func_name": "mojo_predict_csv", "original_string": "def mojo_predict_csv(input_csv_path, mojo_zip_path, output_csv_path=None, genmodel_jar_path=None, classpath=None, java_options=None, verbose=False):\n    \"\"\"\n    MOJO scoring function to take a CSV file and use MOJO model as zip file to score.\n\n    :param input_csv_path: Path to input CSV file.\n    :param mojo_zip_path: Path to MOJO zip downloaded from H2O.\n    :param output_csv_path: Optional, name of the output CSV file with computed predictions. If None (default), then\n        predictions will be saved as prediction.csv in the same folder as the MOJO zip.\n    :param genmodel_jar_path: Optional, path to genmodel jar file. If None (default) then the h2o-genmodel.jar in the same\n        folder as the MOJO zip will be used.\n    :param classpath: Optional, specifies custom user defined classpath which will be used when scoring. If None\n        (default) then the default classpath for this MOJO model will be used.\n    :param java_options: Optional, custom user defined options for Java. By default ``-Xmx4g -XX:ReservedCodeCacheSize=256m`` is used.\n    :param verbose: Optional, if True, then additional debug information will be printed. False by default.\n    :return: List of computed predictions\n    \"\"\"\n    default_java_options = '-Xmx4g -XX:ReservedCodeCacheSize=256m'\n    prediction_output_file = 'prediction.csv'\n\n    # Checking java\n    java = H2OLocalServer._find_java()\n    H2OLocalServer._check_java(java=java, verbose=verbose)\n\n    # Ensure input_csv exists\n    if verbose:\n        print(\"input_csv:\\t%s\" % input_csv_path)\n    if not os.path.isfile(input_csv_path):\n        raise RuntimeError(\"Input csv cannot be found at %s\" % input_csv_path)\n\n    # Ensure mojo_zip exists\n    mojo_zip_path = os.path.abspath(mojo_zip_path)\n    if verbose:\n        print(\"mojo_zip:\\t%s\" % mojo_zip_path)\n    if not os.path.isfile(mojo_zip_path):\n        raise RuntimeError(\"MOJO zip cannot be found at %s\" % mojo_zip_path)\n\n    parent_dir = os.path.dirname(mojo_zip_path)\n\n    # Set output_csv if necessary\n    if output_csv_path is None:\n        output_csv_path = os.path.join(parent_dir, prediction_output_file)\n\n    # Set path to h2o-genmodel.jar if necessary and check it's valid\n    if genmodel_jar_path is None:\n        genmodel_jar_path = os.path.join(parent_dir, gen_model_file_name)\n    if verbose:\n        print(\"genmodel_jar:\\t%s\" % genmodel_jar_path)\n    if not os.path.isfile(genmodel_jar_path):\n        raise RuntimeError(\"Genmodel jar cannot be found at %s\" % genmodel_jar_path)\n\n    if verbose and output_csv_path is not None:\n        print(\"output_csv:\\t%s\" % output_csv_path)\n\n    # Set classpath if necessary\n    if classpath is None:\n        classpath = genmodel_jar_path\n    if verbose:\n        print(\"classpath:\\t%s\" % classpath)\n\n    # Set java_options if necessary\n    if java_options is None:\n        java_options = default_java_options\n    if verbose:\n        print(\"java_options:\\t%s\" % java_options)\n\n    # Construct command to invoke java\n    cmd = [java]\n    for option in java_options.split(' '):\n        cmd += [option]\n    cmd += [\"-cp\", classpath, h2o_predictor_class, \"--mojo\", mojo_zip_path, \"--input\", input_csv_path,\n            '--output', output_csv_path, '--decimal']\n    if verbose:\n        cmd_str = \" \".join(cmd)\n        print(\"java cmd:\\t%s\" % cmd_str)\n\n    # invoke the command\n    subprocess.check_call(cmd, shell=False)\n\n    # load predictions in form of a dict\n    with open(output_csv_path) as csv_file:\n        result = list(csv.DictReader(csv_file))\n    return result", "language": "python", "code": "def mojo_predict_csv(input_csv_path, mojo_zip_path, output_csv_path=None, genmodel_jar_path=None, classpath=None, java_options=None, verbose=False):\n    \"\"\"\n    MOJO scoring function to take a CSV file and use MOJO model as zip file to score.\n\n    :param input_csv_path: Path to input CSV file.\n    :param mojo_zip_path: Path to MOJO zip downloaded from H2O.\n    :param output_csv_path: Optional, name of the output CSV file with computed predictions. If None (default), then\n        predictions will be saved as prediction.csv in the same folder as the MOJO zip.\n    :param genmodel_jar_path: Optional, path to genmodel jar file. If None (default) then the h2o-genmodel.jar in the same\n        folder as the MOJO zip will be used.\n    :param classpath: Optional, specifies custom user defined classpath which will be used when scoring. If None\n        (default) then the default classpath for this MOJO model will be used.\n    :param java_options: Optional, custom user defined options for Java. By default ``-Xmx4g -XX:ReservedCodeCacheSize=256m`` is used.\n    :param verbose: Optional, if True, then additional debug information will be printed. False by default.\n    :return: List of computed predictions\n    \"\"\"\n    default_java_options = '-Xmx4g -XX:ReservedCodeCacheSize=256m'\n    prediction_output_file = 'prediction.csv'\n\n    # Checking java\n    java = H2OLocalServer._find_java()\n    H2OLocalServer._check_java(java=java, verbose=verbose)\n\n    # Ensure input_csv exists\n    if verbose:\n        print(\"input_csv:\\t%s\" % input_csv_path)\n    if not os.path.isfile(input_csv_path):\n        raise RuntimeError(\"Input csv cannot be found at %s\" % input_csv_path)\n\n    # Ensure mojo_zip exists\n    mojo_zip_path = os.path.abspath(mojo_zip_path)\n    if verbose:\n        print(\"mojo_zip:\\t%s\" % mojo_zip_path)\n    if not os.path.isfile(mojo_zip_path):\n        raise RuntimeError(\"MOJO zip cannot be found at %s\" % mojo_zip_path)\n\n    parent_dir = os.path.dirname(mojo_zip_path)\n\n    # Set output_csv if necessary\n    if output_csv_path is None:\n        output_csv_path = os.path.join(parent_dir, prediction_output_file)\n\n    # Set path to h2o-genmodel.jar if necessary and check it's valid\n    if genmodel_jar_path is None:\n        genmodel_jar_path = os.path.join(parent_dir, gen_model_file_name)\n    if verbose:\n        print(\"genmodel_jar:\\t%s\" % genmodel_jar_path)\n    if not os.path.isfile(genmodel_jar_path):\n        raise RuntimeError(\"Genmodel jar cannot be found at %s\" % genmodel_jar_path)\n\n    if verbose and output_csv_path is not None:\n        print(\"output_csv:\\t%s\" % output_csv_path)\n\n    # Set classpath if necessary\n    if classpath is None:\n        classpath = genmodel_jar_path\n    if verbose:\n        print(\"classpath:\\t%s\" % classpath)\n\n    # Set java_options if necessary\n    if java_options is None:\n        java_options = default_java_options\n    if verbose:\n        print(\"java_options:\\t%s\" % java_options)\n\n    # Construct command to invoke java\n    cmd = [java]\n    for option in java_options.split(' '):\n        cmd += [option]\n    cmd += [\"-cp\", classpath, h2o_predictor_class, \"--mojo\", mojo_zip_path, \"--input\", input_csv_path,\n            '--output', output_csv_path, '--decimal']\n    if verbose:\n        cmd_str = \" \".join(cmd)\n        print(\"java cmd:\\t%s\" % cmd_str)\n\n    # invoke the command\n    subprocess.check_call(cmd, shell=False)\n\n    # load predictions in form of a dict\n    with open(output_csv_path) as csv_file:\n        result = list(csv.DictReader(csv_file))\n    return result", "code_tokens": ["def", "mojo_predict_csv", "(", "input_csv_path", ",", "mojo_zip_path", ",", "output_csv_path", "=", "None", ",", "genmodel_jar_path", "=", "None", ",", "classpath", "=", "None", ",", "java_options", "=", "None", ",", "verbose", "=", "False", ")", ":", "default_java_options", "=", "'-Xmx4g -XX:ReservedCodeCacheSize=256m'", "prediction_output_file", "=", "'prediction.csv'", "# Checking java", "java", "=", "H2OLocalServer", ".", "_find_java", "(", ")", "H2OLocalServer", ".", "_check_java", "(", "java", "=", "java", ",", "verbose", "=", "verbose", ")", "# Ensure input_csv exists", "if", "verbose", ":", "print", "(", "\"input_csv:\\t%s\"", "%", "input_csv_path", ")", "if", "not", "os", ".", "path", ".", "isfile", "(", "input_csv_path", ")", ":", "raise", "RuntimeError", "(", "\"Input csv cannot be found at %s\"", "%", "input_csv_path", ")", "# Ensure mojo_zip exists", "mojo_zip_path", "=", "os", ".", "path", ".", "abspath", "(", "mojo_zip_path", ")", "if", "verbose", ":", "print", "(", "\"mojo_zip:\\t%s\"", "%", "mojo_zip_path", ")", "if", "not", "os", ".", "path", ".", "isfile", "(", "mojo_zip_path", ")", ":", "raise", "RuntimeError", "(", "\"MOJO zip cannot be found at %s\"", "%", "mojo_zip_path", ")", "parent_dir", "=", "os", ".", "path", ".", "dirname", "(", "mojo_zip_path", ")", "# Set output_csv if necessary", "if", "output_csv_path", "is", "None", ":", "output_csv_path", "=", "os", ".", "path", ".", "join", "(", "parent_dir", ",", "prediction_output_file", ")", "# Set path to h2o-genmodel.jar if necessary and check it's valid", "if", "genmodel_jar_path", "is", "None", ":", "genmodel_jar_path", "=", "os", ".", "path", ".", "join", "(", "parent_dir", ",", "gen_model_file_name", ")", "if", "verbose", ":", "print", "(", "\"genmodel_jar:\\t%s\"", "%", "genmodel_jar_path", ")", "if", "not", "os", ".", "path", ".", "isfile", "(", "genmodel_jar_path", ")", ":", "raise", "RuntimeError", "(", "\"Genmodel jar cannot be found at %s\"", "%", "genmodel_jar_path", ")", "if", "verbose", "and", "output_csv_path", "is", "not", "None", ":", "print", "(", "\"output_csv:\\t%s\"", "%", "output_csv_path", ")", "# Set classpath if necessary", "if", "classpath", "is", "None", ":", "classpath", "=", "genmodel_jar_path", "if", "verbose", ":", "print", "(", "\"classpath:\\t%s\"", "%", "classpath", ")", "# Set java_options if necessary", "if", "java_options", "is", "None", ":", "java_options", "=", "default_java_options", "if", "verbose", ":", "print", "(", "\"java_options:\\t%s\"", "%", "java_options", ")", "# Construct command to invoke java", "cmd", "=", "[", "java", "]", "for", "option", "in", "java_options", ".", "split", "(", "' '", ")", ":", "cmd", "+=", "[", "option", "]", "cmd", "+=", "[", "\"-cp\"", ",", "classpath", ",", "h2o_predictor_class", ",", "\"--mojo\"", ",", "mojo_zip_path", ",", "\"--input\"", ",", "input_csv_path", ",", "'--output'", ",", "output_csv_path", ",", "'--decimal'", "]", "if", "verbose", ":", "cmd_str", "=", "\" \"", ".", "join", "(", "cmd", ")", "print", "(", "\"java cmd:\\t%s\"", "%", "cmd_str", ")", "# invoke the command", "subprocess", ".", "check_call", "(", "cmd", ",", "shell", "=", "False", ")", "# load predictions in form of a dict", "with", "open", "(", "output_csv_path", ")", "as", "csv_file", ":", "result", "=", "list", "(", "csv", ".", "DictReader", "(", "csv_file", ")", ")", "return", "result"], "docstring": "MOJO scoring function to take a CSV file and use MOJO model as zip file to score.", "docstring_tokens": ["MOJO", "scoring", "function", "to", "take", "a", "CSV", "file", "and", "use", "MOJO", "model", "as", "zip", "file", "to", "score", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/utils/shared_utils.py#L410-L491", "partition": "test", "index": 1481, "time": "2018-03-16 13:42:47"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/automl/autoh2o.py", "func_name": "H2OAutoML.download_mojo", "original_string": "def download_mojo(self, path=\".\", get_genmodel_jar=False, genmodel_name=\"\"):\n        \"\"\"\n        Download the leader model in AutoML in MOJO format.\n\n        :param path: the path where MOJO file should be saved.\n        :param get_genmodel_jar: if True, then also download h2o-genmodel.jar and store it in folder ``path``.\n        :param genmodel_name Custom name of genmodel jar\n        :returns: name of the MOJO file written.\n        \"\"\"\n\n        return ModelBase.download_mojo(self.leader, path, get_genmodel_jar, genmodel_name)", "language": "python", "code": "def download_mojo(self, path=\".\", get_genmodel_jar=False, genmodel_name=\"\"):\n        \"\"\"\n        Download the leader model in AutoML in MOJO format.\n\n        :param path: the path where MOJO file should be saved.\n        :param get_genmodel_jar: if True, then also download h2o-genmodel.jar and store it in folder ``path``.\n        :param genmodel_name Custom name of genmodel jar\n        :returns: name of the MOJO file written.\n        \"\"\"\n\n        return ModelBase.download_mojo(self.leader, path, get_genmodel_jar, genmodel_name)", "code_tokens": ["def", "download_mojo", "(", "self", ",", "path", "=", "\".\"", ",", "get_genmodel_jar", "=", "False", ",", "genmodel_name", "=", "\"\"", ")", ":", "return", "ModelBase", ".", "download_mojo", "(", "self", ".", "leader", ",", "path", ",", "get_genmodel_jar", ",", "genmodel_name", ")"], "docstring": "Download the leader model in AutoML in MOJO format.", "docstring_tokens": ["Download", "the", "leader", "model", "in", "AutoML", "in", "MOJO", "format", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/automl/autoh2o.py#L457-L467", "partition": "test", "index": 1510, "time": "2018-04-11 17:35:20"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/automl/autoh2o.py", "func_name": "H2OAutoML.download_pojo", "original_string": "def download_pojo(self, path=\"\", get_genmodel_jar=False, genmodel_name=\"\"):\n        \"\"\"\n        Download the POJO for the leader model in AutoML to the directory specified by path.\n\n        If path is an empty string, then dump the output to screen.\n\n        :param path:  An absolute path to the directory where POJO should be saved.\n        :param get_genmodel_jar: if True, then also download h2o-genmodel.jar and store it in folder ``path``.\n        :param genmodel_name Custom name of genmodel jar\n        :returns: name of the POJO file written.\n        \"\"\"\n\n        return h2o.download_pojo(self.leader, path, get_jar=get_genmodel_jar, jar_name=genmodel_name)", "language": "python", "code": "def download_pojo(self, path=\"\", get_genmodel_jar=False, genmodel_name=\"\"):\n        \"\"\"\n        Download the POJO for the leader model in AutoML to the directory specified by path.\n\n        If path is an empty string, then dump the output to screen.\n\n        :param path:  An absolute path to the directory where POJO should be saved.\n        :param get_genmodel_jar: if True, then also download h2o-genmodel.jar and store it in folder ``path``.\n        :param genmodel_name Custom name of genmodel jar\n        :returns: name of the POJO file written.\n        \"\"\"\n\n        return h2o.download_pojo(self.leader, path, get_jar=get_genmodel_jar, jar_name=genmodel_name)", "code_tokens": ["def", "download_pojo", "(", "self", ",", "path", "=", "\"\"", ",", "get_genmodel_jar", "=", "False", ",", "genmodel_name", "=", "\"\"", ")", ":", "return", "h2o", ".", "download_pojo", "(", "self", ".", "leader", ",", "path", ",", "get_jar", "=", "get_genmodel_jar", ",", "jar_name", "=", "genmodel_name", ")"], "docstring": "Download the POJO for the leader model in AutoML to the directory specified by path.", "docstring_tokens": ["Download", "the", "POJO", "for", "the", "leader", "model", "in", "AutoML", "to", "the", "directory", "specified", "by", "path", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/automl/autoh2o.py#L443-L455", "partition": "test", "index": 1509, "time": "2018-04-11 17:35:20"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/automl/autoh2o.py", "func_name": "get_automl", "original_string": "def get_automl(project_name):\n    \"\"\"\n    Retrieve information about an AutoML instance.\n\n    :param str project_name:  A string indicating the project_name of the automl instance to retrieve.\n    :returns: A dictionary containing the project_name, leader model, and leaderboard.\n    \"\"\"\n    automl_json = h2o.api(\"GET /99/AutoML/%s\" % project_name)\n    project_name = automl_json[\"project_name\"]\n    leaderboard_list = [key[\"name\"] for key in automl_json['leaderboard']['models']]\n\n    if leaderboard_list is not None and len(leaderboard_list) > 0:\n        leader_id = leaderboard_list[0]\n    else:\n        leader_id = None\n\n    leader = h2o.get_model(leader_id)\n    # Intentionally mask the progress bar here since showing multiple progress bars is confusing to users.\n    # If any failure happens, revert back to user's original setting for progress and display the error message.\n    is_progress = H2OJob.__PROGRESS_BAR__\n    h2o.no_progress()\n    try:\n        # Parse leaderboard H2OTwoDimTable & return as an H2OFrame\n        leaderboard = h2o.H2OFrame(\n            automl_json[\"leaderboard_table\"].cell_values,\n            column_names=automl_json[\"leaderboard_table\"].col_header)\n    except Exception as ex:\n        raise ex\n    finally:\n        if is_progress is True:\n            h2o.show_progress()\n\n    leaderboard = leaderboard[1:]\n    automl_dict = {'project_name': project_name, \"leader\": leader, \"leaderboard\": leaderboard}\n    return automl_dict", "language": "python", "code": "def get_automl(project_name):\n    \"\"\"\n    Retrieve information about an AutoML instance.\n\n    :param str project_name:  A string indicating the project_name of the automl instance to retrieve.\n    :returns: A dictionary containing the project_name, leader model, and leaderboard.\n    \"\"\"\n    automl_json = h2o.api(\"GET /99/AutoML/%s\" % project_name)\n    project_name = automl_json[\"project_name\"]\n    leaderboard_list = [key[\"name\"] for key in automl_json['leaderboard']['models']]\n\n    if leaderboard_list is not None and len(leaderboard_list) > 0:\n        leader_id = leaderboard_list[0]\n    else:\n        leader_id = None\n\n    leader = h2o.get_model(leader_id)\n    # Intentionally mask the progress bar here since showing multiple progress bars is confusing to users.\n    # If any failure happens, revert back to user's original setting for progress and display the error message.\n    is_progress = H2OJob.__PROGRESS_BAR__\n    h2o.no_progress()\n    try:\n        # Parse leaderboard H2OTwoDimTable & return as an H2OFrame\n        leaderboard = h2o.H2OFrame(\n            automl_json[\"leaderboard_table\"].cell_values,\n            column_names=automl_json[\"leaderboard_table\"].col_header)\n    except Exception as ex:\n        raise ex\n    finally:\n        if is_progress is True:\n            h2o.show_progress()\n\n    leaderboard = leaderboard[1:]\n    automl_dict = {'project_name': project_name, \"leader\": leader, \"leaderboard\": leaderboard}\n    return automl_dict", "code_tokens": ["def", "get_automl", "(", "project_name", ")", ":", "automl_json", "=", "h2o", ".", "api", "(", "\"GET /99/AutoML/%s\"", "%", "project_name", ")", "project_name", "=", "automl_json", "[", "\"project_name\"", "]", "leaderboard_list", "=", "[", "key", "[", "\"name\"", "]", "for", "key", "in", "automl_json", "[", "'leaderboard'", "]", "[", "'models'", "]", "]", "if", "leaderboard_list", "is", "not", "None", "and", "len", "(", "leaderboard_list", ")", ">", "0", ":", "leader_id", "=", "leaderboard_list", "[", "0", "]", "else", ":", "leader_id", "=", "None", "leader", "=", "h2o", ".", "get_model", "(", "leader_id", ")", "# Intentionally mask the progress bar here since showing multiple progress bars is confusing to users.", "# If any failure happens, revert back to user's original setting for progress and display the error message.", "is_progress", "=", "H2OJob", ".", "__PROGRESS_BAR__", "h2o", ".", "no_progress", "(", ")", "try", ":", "# Parse leaderboard H2OTwoDimTable & return as an H2OFrame", "leaderboard", "=", "h2o", ".", "H2OFrame", "(", "automl_json", "[", "\"leaderboard_table\"", "]", ".", "cell_values", ",", "column_names", "=", "automl_json", "[", "\"leaderboard_table\"", "]", ".", "col_header", ")", "except", "Exception", "as", "ex", ":", "raise", "ex", "finally", ":", "if", "is_progress", "is", "True", ":", "h2o", ".", "show_progress", "(", ")", "leaderboard", "=", "leaderboard", "[", "1", ":", "]", "automl_dict", "=", "{", "'project_name'", ":", "project_name", ",", "\"leader\"", ":", "leader", ",", "\"leaderboard\"", ":", "leaderboard", "}", "return", "automl_dict"], "docstring": "Retrieve information about an AutoML instance.", "docstring_tokens": ["Retrieve", "information", "about", "an", "AutoML", "instance", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/automl/autoh2o.py#L503-L537", "partition": "test", "index": 1508, "time": "2018-05-25 16:12:44"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/targetencoder.py", "func_name": "TargetEncoder.fit", "original_string": "def fit(self, frame = None):\n        \"\"\"\n        Returns encoding map as an object that maps 'column_name' -> 'frame_with_encoding_map_for_this_column_name'\n\n        :param frame frame: An H2OFrame object with which to create the target encoding map\n        \"\"\"\n        self._teColumns = list(map(lambda i: frame.names[i], self._teColumns)) if all(isinstance(n, int) for n in self._teColumns) else self._teColumns\n        self._responseColumnName = frame.names[self._responseColumnName] if isinstance(self._responseColumnName, int) else self._responseColumnName\n        self._foldColumnName = frame.names[self._foldColumnName] if isinstance(self._foldColumnName, int) else self._foldColumnName\n        \n        self._encodingMap = ExprNode(\"target.encoder.fit\", frame, self._teColumns, self._responseColumnName,\n                                     self._foldColumnName)._eager_map_frame()\n\n        return self._encodingMap", "language": "python", "code": "def fit(self, frame = None):\n        \"\"\"\n        Returns encoding map as an object that maps 'column_name' -> 'frame_with_encoding_map_for_this_column_name'\n\n        :param frame frame: An H2OFrame object with which to create the target encoding map\n        \"\"\"\n        self._teColumns = list(map(lambda i: frame.names[i], self._teColumns)) if all(isinstance(n, int) for n in self._teColumns) else self._teColumns\n        self._responseColumnName = frame.names[self._responseColumnName] if isinstance(self._responseColumnName, int) else self._responseColumnName\n        self._foldColumnName = frame.names[self._foldColumnName] if isinstance(self._foldColumnName, int) else self._foldColumnName\n        \n        self._encodingMap = ExprNode(\"target.encoder.fit\", frame, self._teColumns, self._responseColumnName,\n                                     self._foldColumnName)._eager_map_frame()\n\n        return self._encodingMap", "code_tokens": ["def", "fit", "(", "self", ",", "frame", "=", "None", ")", ":", "self", ".", "_teColumns", "=", "list", "(", "map", "(", "lambda", "i", ":", "frame", ".", "names", "[", "i", "]", ",", "self", ".", "_teColumns", ")", ")", "if", "all", "(", "isinstance", "(", "n", ",", "int", ")", "for", "n", "in", "self", ".", "_teColumns", ")", "else", "self", ".", "_teColumns", "self", ".", "_responseColumnName", "=", "frame", ".", "names", "[", "self", ".", "_responseColumnName", "]", "if", "isinstance", "(", "self", ".", "_responseColumnName", ",", "int", ")", "else", "self", ".", "_responseColumnName", "self", ".", "_foldColumnName", "=", "frame", ".", "names", "[", "self", ".", "_foldColumnName", "]", "if", "isinstance", "(", "self", ".", "_foldColumnName", ",", "int", ")", "else", "self", ".", "_foldColumnName", "self", ".", "_encodingMap", "=", "ExprNode", "(", "\"target.encoder.fit\"", ",", "frame", ",", "self", ".", "_teColumns", ",", "self", ".", "_responseColumnName", ",", "self", ".", "_foldColumnName", ")", ".", "_eager_map_frame", "(", ")", "return", "self", ".", "_encodingMap"], "docstring": "Returns encoding map as an object that maps 'column_name' -> 'frame_with_encoding_map_for_this_column_name'", "docstring_tokens": ["Returns", "encoding", "map", "as", "an", "object", "that", "maps", "column_name", "-", ">", "frame_with_encoding_map_for_this_column_name"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/targetencoder.py#L78-L91", "partition": "test", "index": 1387, "time": "2018-10-17 19:43:33"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/pipeline/mojo_pipeline.py", "func_name": "H2OMojoPipeline.transform", "original_string": "def transform(self, data, allow_timestamps=False):\n        \"\"\"\n        Transform H2OFrame using a MOJO Pipeline.\n\n        :param data: Frame to be transformed.\n        :param allow_timestamps: Allows datetime columns to be used directly with MOJO pipelines. It is recommended\n        to parse your datetime columns as Strings when using pipelines because pipelines can interpret certain datetime\n        formats in a different way. If your H2OFrame is parsed from a binary file format (eg. Parquet) instead of CSV\n        it is safe to turn this option on and use datetime columns directly.\n\n        :returns: A new H2OFrame.\n        \"\"\"\n        assert_is_type(data, H2OFrame)\n        assert_is_type(allow_timestamps, bool)\n        return H2OFrame._expr(ExprNode(\"mojo.pipeline.transform\", self.pipeline_id[0], data, allow_timestamps))", "language": "python", "code": "def transform(self, data, allow_timestamps=False):\n        \"\"\"\n        Transform H2OFrame using a MOJO Pipeline.\n\n        :param data: Frame to be transformed.\n        :param allow_timestamps: Allows datetime columns to be used directly with MOJO pipelines. It is recommended\n        to parse your datetime columns as Strings when using pipelines because pipelines can interpret certain datetime\n        formats in a different way. If your H2OFrame is parsed from a binary file format (eg. Parquet) instead of CSV\n        it is safe to turn this option on and use datetime columns directly.\n\n        :returns: A new H2OFrame.\n        \"\"\"\n        assert_is_type(data, H2OFrame)\n        assert_is_type(allow_timestamps, bool)\n        return H2OFrame._expr(ExprNode(\"mojo.pipeline.transform\", self.pipeline_id[0], data, allow_timestamps))", "code_tokens": ["def", "transform", "(", "self", ",", "data", ",", "allow_timestamps", "=", "False", ")", ":", "assert_is_type", "(", "data", ",", "H2OFrame", ")", "assert_is_type", "(", "allow_timestamps", ",", "bool", ")", "return", "H2OFrame", ".", "_expr", "(", "ExprNode", "(", "\"mojo.pipeline.transform\"", ",", "self", ".", "pipeline_id", "[", "0", "]", ",", "data", ",", "allow_timestamps", ")", ")"], "docstring": "Transform H2OFrame using a MOJO Pipeline.", "docstring_tokens": ["Transform", "H2OFrame", "using", "a", "MOJO", "Pipeline", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/pipeline/mojo_pipeline.py#L39-L53", "partition": "test", "index": 1576, "time": "2018-12-17 14:17:51"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/h2o.py", "func_name": "import_hive_table", "original_string": "def import_hive_table(database=None, table=None, partitions=None, allow_multi_format=False):\n    \"\"\"\n    Import Hive table to H2OFrame in memory.\n\n    Make sure to start H2O with Hive on classpath. Uses hive-site.xml on classpath to connect to Hive.\n\n    :param database: Name of Hive database (default database will be used by default)\n    :param table: name of Hive table to import\n    :param partitions: a list of lists of strings - partition key column values of partitions you want to import.\n    :param allow_multi_format: enable import of partitioned tables with different storage formats used. WARNING:\n        this may fail on out-of-memory for tables with a large number of small partitions.\n\n    :returns: an :class:`H2OFrame` containing data of the specified Hive table.\n\n    :examples:\n        >>> my_citibike_data = h2o.import_hive_table(\"default\", \"table\", [[\"2017\", \"01\"], [\"2017\", \"02\"]])\n    \"\"\"    \n    assert_is_type(database, str, None)\n    assert_is_type(table, str)\n    assert_is_type(partitions, [[str]], None)\n    p = { \"database\": database, \"table\": table, \"partitions\": partitions, \"allow_multi_format\": allow_multi_format }\n    j = H2OJob(api(\"POST /3/ImportHiveTable\", data=p), \"Import Hive Table\").poll()\n    return get_frame(j.dest_key)", "language": "python", "code": "def import_hive_table(database=None, table=None, partitions=None, allow_multi_format=False):\n    \"\"\"\n    Import Hive table to H2OFrame in memory.\n\n    Make sure to start H2O with Hive on classpath. Uses hive-site.xml on classpath to connect to Hive.\n\n    :param database: Name of Hive database (default database will be used by default)\n    :param table: name of Hive table to import\n    :param partitions: a list of lists of strings - partition key column values of partitions you want to import.\n    :param allow_multi_format: enable import of partitioned tables with different storage formats used. WARNING:\n        this may fail on out-of-memory for tables with a large number of small partitions.\n\n    :returns: an :class:`H2OFrame` containing data of the specified Hive table.\n\n    :examples:\n        >>> my_citibike_data = h2o.import_hive_table(\"default\", \"table\", [[\"2017\", \"01\"], [\"2017\", \"02\"]])\n    \"\"\"    \n    assert_is_type(database, str, None)\n    assert_is_type(table, str)\n    assert_is_type(partitions, [[str]], None)\n    p = { \"database\": database, \"table\": table, \"partitions\": partitions, \"allow_multi_format\": allow_multi_format }\n    j = H2OJob(api(\"POST /3/ImportHiveTable\", data=p), \"Import Hive Table\").poll()\n    return get_frame(j.dest_key)", "code_tokens": ["def", "import_hive_table", "(", "database", "=", "None", ",", "table", "=", "None", ",", "partitions", "=", "None", ",", "allow_multi_format", "=", "False", ")", ":", "assert_is_type", "(", "database", ",", "str", ",", "None", ")", "assert_is_type", "(", "table", ",", "str", ")", "assert_is_type", "(", "partitions", ",", "[", "[", "str", "]", "]", ",", "None", ")", "p", "=", "{", "\"database\"", ":", "database", ",", "\"table\"", ":", "table", ",", "\"partitions\"", ":", "partitions", ",", "\"allow_multi_format\"", ":", "allow_multi_format", "}", "j", "=", "H2OJob", "(", "api", "(", "\"POST /3/ImportHiveTable\"", ",", "data", "=", "p", ")", ",", "\"Import Hive Table\"", ")", ".", "poll", "(", ")", "return", "get_frame", "(", "j", ".", "dest_key", ")"], "docstring": "Import Hive table to H2OFrame in memory.", "docstring_tokens": ["Import", "Hive", "table", "to", "H2OFrame", "in", "memory", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/h2o.py#L440-L462", "partition": "test", "index": 1458, "time": "2019-02-06 19:20:04"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/backend/cluster.py", "func_name": "H2OCluster.list_jobs", "original_string": "def list_jobs(self):\n        \"\"\"List all jobs performed by the cluster.\"\"\"\n        res = h2o.api(\"GET /3/Jobs\")\n        table = [[\"type\"], [\"dest\"], [\"description\"], [\"status\"]]\n        for job in res[\"jobs\"]:\n            job_dest = job[\"dest\"]\n            table[0].append(self._translate_job_type(job_dest[\"type\"]))\n            table[1].append(job_dest[\"name\"])\n            table[2].append(job[\"description\"])\n            table[3].append(job[\"status\"])\n        return table", "language": "python", "code": "def list_jobs(self):\n        \"\"\"List all jobs performed by the cluster.\"\"\"\n        res = h2o.api(\"GET /3/Jobs\")\n        table = [[\"type\"], [\"dest\"], [\"description\"], [\"status\"]]\n        for job in res[\"jobs\"]:\n            job_dest = job[\"dest\"]\n            table[0].append(self._translate_job_type(job_dest[\"type\"]))\n            table[1].append(job_dest[\"name\"])\n            table[2].append(job[\"description\"])\n            table[3].append(job[\"status\"])\n        return table", "code_tokens": ["def", "list_jobs", "(", "self", ")", ":", "res", "=", "h2o", ".", "api", "(", "\"GET /3/Jobs\"", ")", "table", "=", "[", "[", "\"type\"", "]", ",", "[", "\"dest\"", "]", ",", "[", "\"description\"", "]", ",", "[", "\"status\"", "]", "]", "for", "job", "in", "res", "[", "\"jobs\"", "]", ":", "job_dest", "=", "job", "[", "\"dest\"", "]", "table", "[", "0", "]", ".", "append", "(", "self", ".", "_translate_job_type", "(", "job_dest", "[", "\"type\"", "]", ")", ")", "table", "[", "1", "]", ".", "append", "(", "job_dest", "[", "\"name\"", "]", ")", "table", "[", "2", "]", ".", "append", "(", "job", "[", "\"description\"", "]", ")", "table", "[", "3", "]", ".", "append", "(", "job", "[", "\"status\"", "]", ")", "return", "table"], "docstring": "List all jobs performed by the cluster.", "docstring_tokens": ["List", "all", "jobs", "performed", "by", "the", "cluster", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/backend/cluster.py#L266-L276", "partition": "test", "index": 1322, "time": "2019-04-18 23:06:04"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/estimators/estimator_base.py", "func_name": "H2OEstimator.join", "original_string": "def join(self):\n        \"\"\"Wait until job's completion.\"\"\"\n        self._future = False\n        self._job.poll()\n        model_key = self._job.dest_key\n        self._job = None\n        model_json = h2o.api(\"GET /%d/Models/%s\" % (self._rest_version, model_key))[\"models\"][0]\n        self._resolve_model(model_key, model_json)", "language": "python", "code": "def join(self):\n        \"\"\"Wait until job's completion.\"\"\"\n        self._future = False\n        self._job.poll()\n        model_key = self._job.dest_key\n        self._job = None\n        model_json = h2o.api(\"GET /%d/Models/%s\" % (self._rest_version, model_key))[\"models\"][0]\n        self._resolve_model(model_key, model_json)", "code_tokens": ["def", "join", "(", "self", ")", ":", "self", ".", "_future", "=", "False", "self", ".", "_job", ".", "poll", "(", ")", "model_key", "=", "self", ".", "_job", ".", "dest_key", "self", ".", "_job", "=", "None", "model_json", "=", "h2o", ".", "api", "(", "\"GET /%d/Models/%s\"", "%", "(", "self", ".", "_rest_version", ",", "model_key", ")", ")", "[", "\"models\"", "]", "[", "0", "]", "self", ".", "_resolve_model", "(", "model_key", ",", "model_json", ")"], "docstring": "Wait until job's completion.", "docstring_tokens": ["Wait", "until", "job", "s", "completion", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/estimators/estimator_base.py#L79-L86", "partition": "test", "index": 1345, "time": "2016-08-25 15:32:40"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/estimators/estimator_base.py", "func_name": "H2OEstimator.fit", "original_string": "def fit(self, X, y=None, **params):\n        \"\"\"\n        Fit an H2O model as part of a scikit-learn pipeline or grid search.\n\n        A warning will be issued if a caller other than sklearn attempts to use this method.\n\n        :param H2OFrame X: An H2OFrame consisting of the predictor variables.\n        :param H2OFrame y: An H2OFrame consisting of the response variable.\n        :param params: Extra arguments.\n        :returns: The current instance of H2OEstimator for method chaining.\n        \"\"\"\n        stk = inspect.stack()[1:]\n        warn = True\n        for s in stk:\n            mod = inspect.getmodule(s[0])\n            if mod:\n                warn = \"sklearn\" not in mod.__name__\n                if not warn: break\n        if warn:\n            warnings.warn(\"\\n\\n\\t`fit` is not recommended outside of the sklearn framework. Use `train` instead.\",\n                          UserWarning, stacklevel=2)\n        training_frame = X.cbind(y) if y is not None else X\n        x = X.names\n        y = y.names[0] if y is not None else None\n        self.train(x, y, training_frame, **params)\n        return self", "language": "python", "code": "def fit(self, X, y=None, **params):\n        \"\"\"\n        Fit an H2O model as part of a scikit-learn pipeline or grid search.\n\n        A warning will be issued if a caller other than sklearn attempts to use this method.\n\n        :param H2OFrame X: An H2OFrame consisting of the predictor variables.\n        :param H2OFrame y: An H2OFrame consisting of the response variable.\n        :param params: Extra arguments.\n        :returns: The current instance of H2OEstimator for method chaining.\n        \"\"\"\n        stk = inspect.stack()[1:]\n        warn = True\n        for s in stk:\n            mod = inspect.getmodule(s[0])\n            if mod:\n                warn = \"sklearn\" not in mod.__name__\n                if not warn: break\n        if warn:\n            warnings.warn(\"\\n\\n\\t`fit` is not recommended outside of the sklearn framework. Use `train` instead.\",\n                          UserWarning, stacklevel=2)\n        training_frame = X.cbind(y) if y is not None else X\n        x = X.names\n        y = y.names[0] if y is not None else None\n        self.train(x, y, training_frame, **params)\n        return self", "code_tokens": ["def", "fit", "(", "self", ",", "X", ",", "y", "=", "None", ",", "*", "*", "params", ")", ":", "stk", "=", "inspect", ".", "stack", "(", ")", "[", "1", ":", "]", "warn", "=", "True", "for", "s", "in", "stk", ":", "mod", "=", "inspect", ".", "getmodule", "(", "s", "[", "0", "]", ")", "if", "mod", ":", "warn", "=", "\"sklearn\"", "not", "in", "mod", ".", "__name__", "if", "not", "warn", ":", "break", "if", "warn", ":", "warnings", ".", "warn", "(", "\"\\n\\n\\t`fit` is not recommended outside of the sklearn framework. Use `train` instead.\"", ",", "UserWarning", ",", "stacklevel", "=", "2", ")", "training_frame", "=", "X", ".", "cbind", "(", "y", ")", "if", "y", "is", "not", "None", "else", "X", "x", "=", "X", ".", "names", "y", "=", "y", ".", "names", "[", "0", "]", "if", "y", "is", "not", "None", "else", "None", "self", ".", "train", "(", "x", ",", "y", ",", "training_frame", ",", "*", "*", "params", ")", "return", "self"], "docstring": "Fit an H2O model as part of a scikit-learn pipeline or grid search.", "docstring_tokens": ["Fit", "an", "H2O", "model", "as", "part", "of", "a", "scikit", "-", "learn", "pipeline", "or", "grid", "search", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/estimators/estimator_base.py#L325-L350", "partition": "test", "index": 1347, "time": "2016-08-25 15:32:40"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/estimators/deepwater.py", "func_name": "H2ODeepWaterEstimator.available", "original_string": "def available():\n        \"\"\"Returns True if a deep water model can be built, or False otherwise.\"\"\"\n        builder_json = h2o.api(\"GET /3/ModelBuilders\", data={\"algo\": \"deepwater\"})\n        visibility = builder_json[\"model_builders\"][\"deepwater\"][\"visibility\"]\n        if visibility == \"Experimental\":\n            print(\"Cannot build a Deep Water model - no backend found.\")\n            return False\n        else:\n            return True", "language": "python", "code": "def available():\n        \"\"\"Returns True if a deep water model can be built, or False otherwise.\"\"\"\n        builder_json = h2o.api(\"GET /3/ModelBuilders\", data={\"algo\": \"deepwater\"})\n        visibility = builder_json[\"model_builders\"][\"deepwater\"][\"visibility\"]\n        if visibility == \"Experimental\":\n            print(\"Cannot build a Deep Water model - no backend found.\")\n            return False\n        else:\n            return True", "code_tokens": ["def", "available", "(", ")", ":", "builder_json", "=", "h2o", ".", "api", "(", "\"GET /3/ModelBuilders\"", ",", "data", "=", "{", "\"algo\"", ":", "\"deepwater\"", "}", ")", "visibility", "=", "builder_json", "[", "\"model_builders\"", "]", "[", "\"deepwater\"", "]", "[", "\"visibility\"", "]", "if", "visibility", "==", "\"Experimental\"", ":", "print", "(", "\"Cannot build a Deep Water model - no backend found.\"", ")", "return", "False", "else", ":", "return", "True"], "docstring": "Returns True if a deep water model can be built, or False otherwise.", "docstring_tokens": ["Returns", "True", "if", "a", "deep", "water", "model", "can", "be", "built", "or", "False", "otherwise", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/estimators/deepwater.py#L1024-L1032", "partition": "test", "index": 1581, "time": "2016-09-01 21:49:49"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/frame.py", "func_name": "H2OFrame.difflag1", "original_string": "def difflag1(self):\n        \"\"\"\n        Conduct a diff-1 transform on a numeric frame column.\n\n        :returns: an H2OFrame where each element is equal to the corresponding element in the source\n            frame minus the previous-row element in the same frame.\n        \"\"\"\n        if self.ncols > 1:\n            raise H2OValueError(\"Only single-column frames supported\")\n        if self.types[self.columns[0]] not in {\"real\", \"int\", \"bool\"}:\n            raise H2OValueError(\"Numeric column expected\")\n        fr = H2OFrame._expr(expr=ExprNode(\"difflag1\", self), cache=self._ex._cache)\n        return fr", "language": "python", "code": "def difflag1(self):\n        \"\"\"\n        Conduct a diff-1 transform on a numeric frame column.\n\n        :returns: an H2OFrame where each element is equal to the corresponding element in the source\n            frame minus the previous-row element in the same frame.\n        \"\"\"\n        if self.ncols > 1:\n            raise H2OValueError(\"Only single-column frames supported\")\n        if self.types[self.columns[0]] not in {\"real\", \"int\", \"bool\"}:\n            raise H2OValueError(\"Numeric column expected\")\n        fr = H2OFrame._expr(expr=ExprNode(\"difflag1\", self), cache=self._ex._cache)\n        return fr", "code_tokens": ["def", "difflag1", "(", "self", ")", ":", "if", "self", ".", "ncols", ">", "1", ":", "raise", "H2OValueError", "(", "\"Only single-column frames supported\"", ")", "if", "self", ".", "types", "[", "self", ".", "columns", "[", "0", "]", "]", "not", "in", "{", "\"real\"", ",", "\"int\"", ",", "\"bool\"", "}", ":", "raise", "H2OValueError", "(", "\"Numeric column expected\"", ")", "fr", "=", "H2OFrame", ".", "_expr", "(", "expr", "=", "ExprNode", "(", "\"difflag1\"", ",", "self", ")", ",", "cache", "=", "self", ".", "_ex", ".", "_cache", ")", "return", "fr"], "docstring": "Conduct a diff-1 transform on a numeric frame column.", "docstring_tokens": ["Conduct", "a", "diff", "-", "1", "transform", "on", "a", "numeric", "frame", "column", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/frame.py#L3041-L3053", "partition": "test", "index": 1437, "time": "2016-09-02 18:52:52"}
{"repo": "h2oai/h2o-3", "path": "h2o-bindings/bin/gen_python.py", "func_name": "normalize_enum_constant", "original_string": "def normalize_enum_constant(s):\n    \"\"\"Return enum constant `s` converted to a canonical snake-case.\"\"\"\n    if s.islower(): return s\n    if s.isupper(): return s.lower()\n    return \"\".join(ch if ch.islower() else \"_\" + ch.lower() for ch in s).strip(\"_\")", "language": "python", "code": "def normalize_enum_constant(s):\n    \"\"\"Return enum constant `s` converted to a canonical snake-case.\"\"\"\n    if s.islower(): return s\n    if s.isupper(): return s.lower()\n    return \"\".join(ch if ch.islower() else \"_\" + ch.lower() for ch in s).strip(\"_\")", "code_tokens": ["def", "normalize_enum_constant", "(", "s", ")", ":", "if", "s", ".", "islower", "(", ")", ":", "return", "s", "if", "s", ".", "isupper", "(", ")", ":", "return", "s", ".", "lower", "(", ")", "return", "\"\"", ".", "join", "(", "ch", "if", "ch", ".", "islower", "(", ")", "else", "\"_\"", "+", "ch", ".", "lower", "(", ")", "for", "ch", "in", "s", ")", ".", "strip", "(", "\"_\"", ")"], "docstring": "Return enum constant `s` converted to a canonical snake-case.", "docstring_tokens": ["Return", "enum", "constant", "s", "converted", "to", "a", "canonical", "snake", "-", "case", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-bindings/bin/gen_python.py#L66-L70", "partition": "test", "index": 1527, "time": "2016-09-16 17:25:35"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/frame.py", "func_name": "H2OFrame.columns_by_type", "original_string": "def columns_by_type(self, coltype=\"numeric\"):\n        \"\"\"\n        Extract columns of the specified type from the frame.\n\n        :param str coltype: A character string indicating which column type to filter by. This must be\n            one of the following:\n\n            - ``\"numeric\"``      - Numeric, but not categorical or time\n            - ``\"categorical\"``  - Integer, with a categorical/factor String mapping\n            - ``\"string\"``       - String column\n            - ``\"time\"``         - Long msec since the Unix Epoch - with a variety of display/parse options\n            - ``\"uuid\"``         - UUID\n            - ``\"bad\"``          - No none-NA rows (triple negative! all NAs or zero rows)\n\n        :returns: list of indices of columns that have the requested type\n        \"\"\"\n        assert_is_type(coltype, \"numeric\", \"categorical\", \"string\", \"time\", \"uuid\", \"bad\")\n        assert_is_type(self, H2OFrame)\n        return ExprNode(\"columnsByType\", self, coltype)._eager_scalar()", "language": "python", "code": "def columns_by_type(self, coltype=\"numeric\"):\n        \"\"\"\n        Extract columns of the specified type from the frame.\n\n        :param str coltype: A character string indicating which column type to filter by. This must be\n            one of the following:\n\n            - ``\"numeric\"``      - Numeric, but not categorical or time\n            - ``\"categorical\"``  - Integer, with a categorical/factor String mapping\n            - ``\"string\"``       - String column\n            - ``\"time\"``         - Long msec since the Unix Epoch - with a variety of display/parse options\n            - ``\"uuid\"``         - UUID\n            - ``\"bad\"``          - No none-NA rows (triple negative! all NAs or zero rows)\n\n        :returns: list of indices of columns that have the requested type\n        \"\"\"\n        assert_is_type(coltype, \"numeric\", \"categorical\", \"string\", \"time\", \"uuid\", \"bad\")\n        assert_is_type(self, H2OFrame)\n        return ExprNode(\"columnsByType\", self, coltype)._eager_scalar()", "code_tokens": ["def", "columns_by_type", "(", "self", ",", "coltype", "=", "\"numeric\"", ")", ":", "assert_is_type", "(", "coltype", ",", "\"numeric\"", ",", "\"categorical\"", ",", "\"string\"", ",", "\"time\"", ",", "\"uuid\"", ",", "\"bad\"", ")", "assert_is_type", "(", "self", ",", "H2OFrame", ")", "return", "ExprNode", "(", "\"columnsByType\"", ",", "self", ",", "coltype", ")", ".", "_eager_scalar", "(", ")"], "docstring": "Extract columns of the specified type from the frame.", "docstring_tokens": ["Extract", "columns", "of", "the", "specified", "type", "from", "the", "frame", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/frame.py#L379-L397", "partition": "test", "index": 1391, "time": "2016-09-19 18:32:09"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/utils/config.py", "func_name": "H2OConfigReader._read_config", "original_string": "def _read_config(self):\n        \"\"\"Find and parse config file, storing all variables in ``self._config``.\"\"\"\n        self._config_loaded = True\n        conf = []\n        for f in self._candidate_log_files():\n            if os.path.isfile(f):\n                self._logger.info(\"Reading config file %s\" % f)\n                section_rx = re.compile(r\"^\\[(\\w+)\\]$\")\n                keyvalue_rx = re.compile(r\"^(\\w+:)?([\\w.]+)\\s*=(.*)$\")\n                with io.open(f, \"rt\", encoding=\"utf-8\") as config_file:\n                    section_name = None\n                    for lineno, line in enumerate(config_file):\n                        line = line.strip()\n                        if line == \"\" or line.startswith(\"#\"): continue\n                        m1 = section_rx.match(line)\n                        if m1:\n                            section_name = m1.group(1)\n                            continue\n                        m2 = keyvalue_rx.match(line)\n                        if m2:\n                            lng = m2.group(1)\n                            key = m2.group(2)\n                            val = m2.group(3).strip()\n                            if lng and lng.lower() != \"py:\": continue\n                            if section_name:\n                                key = section_name + \".\" + key\n                            if key in H2OConfigReader._allowed_config_keys:\n                                conf.append((key, val))\n                            else:\n                                self._logger.error(\"Key %s is not a valid config key\" % key)\n                            continue\n                        self._logger.error(\"Syntax error in config file line %d: %s\" % (lineno, line))\n                self._config = dict(conf)\n                return", "language": "python", "code": "def _read_config(self):\n        \"\"\"Find and parse config file, storing all variables in ``self._config``.\"\"\"\n        self._config_loaded = True\n        conf = []\n        for f in self._candidate_log_files():\n            if os.path.isfile(f):\n                self._logger.info(\"Reading config file %s\" % f)\n                section_rx = re.compile(r\"^\\[(\\w+)\\]$\")\n                keyvalue_rx = re.compile(r\"^(\\w+:)?([\\w.]+)\\s*=(.*)$\")\n                with io.open(f, \"rt\", encoding=\"utf-8\") as config_file:\n                    section_name = None\n                    for lineno, line in enumerate(config_file):\n                        line = line.strip()\n                        if line == \"\" or line.startswith(\"#\"): continue\n                        m1 = section_rx.match(line)\n                        if m1:\n                            section_name = m1.group(1)\n                            continue\n                        m2 = keyvalue_rx.match(line)\n                        if m2:\n                            lng = m2.group(1)\n                            key = m2.group(2)\n                            val = m2.group(3).strip()\n                            if lng and lng.lower() != \"py:\": continue\n                            if section_name:\n                                key = section_name + \".\" + key\n                            if key in H2OConfigReader._allowed_config_keys:\n                                conf.append((key, val))\n                            else:\n                                self._logger.error(\"Key %s is not a valid config key\" % key)\n                            continue\n                        self._logger.error(\"Syntax error in config file line %d: %s\" % (lineno, line))\n                self._config = dict(conf)\n                return", "code_tokens": ["def", "_read_config", "(", "self", ")", ":", "self", ".", "_config_loaded", "=", "True", "conf", "=", "[", "]", "for", "f", "in", "self", ".", "_candidate_log_files", "(", ")", ":", "if", "os", ".", "path", ".", "isfile", "(", "f", ")", ":", "self", ".", "_logger", ".", "info", "(", "\"Reading config file %s\"", "%", "f", ")", "section_rx", "=", "re", ".", "compile", "(", "r\"^\\[(\\w+)\\]$\"", ")", "keyvalue_rx", "=", "re", ".", "compile", "(", "r\"^(\\w+:)?([\\w.]+)\\s*=(.*)$\"", ")", "with", "io", ".", "open", "(", "f", ",", "\"rt\"", ",", "encoding", "=", "\"utf-8\"", ")", "as", "config_file", ":", "section_name", "=", "None", "for", "lineno", ",", "line", "in", "enumerate", "(", "config_file", ")", ":", "line", "=", "line", ".", "strip", "(", ")", "if", "line", "==", "\"\"", "or", "line", ".", "startswith", "(", "\"#\"", ")", ":", "continue", "m1", "=", "section_rx", ".", "match", "(", "line", ")", "if", "m1", ":", "section_name", "=", "m1", ".", "group", "(", "1", ")", "continue", "m2", "=", "keyvalue_rx", ".", "match", "(", "line", ")", "if", "m2", ":", "lng", "=", "m2", ".", "group", "(", "1", ")", "key", "=", "m2", ".", "group", "(", "2", ")", "val", "=", "m2", ".", "group", "(", "3", ")", ".", "strip", "(", ")", "if", "lng", "and", "lng", ".", "lower", "(", ")", "!=", "\"py:\"", ":", "continue", "if", "section_name", ":", "key", "=", "section_name", "+", "\".\"", "+", "key", "if", "key", "in", "H2OConfigReader", ".", "_allowed_config_keys", ":", "conf", ".", "append", "(", "(", "key", ",", "val", ")", ")", "else", ":", "self", ".", "_logger", ".", "error", "(", "\"Key %s is not a valid config key\"", "%", "key", ")", "continue", "self", ".", "_logger", ".", "error", "(", "\"Syntax error in config file line %d: %s\"", "%", "(", "lineno", ",", "line", ")", ")", "self", ".", "_config", "=", "dict", "(", "conf", ")", "return"], "docstring": "Find and parse config file, storing all variables in ``self._config``.", "docstring_tokens": ["Find", "and", "parse", "config", "file", "storing", "all", "variables", "in", "self", ".", "_config", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/utils/config.py#L56-L89", "partition": "test", "index": 1374, "time": "2016-09-27 12:18:26"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/utils/config.py", "func_name": "H2OConfigReader._candidate_log_files", "original_string": "def _candidate_log_files():\n        \"\"\"Return possible locations for the .h2oconfig file, one at a time.\"\"\"\n        # Search for .h2oconfig in the current directory and all parent directories\n        relpath = \".h2oconfig\"\n        prevpath = None\n        while True:\n            abspath = os.path.abspath(relpath)\n            if abspath == prevpath: break\n            prevpath = abspath\n            relpath = \"../\" + relpath\n            yield abspath\n        # Also check if .h2oconfig exists in the user's directory\n        yield os.path.expanduser(\"~/.h2oconfig\")", "language": "python", "code": "def _candidate_log_files():\n        \"\"\"Return possible locations for the .h2oconfig file, one at a time.\"\"\"\n        # Search for .h2oconfig in the current directory and all parent directories\n        relpath = \".h2oconfig\"\n        prevpath = None\n        while True:\n            abspath = os.path.abspath(relpath)\n            if abspath == prevpath: break\n            prevpath = abspath\n            relpath = \"../\" + relpath\n            yield abspath\n        # Also check if .h2oconfig exists in the user's directory\n        yield os.path.expanduser(\"~/.h2oconfig\")", "code_tokens": ["def", "_candidate_log_files", "(", ")", ":", "# Search for .h2oconfig in the current directory and all parent directories", "relpath", "=", "\".h2oconfig\"", "prevpath", "=", "None", "while", "True", ":", "abspath", "=", "os", ".", "path", ".", "abspath", "(", "relpath", ")", "if", "abspath", "==", "prevpath", ":", "break", "prevpath", "=", "abspath", "relpath", "=", "\"../\"", "+", "relpath", "yield", "abspath", "# Also check if .h2oconfig exists in the user's directory", "yield", "os", ".", "path", ".", "expanduser", "(", "\"~/.h2oconfig\"", ")"], "docstring": "Return possible locations for the .h2oconfig file, one at a time.", "docstring_tokens": ["Return", "possible", "locations", "for", "the", ".", "h2oconfig", "file", "one", "at", "a", "time", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/utils/config.py#L92-L104", "partition": "test", "index": 1375, "time": "2016-09-27 12:18:26"}
