{"repo": "h2oai/h2o-3", "path": "scripts/run.py", "func_name": "H2OCloudNode.scrape_port_from_stdout", "original_string": "def scrape_port_from_stdout(self):\n        \"\"\"\n        Look at the stdout log and figure out which port the JVM chose.\n\n        If successful, port number is stored in self.port; otherwise the\n        program is terminated. This call is blocking, and will wait for\n        up to 30s for the server to start up.\n        \"\"\"\n        regex = re.compile(r\"Open H2O Flow in your web browser: https?://([^:]+):(\\d+)\")\n        retries_left = 30\n        while retries_left and not self.terminated:\n            with open(self.output_file_name, \"r\") as f:\n                for line in f:\n                    mm = re.search(regex, line)\n                    if mm is not None:\n                        self.port = mm.group(2)\n                        print(\"H2O cloud %d node %d listening on port %s\\n    with output file %s\" %\n                              (self.cloud_num, self.node_num, self.port, self.output_file_name))\n                        return\n            if self.terminated: break\n            retries_left -= 1\n            time.sleep(1)\n\n        if self.terminated: return\n        print(\"\\nERROR: Too many retries starting cloud %d.\\nCheck the output log %s.\\n\" %\n              (self.cloud_num, self.output_file_name))\n        sys.exit(1)", "language": "python", "code": "def scrape_port_from_stdout(self):\n        regex = re.compile(r\"Open H2O Flow in your web browser: https?://([^:]+):(\\d+)\")\n        retries_left = 30\n        while retries_left and not self.terminated:\n            with open(self.output_file_name, \"r\") as f:\n                for line in f:\n                    mm = re.search(regex, line)\n                    if mm is not None:\n                        self.port = mm.group(2)\n                        print(\"H2O cloud %d node %d listening on port %s\\n    with output file %s\" %\n                              (self.cloud_num, self.node_num, self.port, self.output_file_name))\n                        return\n            if self.terminated: break\n            retries_left -= 1\n            time.sleep(1)\n\n        if self.terminated: return\n        print(\"\\nERROR: Too many retries starting cloud %d.\\nCheck the output log %s.\\n\" %\n              (self.cloud_num, self.output_file_name))\n        sys.exit(1)", "code_tokens": ["def", "scrape_port_from_stdout", "(", "self", ")", ":", "regex", "=", "re", ".", "compile", "(", "r\"Open H2O Flow in your web browser: https?://([^:]+):(\\d+)\"", ")", "retries_left", "=", "30", "while", "retries_left", "and", "not", "self", ".", "terminated", ":", "with", "open", "(", "self", ".", "output_file_name", ",", "\"r\"", ")", "as", "f", ":", "for", "line", "in", "f", ":", "mm", "=", "re", ".", "search", "(", "regex", ",", "line", ")", "if", "mm", "is", "not", "None", ":", "self", ".", "port", "=", "mm", ".", "group", "(", "2", ")", "print", "(", "\"H2O cloud %d node %d listening on port %s\\n    with output file %s\"", "%", "(", "self", ".", "cloud_num", ",", "self", ".", "node_num", ",", "self", ".", "port", ",", "self", ".", "output_file_name", ")", ")", "return", "if", "self", ".", "terminated", ":", "break", "retries_left", "-=", "1", "time", ".", "sleep", "(", "1", ")", "if", "self", ".", "terminated", ":", "return", "print", "(", "\"\\nERROR: Too many retries starting cloud %d.\\nCheck the output log %s.\\n\"", "%", "(", "self", ".", "cloud_num", ",", "self", ".", "output_file_name", ")", ")", "sys", ".", "exit", "(", "1", ")"], "docstring": "Look at the stdout log and figure out which port the JVM chose.", "docstring_tokens": ["Look", "at", "the", "stdout", "log", "and", "figure", "out", "which", "port", "the", "JVM", "chose", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/scripts/run.py#L418-L444", "partition": "test", "index": 1352, "time": "2015-02-28 13:24:03"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/estimators/stackedensemble.py", "func_name": "H2OStackedEnsembleEstimator.metalearner_params", "original_string": "def metalearner_params(self):\n        \"\"\"\n        Parameters for metalearner algorithm\n\n        Type: ``dict``  (default: ``None``).\n        Example: metalearner_gbm_params = {'max_depth': 2, 'col_sample_rate': 0.3}\n        \"\"\"\n        if self._parms.get(\"metalearner_params\") != None:\n            metalearner_params_dict =  ast.literal_eval(self._parms.get(\"metalearner_params\"))\n            for k in metalearner_params_dict:\n                if len(metalearner_params_dict[k]) == 1: #single parameter\n                    metalearner_params_dict[k] = metalearner_params_dict[k][0]\n            return metalearner_params_dict\n        else:\n            return self._parms.get(\"metalearner_params\")", "language": "python", "code": "def metalearner_params(self):\n        if self._parms.get(\"metalearner_params\") != None:\n            metalearner_params_dict =  ast.literal_eval(self._parms.get(\"metalearner_params\"))\n            for k in metalearner_params_dict:\n                if len(metalearner_params_dict[k]) == 1: #single parameter\n                    metalearner_params_dict[k] = metalearner_params_dict[k][0]\n            return metalearner_params_dict\n        else:\n            return self._parms.get(\"metalearner_params\")", "code_tokens": ["def", "metalearner_params", "(", "self", ")", ":", "if", "self", ".", "_parms", ".", "get", "(", "\"metalearner_params\"", ")", "!=", "None", ":", "metalearner_params_dict", "=", "ast", ".", "literal_eval", "(", "self", ".", "_parms", ".", "get", "(", "\"metalearner_params\"", ")", ")", "for", "k", "in", "metalearner_params_dict", ":", "if", "len", "(", "metalearner_params_dict", "[", "k", "]", ")", "==", "1", ":", "#single parameter", "metalearner_params_dict", "[", "k", "]", "=", "metalearner_params_dict", "[", "k", "]", "[", "0", "]", "return", "metalearner_params_dict", "else", ":", "return", "self", ".", "_parms", ".", "get", "(", "\"metalearner_params\"", ")"], "docstring": "Parameters for metalearner algorithm", "docstring_tokens": ["Parameters", "for", "metalearner", "algorithm"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/estimators/stackedensemble.py#L216-L230", "partition": "test", "index": 1325, "time": "2018-02-01 16:33:18"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/frame.py", "func_name": "H2OFrame.rename", "original_string": "def rename(self, columns=None):\n        \"\"\"\n        Change names of columns in the frame.\n\n        Dict key is an index or name of the column whose name is to be set.\n        Dict value is the new name of the column.\n\n        :param columns: dict-like transformations to apply to the column names\n        \"\"\"\n        assert_is_type(columns, None, dict)\n        new_names = self.names\n        ncols = self.ncols\n\n        for col, name in columns.items():\n            col_index = None\n            if is_type(col, int) and (-ncols <= col < ncols):\n                col_index = (col + ncols) % ncols  # handle negative indices\n            elif is_type(col, str) and col in self.names:\n                col_index = self.names.index(col)  # lookup the name\n\n            if col_index is not None:\n                new_names[col_index] = name\n\n        return self.set_names(new_names)", "language": "python", "code": "def rename(self, columns=None):\n        assert_is_type(columns, None, dict)\n        new_names = self.names\n        ncols = self.ncols\n\n        for col, name in columns.items():\n            col_index = None\n            if is_type(col, int) and (-ncols <= col < ncols):\n                col_index = (col + ncols) % ncols  # handle negative indices\n            elif is_type(col, str) and col in self.names:\n                col_index = self.names.index(col)  # lookup the name\n\n            if col_index is not None:\n                new_names[col_index] = name\n\n        return self.set_names(new_names)", "code_tokens": ["def", "rename", "(", "self", ",", "columns", "=", "None", ")", ":", "assert_is_type", "(", "columns", ",", "None", ",", "dict", ")", "new_names", "=", "self", ".", "names", "ncols", "=", "self", ".", "ncols", "for", "col", ",", "name", "in", "columns", ".", "items", "(", ")", ":", "col_index", "=", "None", "if", "is_type", "(", "col", ",", "int", ")", "and", "(", "-", "ncols", "<=", "col", "<", "ncols", ")", ":", "col_index", "=", "(", "col", "+", "ncols", ")", "%", "ncols", "# handle negative indices", "elif", "is_type", "(", "col", ",", "str", ")", "and", "col", "in", "self", ".", "names", ":", "col_index", "=", "self", ".", "names", ".", "index", "(", "col", ")", "# lookup the name", "if", "col_index", "is", "not", "None", ":", "new_names", "[", "col_index", "]", "=", "name", "return", "self", ".", "set_names", "(", "new_names", ")"], "docstring": "Change names of columns in the frame.", "docstring_tokens": ["Change", "names", "of", "columns", "in", "the", "frame", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/frame.py#L1035-L1058", "partition": "test", "index": 1400, "time": "2018-02-23 19:01:14"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/automl/autoh2o.py", "func_name": "H2OAutoML.download_pojo", "original_string": "def download_pojo(self, path=\"\", get_genmodel_jar=False, genmodel_name=\"\"):\n        \"\"\"\n        Download the POJO for the leader model in AutoML to the directory specified by path.\n\n        If path is an empty string, then dump the output to screen.\n\n        :param path:  An absolute path to the directory where POJO should be saved.\n        :param get_genmodel_jar: if True, then also download h2o-genmodel.jar and store it in folder ``path``.\n        :param genmodel_name Custom name of genmodel jar\n        :returns: name of the POJO file written.\n        \"\"\"\n\n        return h2o.download_pojo(self.leader, path, get_jar=get_genmodel_jar, jar_name=genmodel_name)", "language": "python", "code": "def download_pojo(self, path=\"\", get_genmodel_jar=False, genmodel_name=\"\"):\n        return h2o.download_pojo(self.leader, path, get_jar=get_genmodel_jar, jar_name=genmodel_name)", "code_tokens": ["def", "download_pojo", "(", "self", ",", "path", "=", "\"\"", ",", "get_genmodel_jar", "=", "False", ",", "genmodel_name", "=", "\"\"", ")", ":", "return", "h2o", ".", "download_pojo", "(", "self", ".", "leader", ",", "path", ",", "get_jar", "=", "get_genmodel_jar", ",", "jar_name", "=", "genmodel_name", ")"], "docstring": "Download the POJO for the leader model in AutoML to the directory specified by path.", "docstring_tokens": ["Download", "the", "POJO", "for", "the", "leader", "model", "in", "AutoML", "to", "the", "directory", "specified", "by", "path", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/automl/autoh2o.py#L443-L455", "partition": "test", "index": 1509, "time": "2018-04-11 17:35:20"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/h2o.py", "func_name": "get_frame", "original_string": "def get_frame(frame_id, **kwargs):\n    \"\"\"\n    Obtain a handle to the frame in H2O with the frame_id key.\n\n    :param str frame_id: id of the frame to retrieve.\n    :returns: an :class:`H2OFrame` object\n    \"\"\"\n    assert_is_type(frame_id, str)\n    return H2OFrame.get_frame(frame_id, **kwargs)", "language": "python", "code": "def get_frame(frame_id, **kwargs):\n    assert_is_type(frame_id, str)\n    return H2OFrame.get_frame(frame_id, **kwargs)", "code_tokens": ["def", "get_frame", "(", "frame_id", ",", "*", "*", "kwargs", ")", ":", "assert_is_type", "(", "frame_id", ",", "str", ")", "return", "H2OFrame", ".", "get_frame", "(", "frame_id", ",", "*", "*", "kwargs", ")"], "docstring": "Obtain a handle to the frame in H2O with the frame_id key.", "docstring_tokens": ["Obtain", "a", "handle", "to", "the", "frame", "in", "H2O", "with", "the", "frame_id", "key", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/h2o.py#L858-L866", "partition": "test", "index": 1465, "time": "2015-11-02 13:05:01"}
{"repo": "h2oai/h2o-3", "path": "h2o-docs/src/product/sphinxext/apigen.py", "func_name": "ApiDocWriter._path2uri", "original_string": "def _path2uri(self, dirpath):\n        ''' Convert directory path to uri '''\n        relpath = dirpath.replace(self.root_path, self.package_name)\n        if relpath.startswith(os.path.sep):\n            relpath = relpath[1:]\n        return relpath.replace(os.path.sep, '.')", "language": "python", "code": "def _path2uri(self, dirpath):\n        ''' Convert directory path to uri '''\n        relpath = dirpath.replace(self.root_path, self.package_name)\n        if relpath.startswith(os.path.sep):\n            relpath = relpath[1:]\n        return relpath.replace(os.path.sep, '.')", "code_tokens": ["def", "_path2uri", "(", "self", ",", "dirpath", ")", ":", "relpath", "=", "dirpath", ".", "replace", "(", "self", ".", "root_path", ",", "self", ".", "package_name", ")", "if", "relpath", ".", "startswith", "(", "os", ".", "path", ".", "sep", ")", ":", "relpath", "=", "relpath", "[", "1", ":", "]", "return", "relpath", ".", "replace", "(", "os", ".", "path", ".", "sep", ",", "'.'", ")"], "docstring": "Convert directory path to uri", "docstring_tokens": ["Convert", "directory", "path", "to", "uri"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-docs/src/product/sphinxext/apigen.py#L154-L159", "partition": "test", "index": 1558, "time": "2016-05-04 08:57:54"}
{"repo": "h2oai/h2o-3", "path": "h2o-bindings/bin/bindings.py", "func_name": "endpoint_groups", "original_string": "def endpoint_groups():\n    \"\"\"Return endpoints, grouped by the class which handles them.\"\"\"\n    groups = defaultdict(list)\n    for e in endpoints():\n        groups[e[\"class_name\"]].append(e)\n    return groups", "language": "python", "code": "def endpoint_groups():\n    groups = defaultdict(list)\n    for e in endpoints():\n        groups[e[\"class_name\"]].append(e)\n    return groups", "code_tokens": ["def", "endpoint_groups", "(", ")", ":", "groups", "=", "defaultdict", "(", "list", ")", "for", "e", "in", "endpoints", "(", ")", ":", "groups", "[", "e", "[", "\"class_name\"", "]", "]", ".", "append", "(", "e", ")", "return", "groups"], "docstring": "Return endpoints, grouped by the class which handles them.", "docstring_tokens": ["Return", "endpoints", "grouped", "by", "the", "class", "which", "handles", "them", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-bindings/bin/bindings.py#L298-L303", "partition": "test", "index": 1583, "time": "2016-05-31 16:19:02"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/grid/grid_search.py", "func_name": "H2OGridSearch.join", "original_string": "def join(self):\n        \"\"\"Wait until grid finishes computing.\"\"\"\n        self._future = False\n        self._job.poll()\n        self._job = None", "language": "python", "code": "def join(self):\n        self._future = False\n        self._job.poll()\n        self._job = None", "code_tokens": ["def", "join", "(", "self", ")", ":", "self", ".", "_future", "=", "False", "self", ".", "_job", ".", "poll", "(", ")", "self", ".", "_job", "=", "None"], "docstring": "Wait until grid finishes computing.", "docstring_tokens": ["Wait", "until", "grid", "finishes", "computing", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/grid/grid_search.py#L147-L151", "partition": "test", "index": 1483, "time": "2016-07-21 16:43:26"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/two_dim_table.py", "func_name": "H2OTwoDimTable.as_data_frame", "original_string": "def as_data_frame(self):\n        \"\"\"Convert to a python 'data frame'.\"\"\"\n        if can_use_pandas():\n            import pandas\n            pandas.options.display.max_colwidth = 70\n            return pandas.DataFrame(self._cell_values, columns=self._col_header)\n        return self", "language": "python", "code": "def as_data_frame(self):\n        if can_use_pandas():\n            import pandas\n            pandas.options.display.max_colwidth = 70\n            return pandas.DataFrame(self._cell_values, columns=self._col_header)\n        return self", "code_tokens": ["def", "as_data_frame", "(", "self", ")", ":", "if", "can_use_pandas", "(", ")", ":", "import", "pandas", "pandas", ".", "options", ".", "display", ".", "max_colwidth", "=", "70", "return", "pandas", ".", "DataFrame", "(", "self", ".", "_cell_values", ",", "columns", "=", "self", ".", "_col_header", ")", "return", "self"], "docstring": "Convert to a python 'data frame'.", "docstring_tokens": ["Convert", "to", "a", "python", "data", "frame", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/two_dim_table.py#L77-L83", "partition": "test", "index": 1550, "time": "2016-07-21 16:43:26"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/model/clustering.py", "func_name": "H2OClusteringModel.centers", "original_string": "def centers(self):\n        \"\"\"The centers for the KMeans model.\"\"\"\n        o = self._model_json[\"output\"]\n        cvals = o[\"centers\"].cell_values\n        centers = [list(cval[1:]) for cval in cvals]\n        return centers", "language": "python", "code": "def centers(self):\n        o = self._model_json[\"output\"]\n        cvals = o[\"centers\"].cell_values\n        centers = [list(cval[1:]) for cval in cvals]\n        return centers", "code_tokens": ["def", "centers", "(", "self", ")", ":", "o", "=", "self", ".", "_model_json", "[", "\"output\"", "]", "cvals", "=", "o", "[", "\"centers\"", "]", ".", "cell_values", "centers", "=", "[", "list", "(", "cval", "[", "1", ":", "]", ")", "for", "cval", "in", "cvals", "]", "return", "centers"], "docstring": "The centers for the KMeans model.", "docstring_tokens": ["The", "centers", "for", "the", "KMeans", "model", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/model/clustering.py#L143-L148", "partition": "test", "index": 1450, "time": "2016-07-21 16:43:26"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/frame.py", "func_name": "H2OFrame.nlevels", "original_string": "def nlevels(self):\n        \"\"\"\n        Get the number of factor levels for each categorical column.\n\n        :returns: A list of the number of levels per column.\n        \"\"\"\n        levels = self.levels()\n        return [len(l) for l in levels] if levels else 0", "language": "python", "code": "def nlevels(self):\n        levels = self.levels()\n        return [len(l) for l in levels] if levels else 0", "code_tokens": ["def", "nlevels", "(", "self", ")", ":", "levels", "=", "self", ".", "levels", "(", ")", "return", "[", "len", "(", "l", ")", "for", "l", "in", "levels", "]", "if", "levels", "else", "0"], "docstring": "Get the number of factor levels for each categorical column.", "docstring_tokens": ["Get", "the", "number", "of", "factor", "levels", "for", "each", "categorical", "column", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/frame.py#L1000-L1007", "partition": "test", "index": 1397, "time": "2016-07-21 16:43:26"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/backend/cluster.py", "func_name": "H2OCluster.list_timezones", "original_string": "def list_timezones(self):\n        \"\"\"Return the list of all known timezones.\"\"\"\n        from h2o.expr import ExprNode\n        return h2o.H2OFrame._expr(expr=ExprNode(\"listTimeZones\"))._frame()", "language": "python", "code": "def list_timezones(self):\n        from h2o.expr import ExprNode\n        return h2o.H2OFrame._expr(expr=ExprNode(\"listTimeZones\"))._frame()", "code_tokens": ["def", "list_timezones", "(", "self", ")", ":", "from", "h2o", ".", "expr", "import", "ExprNode", "return", "h2o", ".", "H2OFrame", ".", "_expr", "(", "expr", "=", "ExprNode", "(", "\"listTimeZones\"", ")", ")", ".", "_frame", "(", ")"], "docstring": "Return the list of all known timezones.", "docstring_tokens": ["Return", "the", "list", "of", "all", "known", "timezones", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/backend/cluster.py#L303-L306", "partition": "test", "index": 1323, "time": "2016-08-04 12:08:14"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/utils/typechecks.py", "func_name": "NOT.check", "original_string": "def check(self, var):\n        \"\"\"Return True if the variable does not match any of the types, and False otherwise.\"\"\"\n        return not any(_check_type(var, tt) for tt in self._types)", "language": "python", "code": "def check(self, var):\n        return not any(_check_type(var, tt) for tt in self._types)", "code_tokens": ["def", "check", "(", "self", ",", "var", ")", ":", "return", "not", "any", "(", "_check_type", "(", "var", ",", "tt", ")", "for", "tt", "in", "self", ".", "_types", ")"], "docstring": "Return True if the variable does not match any of the types, and False otherwise.", "docstring_tokens": ["Return", "True", "if", "the", "variable", "does", "not", "match", "any", "of", "the", "types", "and", "False", "otherwise", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/utils/typechecks.py#L226-L228", "partition": "test", "index": 1371, "time": "2016-08-15 14:47:11"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/model/model_base.py", "func_name": "ModelBase.default_params", "original_string": "def default_params(self):\n        \"\"\"Dictionary of the default parameters of the model.\"\"\"\n        params = {}\n        for p in self.parms:\n            params[p] = self.parms[p][\"default_value\"]\n        return params", "language": "python", "code": "def default_params(self):\n        params = {}\n        for p in self.parms:\n            params[p] = self.parms[p][\"default_value\"]\n        return params", "code_tokens": ["def", "default_params", "(", "self", ")", ":", "params", "=", "{", "}", "for", "p", "in", "self", ".", "parms", ":", "params", "[", "p", "]", "=", "self", ".", "parms", "[", "p", "]", "[", "\"default_value\"", "]", "return", "params"], "docstring": "Dictionary of the default parameters of the model.", "docstring_tokens": ["Dictionary", "of", "the", "default", "parameters", "of", "the", "model", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/model/model_base.py#L68-L73", "partition": "test", "index": 1533, "time": "2016-08-19 17:11:24"}
{"repo": "h2oai/h2o-3", "path": "h2o-bindings/bin/pyparser.py", "func_name": "ParsedBase.unparse", "original_string": "def unparse(self):\n        \"\"\"Convert the parsed representation back into the source code.\"\"\"\n        ut = Untokenizer(start_row=self._tokens[0].start_row)\n        self._unparse(ut)\n        return ut.result()", "language": "python", "code": "def unparse(self):\n        ut = Untokenizer(start_row=self._tokens[0].start_row)\n        self._unparse(ut)\n        return ut.result()", "code_tokens": ["def", "unparse", "(", "self", ")", ":", "ut", "=", "Untokenizer", "(", "start_row", "=", "self", ".", "_tokens", "[", "0", "]", ".", "start_row", ")", "self", ".", "_unparse", "(", "ut", ")", "return", "ut", ".", "result", "(", ")"], "docstring": "Convert the parsed representation back into the source code.", "docstring_tokens": ["Convert", "the", "parsed", "representation", "back", "into", "the", "source", "code", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-bindings/bin/pyparser.py#L365-L369", "partition": "test", "index": 1448, "time": "2016-08-24 15:16:21"}
{"repo": "h2oai/h2o-3", "path": "h2o-bindings/bin/pyparser.py", "func_name": "Token.move", "original_string": "def move(self, drow, dcol=0):\n        \"\"\"Move the token by `drow` rows and `dcol` columns.\"\"\"\n        self._start_row += drow\n        self._start_col += dcol\n        self._end_row += drow\n        self._end_col += dcol", "language": "python", "code": "def move(self, drow, dcol=0):\n        self._start_row += drow\n        self._start_col += dcol\n        self._end_row += drow\n        self._end_col += dcol", "code_tokens": ["def", "move", "(", "self", ",", "drow", ",", "dcol", "=", "0", ")", ":", "self", ".", "_start_row", "+=", "drow", "self", ".", "_start_col", "+=", "dcol", "self", ".", "_end_row", "+=", "drow", "self", ".", "_end_col", "+=", "dcol"], "docstring": "Move the token by `drow` rows and `dcol` columns.", "docstring_tokens": ["Move", "the", "token", "by", "drow", "rows", "and", "dcol", "columns", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-bindings/bin/pyparser.py#L246-L251", "partition": "test", "index": 1447, "time": "2016-08-24 15:16:21"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/utils/typechecks.py", "func_name": "Enum.check", "original_string": "def check(self, var):\n        \"\"\"Check whether the provided value is a valid enum constant.\"\"\"\n        if not isinstance(var, _str_type): return False\n        return _enum_mangle(var) in self._consts", "language": "python", "code": "def check(self, var):\n        if not isinstance(var, _str_type): return False\n        return _enum_mangle(var) in self._consts", "code_tokens": ["def", "check", "(", "self", ",", "var", ")", ":", "if", "not", "isinstance", "(", "var", ",", "_str_type", ")", ":", "return", "False", "return", "_enum_mangle", "(", "var", ")", "in", "self", ".", "_consts"], "docstring": "Check whether the provided value is a valid enum constant.", "docstring_tokens": ["Check", "whether", "the", "provided", "value", "is", "a", "valid", "enum", "constant", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/utils/typechecks.py#L403-L406", "partition": "test", "index": 1372, "time": "2016-09-16 17:25:35"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/utils/config.py", "func_name": "H2OConfigReader.get_config", "original_string": "def get_config():\n        \"\"\"Retrieve the config as a dictionary of key-value pairs.\"\"\"\n        self = H2OConfigReader._get_instance()\n        if not self._config_loaded:\n            self._read_config()\n        return self._config", "language": "python", "code": "def get_config():\n        self = H2OConfigReader._get_instance()\n        if not self._config_loaded:\n            self._read_config()\n        return self._config", "code_tokens": ["def", "get_config", "(", ")", ":", "self", "=", "H2OConfigReader", ".", "_get_instance", "(", ")", "if", "not", "self", ".", "_config_loaded", ":", "self", ".", "_read_config", "(", ")", "return", "self", ".", "_config"], "docstring": "Retrieve the config as a dictionary of key-value pairs.", "docstring_tokens": ["Retrieve", "the", "config", "as", "a", "dictionary", "of", "key", "-", "value", "pairs", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/utils/config.py#L24-L29", "partition": "test", "index": 1373, "time": "2016-09-27 12:18:26"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/utils/shared_utils.py", "func_name": "slice_is_normalized", "original_string": "def slice_is_normalized(s):\n    \"\"\"Return True if slice ``s`` in \"normalized\" form.\"\"\"\n    return (s.start is not None and s.stop is not None and s.step is not None and s.start <= s.stop)", "language": "python", "code": "def slice_is_normalized(s):\n    return (s.start is not None and s.stop is not None and s.step is not None and s.start <= s.stop)", "code_tokens": ["def", "slice_is_normalized", "(", "s", ")", ":", "return", "(", "s", ".", "start", "is", "not", "None", "and", "s", ".", "stop", "is", "not", "None", "and", "s", ".", "step", "is", "not", "None", "and", "s", ".", "start", "<=", "s", ".", "stop", ")"], "docstring": "Return True if slice ``s`` in \"normalized\" form.", "docstring_tokens": ["Return", "True", "if", "slice", "s", "in", "normalized", "form", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/utils/shared_utils.py#L355-L357", "partition": "test", "index": 1479, "time": "2016-11-04 17:39:23"}
{"repo": "h2oai/h2o-3", "path": "py2/ec2_cmd.py", "func_name": "terminate_instances", "original_string": "def terminate_instances(instances, region):\n    '''terminate all the instances given by its ids'''\n    if not instances: return\n    conn = ec2_connect(region)\n    log(\"Terminating instances {0}.\".format(instances))\n    conn.terminate_instances(instances)\n    log(\"Done\")", "language": "python", "code": "def terminate_instances(instances, region):\n    if not instances: return\n    conn = ec2_connect(region)\n    log(\"Terminating instances {0}.\".format(instances))\n    conn.terminate_instances(instances)\n    log(\"Done\")", "code_tokens": ["def", "terminate_instances", "(", "instances", ",", "region", ")", ":", "if", "not", "instances", ":", "return", "conn", "=", "ec2_connect", "(", "region", ")", "log", "(", "\"Terminating instances {0}.\"", ".", "format", "(", "instances", ")", ")", "conn", ".", "terminate_instances", "(", "instances", ")", "log", "(", "\"Done\"", ")"], "docstring": "terminate all the instances given by its ids", "docstring_tokens": ["terminate", "all", "the", "instances", "given", "by", "its", "ids"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/py2/ec2_cmd.py#L200-L206", "partition": "test", "index": 1336, "time": "2014-11-11 18:26:15"}
{"repo": "h2oai/h2o-3", "path": "py2/ec2_cmd.py", "func_name": "reboot_instances", "original_string": "def reboot_instances(instances, region):\n    '''Reboot all the instances given by its ids'''\n    if not instances: return\n    conn = ec2_connect(region)\n    log(\"Rebooting instances {0}.\".format(instances))\n    conn.reboot_instances(instances)\n    log(\"Done\")", "language": "python", "code": "def reboot_instances(instances, region):\n    if not instances: return\n    conn = ec2_connect(region)\n    log(\"Rebooting instances {0}.\".format(instances))\n    conn.reboot_instances(instances)\n    log(\"Done\")", "code_tokens": ["def", "reboot_instances", "(", "instances", ",", "region", ")", ":", "if", "not", "instances", ":", "return", "conn", "=", "ec2_connect", "(", "region", ")", "log", "(", "\"Rebooting instances {0}.\"", ".", "format", "(", "instances", ")", ")", "conn", ".", "reboot_instances", "(", "instances", ")", "log", "(", "\"Done\"", ")"], "docstring": "Reboot all the instances given by its ids", "docstring_tokens": ["Reboot", "all", "the", "instances", "given", "by", "its", "ids"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/py2/ec2_cmd.py#L224-L230", "partition": "test", "index": 1339, "time": "2014-11-11 18:26:15"}
{"repo": "h2oai/h2o-3", "path": "h2o-bindings/bin/gen_java.py", "func_name": "dedent", "original_string": "def dedent(ind, text):\n    \"\"\"\n    Dedent text to the specific indentation level.\n\n    :param ind: common indentation level for the resulting text (number of spaces to append to every line)\n    :param text: text that should be transformed.\n    :return: ``text`` with all common indentation removed, and then the specified amount of indentation added.\n    \"\"\"\n    text2 = textwrap.dedent(text)\n    if ind == 0:\n        return text2\n    indent_str = \" \" * ind\n    return \"\\n\".join(indent_str + line for line in text2.split(\"\\n\"))", "language": "python", "code": "def dedent(ind, text):\n    text2 = textwrap.dedent(text)\n    if ind == 0:\n        return text2\n    indent_str = \" \" * ind\n    return \"\\n\".join(indent_str + line for line in text2.split(\"\\n\"))", "code_tokens": ["def", "dedent", "(", "ind", ",", "text", ")", ":", "text2", "=", "textwrap", ".", "dedent", "(", "text", ")", "if", "ind", "==", "0", ":", "return", "text2", "indent_str", "=", "\" \"", "*", "ind", "return", "\"\\n\"", ".", "join", "(", "indent_str", "+", "line", "for", "line", "in", "text2", ".", "split", "(", "\"\\n\"", ")", ")"], "docstring": "Dedent text to the specific indentation level.", "docstring_tokens": ["Dedent", "text", "to", "the", "specific", "indentation", "level", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-bindings/bin/gen_java.py#L71-L83", "partition": "test", "index": 1495, "time": "2016-10-14 15:53:43"}
{"repo": "h2oai/h2o-3", "path": "scripts/extractGLRMRuntimeJavaLog.py", "func_name": "main", "original_string": "def main(argv):\n    \"\"\"\n    Main program.  Take user input, parse it and call other functions to execute the commands\n    and extract run summary and store run result in json file\n\n    @return: none\n    \"\"\"\n    global g_test_root_dir\n    global g_temp_filename\n\n    if len(argv) < 2:\n        print(\"invoke this script as python extractGLRMRuntimeJavaLog.py javatextlog.\\n\")\n        sys.exit(1)\n    else:   # we may be in business\n        javaLogText = argv[1]         # filename while java log is stored\n\n        print(\"your java text is {0}\".format(javaLogText))\n        extractRunInto(javaLogText)", "language": "python", "code": "def main(argv):\n    global g_test_root_dir\n    global g_temp_filename\n\n    if len(argv) < 2:\n        print(\"invoke this script as python extractGLRMRuntimeJavaLog.py javatextlog.\\n\")\n        sys.exit(1)\n    else:   # we may be in business\n        javaLogText = argv[1]         # filename while java log is stored\n\n        print(\"your java text is {0}\".format(javaLogText))\n        extractRunInto(javaLogText)", "code_tokens": ["def", "main", "(", "argv", ")", ":", "global", "g_test_root_dir", "global", "g_temp_filename", "if", "len", "(", "argv", ")", "<", "2", ":", "print", "(", "\"invoke this script as python extractGLRMRuntimeJavaLog.py javatextlog.\\n\"", ")", "sys", ".", "exit", "(", "1", ")", "else", ":", "# we may be in business", "javaLogText", "=", "argv", "[", "1", "]", "# filename while java log is stored", "print", "(", "\"your java text is {0}\"", ".", "format", "(", "javaLogText", ")", ")", "extractRunInto", "(", "javaLogText", ")"], "docstring": "Main program.  Take user input, parse it and call other functions to execute the commands\n    and extract run summary and store run result in json file", "docstring_tokens": ["Main", "program", ".", "Take", "user", "input", "parse", "it", "and", "call", "other", "functions", "to", "execute", "the", "commands", "and", "extract", "run", "summary", "and", "store", "run", "result", "in", "json", "file"], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/scripts/extractGLRMRuntimeJavaLog.py#L115-L132", "partition": "test", "index": 1497, "time": "2016-10-18 16:23:53"}
{"repo": "h2oai/h2o-3", "path": "scripts/extractGLRMRuntimeJavaLog.py", "func_name": "extractRunInto", "original_string": "def extractRunInto(javaLogText):\n    \"\"\"\n    This function will extract the various operation time for GLRM model building iterations.\n\n    :param javaLogText:\n    :return:\n    \"\"\"\n    global g_initialXY\n    global g_reguarlize_Y\n    global g_regularize_X_objective\n    global g_updateX\n    global g_updateY\n    global g_objective\n    global g_stepsize\n    global g_history\n\n\n    if os.path.isfile(javaLogText):\n\n        run_result = dict()\n        run_result[\"total time (ms)\"] = []\n        run_result[\"initialXY (ms)\"] = []\n        run_result[\"regularize Y (ms)\"] = []\n        run_result[\"regularize X and objective (ms)\"] = []\n        run_result[\"update X (ms)\"] = []\n        run_result[\"update Y (ms)\"] = []\n        run_result[\"objective (ms)\"] = []\n        run_result[\"step size (ms)\"] = []\n        run_result[\"update history (ms)\"] = []\n\n        total_run_time = -1\n        val = 0.0\n        with open(javaLogText, 'r') as thefile:   # go into tempfile and grab test run info\n            for each_line in thefile:\n                temp_string = each_line.split()\n\n                if len(temp_string) > 0:\n                    val = temp_string[-1].replace('\\\\','')\n\n                if g_initialXY in each_line:    # start of a new file\n                    if total_run_time > 0:  # update total run time\n                        run_result[\"total time (ms)\"].append(total_run_time)\n                        total_run_time = 0.0\n                    else:\n                        total_run_time = 0.0\n\n                    run_result[\"initialXY (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_reguarlize_Y in each_line:\n                    run_result[\"regularize Y (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_regularize_X_objective in each_line:\n                    run_result[\"regularize X and objective (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_updateX in each_line:\n                    run_result[\"update X (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_updateY in each_line:\n                    run_result[\"update Y (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_objective in each_line:\n                    run_result[\"objective (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_stepsize in each_line:\n                    run_result[\"step size (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_history in each_line:\n                    run_result[\"update history (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n        run_result[\"total time (ms)\"].append(total_run_time)    # save the last one\n        print(\"Run result summary: \\n {0}\".format(run_result))\n\n    else:\n        print(\"Cannot find your java log file.  Nothing is done.\\n\")", "language": "python", "code": "def extractRunInto(javaLogText):\n    global g_initialXY\n    global g_reguarlize_Y\n    global g_regularize_X_objective\n    global g_updateX\n    global g_updateY\n    global g_objective\n    global g_stepsize\n    global g_history\n\n\n    if os.path.isfile(javaLogText):\n\n        run_result = dict()\n        run_result[\"total time (ms)\"] = []\n        run_result[\"initialXY (ms)\"] = []\n        run_result[\"regularize Y (ms)\"] = []\n        run_result[\"regularize X and objective (ms)\"] = []\n        run_result[\"update X (ms)\"] = []\n        run_result[\"update Y (ms)\"] = []\n        run_result[\"objective (ms)\"] = []\n        run_result[\"step size (ms)\"] = []\n        run_result[\"update history (ms)\"] = []\n\n        total_run_time = -1\n        val = 0.0\n        with open(javaLogText, 'r') as thefile:   # go into tempfile and grab test run info\n            for each_line in thefile:\n                temp_string = each_line.split()\n\n                if len(temp_string) > 0:\n                    val = temp_string[-1].replace('\\\\','')\n\n                if g_initialXY in each_line:    # start of a new file\n                    if total_run_time > 0:  # update total run time\n                        run_result[\"total time (ms)\"].append(total_run_time)\n                        total_run_time = 0.0\n                    else:\n                        total_run_time = 0.0\n\n                    run_result[\"initialXY (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_reguarlize_Y in each_line:\n                    run_result[\"regularize Y (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_regularize_X_objective in each_line:\n                    run_result[\"regularize X and objective (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_updateX in each_line:\n                    run_result[\"update X (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_updateY in each_line:\n                    run_result[\"update Y (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_objective in each_line:\n                    run_result[\"objective (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_stepsize in each_line:\n                    run_result[\"step size (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n                if g_history in each_line:\n                    run_result[\"update history (ms)\"].append(float(val))\n                    total_run_time = total_run_time+float(val)\n\n        run_result[\"total time (ms)\"].append(total_run_time)    # save the last one\n        print(\"Run result summary: \\n {0}\".format(run_result))\n\n    else:\n        print(\"Cannot find your java log file.  Nothing is done.\\n\")", "code_tokens": ["def", "extractRunInto", "(", "javaLogText", ")", ":", "global", "g_initialXY", "global", "g_reguarlize_Y", "global", "g_regularize_X_objective", "global", "g_updateX", "global", "g_updateY", "global", "g_objective", "global", "g_stepsize", "global", "g_history", "if", "os", ".", "path", ".", "isfile", "(", "javaLogText", ")", ":", "run_result", "=", "dict", "(", ")", "run_result", "[", "\"total time (ms)\"", "]", "=", "[", "]", "run_result", "[", "\"initialXY (ms)\"", "]", "=", "[", "]", "run_result", "[", "\"regularize Y (ms)\"", "]", "=", "[", "]", "run_result", "[", "\"regularize X and objective (ms)\"", "]", "=", "[", "]", "run_result", "[", "\"update X (ms)\"", "]", "=", "[", "]", "run_result", "[", "\"update Y (ms)\"", "]", "=", "[", "]", "run_result", "[", "\"objective (ms)\"", "]", "=", "[", "]", "run_result", "[", "\"step size (ms)\"", "]", "=", "[", "]", "run_result", "[", "\"update history (ms)\"", "]", "=", "[", "]", "total_run_time", "=", "-", "1", "val", "=", "0.0", "with", "open", "(", "javaLogText", ",", "'r'", ")", "as", "thefile", ":", "# go into tempfile and grab test run info", "for", "each_line", "in", "thefile", ":", "temp_string", "=", "each_line", ".", "split", "(", ")", "if", "len", "(", "temp_string", ")", ">", "0", ":", "val", "=", "temp_string", "[", "-", "1", "]", ".", "replace", "(", "'\\\\'", ",", "''", ")", "if", "g_initialXY", "in", "each_line", ":", "# start of a new file", "if", "total_run_time", ">", "0", ":", "# update total run time", "run_result", "[", "\"total time (ms)\"", "]", ".", "append", "(", "total_run_time", ")", "total_run_time", "=", "0.0", "else", ":", "total_run_time", "=", "0.0", "run_result", "[", "\"initialXY (ms)\"", "]", ".", "append", "(", "float", "(", "val", ")", ")", "total_run_time", "=", "total_run_time", "+", "float", "(", "val", ")", "if", "g_reguarlize_Y", "in", "each_line", ":", "run_result", "[", "\"regularize Y (ms)\"", "]", ".", "append", "(", "float", "(", "val", ")", ")", "total_run_time", "=", "total_run_time", "+", "float", "(", "val", ")", "if", "g_regularize_X_objective", "in", "each_line", ":", "run_result", "[", "\"regularize X and objective (ms)\"", "]", ".", "append", "(", "float", "(", "val", ")", ")", "total_run_time", "=", "total_run_time", "+", "float", "(", "val", ")", "if", "g_updateX", "in", "each_line", ":", "run_result", "[", "\"update X (ms)\"", "]", ".", "append", "(", "float", "(", "val", ")", ")", "total_run_time", "=", "total_run_time", "+", "float", "(", "val", ")", "if", "g_updateY", "in", "each_line", ":", "run_result", "[", "\"update Y (ms)\"", "]", ".", "append", "(", "float", "(", "val", ")", ")", "total_run_time", "=", "total_run_time", "+", "float", "(", "val", ")", "if", "g_objective", "in", "each_line", ":", "run_result", "[", "\"objective (ms)\"", "]", ".", "append", "(", "float", "(", "val", ")", ")", "total_run_time", "=", "total_run_time", "+", "float", "(", "val", ")", "if", "g_stepsize", "in", "each_line", ":", "run_result", "[", "\"step size (ms)\"", "]", ".", "append", "(", "float", "(", "val", ")", ")", "total_run_time", "=", "total_run_time", "+", "float", "(", "val", ")", "if", "g_history", "in", "each_line", ":", "run_result", "[", "\"update history (ms)\"", "]", ".", "append", "(", "float", "(", "val", ")", ")", "total_run_time", "=", "total_run_time", "+", "float", "(", "val", ")", "run_result", "[", "\"total time (ms)\"", "]", ".", "append", "(", "total_run_time", ")", "# save the last one", "print", "(", "\"Run result summary: \\n {0}\"", ".", "format", "(", "run_result", ")", ")", "else", ":", "print", "(", "\"Cannot find your java log file.  Nothing is done.\\n\"", ")"], "docstring": "This function will extract the various operation time for GLRM model building iterations.", "docstring_tokens": ["This", "function", "will", "extract", "the", "various", "operation", "time", "for", "GLRM", "model", "building", "iterations", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/scripts/extractGLRMRuntimeJavaLog.py#L31-L112", "partition": "test", "index": 1496, "time": "2016-10-18 16:23:53"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/utils/shared_utils.py", "func_name": "normalize_slice", "original_string": "def normalize_slice(s, total):\n    \"\"\"\n    Return a \"canonical\" version of slice ``s``.\n\n    :param slice s: the original slice expression\n    :param total int: total number of elements in the collection sliced by ``s``\n    :return slice: a slice equivalent to ``s`` but not containing any negative indices or Nones.\n    \"\"\"\n    newstart = 0 if s.start is None else max(0, s.start + total) if s.start < 0 else min(s.start, total)\n    newstop = total if s.stop is None else max(0, s.stop + total) if s.stop < 0 else min(s.stop, total)\n    newstep = 1 if s.step is None else s.step\n    return slice(newstart, newstop, newstep)", "language": "python", "code": "def normalize_slice(s, total):\n    newstart = 0 if s.start is None else max(0, s.start + total) if s.start < 0 else min(s.start, total)\n    newstop = total if s.stop is None else max(0, s.stop + total) if s.stop < 0 else min(s.stop, total)\n    newstep = 1 if s.step is None else s.step\n    return slice(newstart, newstop, newstep)", "code_tokens": ["def", "normalize_slice", "(", "s", ",", "total", ")", ":", "newstart", "=", "0", "if", "s", ".", "start", "is", "None", "else", "max", "(", "0", ",", "s", ".", "start", "+", "total", ")", "if", "s", ".", "start", "<", "0", "else", "min", "(", "s", ".", "start", ",", "total", ")", "newstop", "=", "total", "if", "s", ".", "stop", "is", "None", "else", "max", "(", "0", ",", "s", ".", "stop", "+", "total", ")", "if", "s", ".", "stop", "<", "0", "else", "min", "(", "s", ".", "stop", ",", "total", ")", "newstep", "=", "1", "if", "s", ".", "step", "is", "None", "else", "s", ".", "step", "return", "slice", "(", "newstart", ",", "newstop", ",", "newstep", ")"], "docstring": "Return a \"canonical\" version of slice.", "docstring_tokens": ["Return", "a", "canonical", "version", "of", "slice", "s", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/utils/shared_utils.py#L341-L352", "partition": "test", "index": 1478, "time": "2016-11-04 17:39:23"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/utils/shared_utils.py", "func_name": "check_frame_id", "original_string": "def check_frame_id(frame_id):\n    \"\"\"Check that the provided frame id is valid in Rapids language.\"\"\"\n    if frame_id is None:\n        return\n    if frame_id.strip() == \"\":\n        raise H2OValueError(\"Frame id cannot be an empty string: %r\" % frame_id)\n    for i, ch in enumerate(frame_id):\n        # '$' character has special meaning at the beginning of the string; and prohibited anywhere else\n        if ch == \"$\" and i == 0: continue\n        if ch not in _id_allowed_characters:\n            raise H2OValueError(\"Character '%s' is illegal in frame id: %s\" % (ch, frame_id))\n    if re.match(r\"-?[0-9]\", frame_id):\n        raise H2OValueError(\"Frame id cannot start with a number: %s\" % frame_id)", "language": "python", "code": "def check_frame_id(frame_id):\n    if frame_id is None:\n        return\n    if frame_id.strip() == \"\":\n        raise H2OValueError(\"Frame id cannot be an empty string: %r\" % frame_id)\n    for i, ch in enumerate(frame_id):\n        # '$' character has special meaning at the beginning of the string; and prohibited anywhere else\n        if ch == \"$\" and i == 0: continue\n        if ch not in _id_allowed_characters:\n            raise H2OValueError(\"Character '%s' is illegal in frame id: %s\" % (ch, frame_id))\n    if re.match(r\"-?[0-9]\", frame_id):\n        raise H2OValueError(\"Frame id cannot start with a number: %s\" % frame_id)", "code_tokens": ["def", "check_frame_id", "(", "frame_id", ")", ":", "if", "frame_id", "is", "None", ":", "return", "if", "frame_id", ".", "strip", "(", ")", "==", "\"\"", ":", "raise", "H2OValueError", "(", "\"Frame id cannot be an empty string: %r\"", "%", "frame_id", ")", "for", "i", ",", "ch", "in", "enumerate", "(", "frame_id", ")", ":", "# '$' character has special meaning at the beginning of the string; and prohibited anywhere else", "if", "ch", "==", "\"$\"", "and", "i", "==", "0", ":", "continue", "if", "ch", "not", "in", "_id_allowed_characters", ":", "raise", "H2OValueError", "(", "\"Character '%s' is illegal in frame id: %s\"", "%", "(", "ch", ",", "frame_id", ")", ")", "if", "re", ".", "match", "(", "r\"-?[0-9]\"", ",", "frame_id", ")", ":", "raise", "H2OValueError", "(", "\"Frame id cannot start with a number: %s\"", "%", "frame_id", ")"], "docstring": "Check that the provided frame id is valid in Rapids language.", "docstring_tokens": ["Check", "that", "the", "provided", "frame", "id", "is", "valid", "in", "Rapids", "language", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/utils/shared_utils.py#L46-L58", "partition": "test", "index": 1476, "time": "2016-11-04 19:13:04"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/frame.py", "func_name": "H2OFrame.type", "original_string": "def type(self, col):\n        \"\"\"\n        The type for the given column.\n\n        :param col: either a name, or an index of the column to look up\n        :returns: type of the column, one of: ``str``, ``int``, ``real``, ``enum``, ``time``, ``bool``.\n        :raises H2OValueError: if such column does not exist in the frame.\n        \"\"\"\n        assert_is_type(col, int, str)\n        if not self._ex._cache.types_valid() or not self._ex._cache.names_valid():\n            self._ex._cache.flush()\n            self._frame(fill_cache=True)\n        types = self._ex._cache.types\n        if is_type(col, str):\n            if col in types:\n                return types[col]\n        else:\n            names = self._ex._cache.names\n            if -len(names) <= col < len(names):\n                return types[names[col]]\n        raise H2OValueError(\"Column '%r' does not exist in the frame\" % col)", "language": "python", "code": "def type(self, col):\n        assert_is_type(col, int, str)\n        if not self._ex._cache.types_valid() or not self._ex._cache.names_valid():\n            self._ex._cache.flush()\n            self._frame(fill_cache=True)\n        types = self._ex._cache.types\n        if is_type(col, str):\n            if col in types:\n                return types[col]\n        else:\n            names = self._ex._cache.names\n            if -len(names) <= col < len(names):\n                return types[names[col]]\n        raise H2OValueError(\"Column '%r' does not exist in the frame\" % col)", "code_tokens": ["def", "type", "(", "self", ",", "col", ")", ":", "assert_is_type", "(", "col", ",", "int", ",", "str", ")", "if", "not", "self", ".", "_ex", ".", "_cache", ".", "types_valid", "(", ")", "or", "not", "self", ".", "_ex", ".", "_cache", ".", "names_valid", "(", ")", ":", "self", ".", "_ex", ".", "_cache", ".", "flush", "(", ")", "self", ".", "_frame", "(", "fill_cache", "=", "True", ")", "types", "=", "self", ".", "_ex", ".", "_cache", ".", "types", "if", "is_type", "(", "col", ",", "str", ")", ":", "if", "col", "in", "types", ":", "return", "types", "[", "col", "]", "else", ":", "names", "=", "self", ".", "_ex", ".", "_cache", ".", "names", "if", "-", "len", "(", "names", ")", "<=", "col", "<", "len", "(", "names", ")", ":", "return", "types", "[", "names", "[", "col", "]", "]", "raise", "H2OValueError", "(", "\"Column '%r' does not exist in the frame\"", "%", "col", ")"], "docstring": "The type for the given column.", "docstring_tokens": ["The", "type", "for", "the", "given", "column", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/frame.py#L289-L309", "partition": "test", "index": 1390, "time": "2016-11-23 15:05:04"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/model/word_embedding.py", "func_name": "H2OWordEmbeddingModel.find_synonyms", "original_string": "def find_synonyms(self, word, count=20):\n        \"\"\"\n        Find synonyms using a word2vec model.\n\n        :param str word: A single word to find synonyms for.\n        :param int count: The first \"count\" synonyms will be returned.\n\n        :returns: the approximate reconstruction of the training data.\n        \"\"\"\n        j = h2o.api(\"GET /3/Word2VecSynonyms\", data={'model': self.model_id, 'word': word, 'count': count})\n        return OrderedDict(sorted(zip(j['synonyms'], j['scores']), key=lambda t: t[1], reverse=True))", "language": "python", "code": "def find_synonyms(self, word, count=20):\n        j = h2o.api(\"GET /3/Word2VecSynonyms\", data={'model': self.model_id, 'word': word, 'count': count})\n        return OrderedDict(sorted(zip(j['synonyms'], j['scores']), key=lambda t: t[1], reverse=True))", "code_tokens": ["def", "find_synonyms", "(", "self", ",", "word", ",", "count", "=", "20", ")", ":", "j", "=", "h2o", ".", "api", "(", "\"GET /3/Word2VecSynonyms\"", ",", "data", "=", "{", "'model'", ":", "self", ".", "model_id", ",", "'word'", ":", "word", ",", "'count'", ":", "count", "}", ")", "return", "OrderedDict", "(", "sorted", "(", "zip", "(", "j", "[", "'synonyms'", "]", ",", "j", "[", "'scores'", "]", ")", ",", "key", "=", "lambda", "t", ":", "t", "[", "1", "]", ",", "reverse", "=", "True", ")", ")"], "docstring": "Find synonyms using a word2vec model.", "docstring_tokens": ["Find", "synonyms", "using", "a", "word2vec", "model", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/model/word_embedding.py#L17-L27", "partition": "test", "index": 1528, "time": "2017-01-06 16:37:08"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/frame.py", "func_name": "H2OFrame.minute", "original_string": "def minute(self):\n        \"\"\"\n        Extract the \"minute\" part from a date column.\n\n        :returns: a single-column H2OFrame containing the \"minute\" part from the source frame.\n        \"\"\"\n        fr = H2OFrame._expr(expr=ExprNode(\"minute\", self), cache=self._ex._cache)\n        if fr._ex._cache.types_valid():\n            fr._ex._cache.types = {k: \"int\" for k in self._ex._cache.types.keys()}\n        return fr", "language": "python", "code": "def minute(self):\n        fr = H2OFrame._expr(expr=ExprNode(\"minute\", self), cache=self._ex._cache)\n        if fr._ex._cache.types_valid():\n            fr._ex._cache.types = {k: \"int\" for k in self._ex._cache.types.keys()}\n        return fr", "code_tokens": ["def", "minute", "(", "self", ")", ":", "fr", "=", "H2OFrame", ".", "_expr", "(", "expr", "=", "ExprNode", "(", "\"minute\"", ",", "self", ")", ",", "cache", "=", "self", ".", "_ex", ".", "_cache", ")", "if", "fr", ".", "_ex", ".", "_cache", ".", "types_valid", "(", ")", ":", "fr", ".", "_ex", ".", "_cache", ".", "types", "=", "{", "k", ":", "\"int\"", "for", "k", "in", "self", ".", "_ex", ".", "_cache", ".", "types", ".", "keys", "(", ")", "}", "return", "fr"], "docstring": "Extract the \"minute\" part from a date column.", "docstring_tokens": ["Extract", "the", "minute", "part", "from", "a", "date", "column", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/frame.py#L3143-L3152", "partition": "test", "index": 1439, "time": "2017-01-19 17:45:19"}
{"repo": "h2oai/h2o-3", "path": "h2o-py/h2o/model/model_base.py", "func_name": "ModelBase.save_model_details", "original_string": "def save_model_details(self, path=\"\", force=False):\n        \"\"\"\n        Save Model Details of an H2O Model in JSON Format to disk.\n\n        :param model: The model object to save.\n        :param path: a path to save the model details at (hdfs, s3, local)\n        :param force: if True overwrite destination directory in case it exists, or throw exception if set to False.\n\n        :returns str: the path of the saved model details\n        \"\"\"\n        assert_is_type(path, str)\n        assert_is_type(force, bool)\n        path = os.path.join(os.getcwd() if path == \"\" else path, self.model_id + \".json\")\n        return h2o.api(\"GET /99/Models/%s/json\" % self.model_id, data={\"dir\": path, \"force\": force})[\"dir\"]", "language": "python", "code": "def save_model_details(self, path=\"\", force=False):\n        assert_is_type(path, str)\n        assert_is_type(force, bool)\n        path = os.path.join(os.getcwd() if path == \"\" else path, self.model_id + \".json\")\n        return h2o.api(\"GET /99/Models/%s/json\" % self.model_id, data={\"dir\": path, \"force\": force})[\"dir\"]", "code_tokens": ["def", "save_model_details", "(", "self", ",", "path", "=", "\"\"", ",", "force", "=", "False", ")", ":", "assert_is_type", "(", "path", ",", "str", ")", "assert_is_type", "(", "force", ",", "bool", ")", "path", "=", "os", ".", "path", ".", "join", "(", "os", ".", "getcwd", "(", ")", "if", "path", "==", "\"\"", "else", "path", ",", "self", ".", "model_id", "+", "\".json\"", ")", "return", "h2o", ".", "api", "(", "\"GET /99/Models/%s/json\"", "%", "self", ".", "model_id", ",", "data", "=", "{", "\"dir\"", ":", "path", ",", "\"force\"", ":", "force", "}", ")", "[", "\"dir\"", "]"], "docstring": "Save Model Details of an H2O Model in JSON Format to disk.", "docstring_tokens": ["Save", "Model", "Details", "of", "an", "H2O", "Model", "in", "JSON", "Format", "to", "disk", "."], "sha": "dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8", "url": "https://github.com/h2oai/h2o-3/blob/dd62aaa1e7f680a8b16ee14bc66b0fb5195c2ad8/h2o-py/h2o/model/model_base.py#L840-L853", "partition": "test", "index": 1543, "time": "2017-02-01 16:15:11"}
