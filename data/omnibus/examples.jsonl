{"repo": "chef/omnibus", "path": "lib/omnibus/packagers/bff.rb", "func_name": "Omnibus.Packager::BFF.create_bff_file", "original_string": "def create_bff_file\n      # We are making the assumption that sudo exists.\n      # Unforunately, the owner of the file in the staging directory is what\n      # will be on the target machine, and mkinstallp can't tell you if that\n      # is a bad thing (it usually is).\n      # The match is so we only pick the lowest level of the project dir.\n      # This implies that if we are in /tmp/staging/project/dir/things,\n      # we will chown from 'project' on, rather than 'project/dir', which leaves\n      # project owned by the build user (which is incorrect)\n      # First - let's find out who we are.\n      shellout!(\"sudo chown -Rh 0:0 #{File.join(staging_dir, project.install_dir.match(/^\\/?(\\w+)/).to_s)}\")\n      log.info(log_key) { \"Creating .bff file\" }\n\n      # Since we want the owner to be root, we need to sudo the mkinstallp\n      # command, otherwise it will not have access to the previously chowned\n      # directory.\n      shellout!(\"sudo /usr/sbin/mkinstallp -d #{staging_dir} -T #{File.join(staging_dir, 'gen.template')}\")\n\n      # Print the full contents of the inventory file generated by mkinstallp\n      # from within the staging_dir's .info folder (where control files for the\n      # packaging process are kept.)\n      log.debug(log_key) do\n        \"With .inventory file of:\\n\" + File.read(\"#{File.join( staging_dir, '.info', \"#{safe_base_package_name}.inventory\" )}\")\n      end\n\n      # Copy the resulting package up to the package_dir\n      FileSyncer.glob(File.join(staging_dir, \"tmp/*.bff\")).each do |bff|\n        copy_file(bff, File.join(Config.package_dir, create_bff_file_name))\n      end\n\n    ensure\n      # chown back to original user's uid/gid so cleanup works correctly\n      original_uid = shellout!(\"id -u\").stdout.chomp\n      original_gid = shellout!(\"id -g\").stdout.chomp\n\n      shellout!(\"sudo chown -Rh #{original_uid}:#{original_gid} #{staging_dir}\")\n    end", "language": "ruby", "code": "def create_bff_file\n      # We are making the assumption that sudo exists.\n      # Unforunately, the owner of the file in the staging directory is what\n      # will be on the target machine, and mkinstallp can't tell you if that\n      # is a bad thing (it usually is).\n      # The match is so we only pick the lowest level of the project dir.\n      # This implies that if we are in /tmp/staging/project/dir/things,\n      # we will chown from 'project' on, rather than 'project/dir', which leaves\n      # project owned by the build user (which is incorrect)\n      # First - let's find out who we are.\n      shellout!(\"sudo chown -Rh 0:0 #{File.join(staging_dir, project.install_dir.match(/^\\/?(\\w+)/).to_s)}\")\n      log.info(log_key) { \"Creating .bff file\" }\n\n      # Since we want the owner to be root, we need to sudo the mkinstallp\n      # command, otherwise it will not have access to the previously chowned\n      # directory.\n      shellout!(\"sudo /usr/sbin/mkinstallp -d #{staging_dir} -T #{File.join(staging_dir, 'gen.template')}\")\n\n      # Print the full contents of the inventory file generated by mkinstallp\n      # from within the staging_dir's .info folder (where control files for the\n      # packaging process are kept.)\n      log.debug(log_key) do\n        \"With .inventory file of:\\n\" + File.read(\"#{File.join( staging_dir, '.info', \"#{safe_base_package_name}.inventory\" )}\")\n      end\n\n      # Copy the resulting package up to the package_dir\n      FileSyncer.glob(File.join(staging_dir, \"tmp/*.bff\")).each do |bff|\n        copy_file(bff, File.join(Config.package_dir, create_bff_file_name))\n      end\n\n    ensure\n      # chown back to original user's uid/gid so cleanup works correctly\n      original_uid = shellout!(\"id -u\").stdout.chomp\n      original_gid = shellout!(\"id -g\").stdout.chomp\n\n      shellout!(\"sudo chown -Rh #{original_uid}:#{original_gid} #{staging_dir}\")\n    end", "code_tokens": ["def", "create_bff_file", "# We are making the assumption that sudo exists.", "# Unforunately, the owner of the file in the staging directory is what", "# will be on the target machine, and mkinstallp can't tell you if that", "# is a bad thing (it usually is).", "# The match is so we only pick the lowest level of the project dir.", "# This implies that if we are in /tmp/staging/project/dir/things,", "# we will chown from 'project' on, rather than 'project/dir', which leaves", "# project owned by the build user (which is incorrect)", "# First - let's find out who we are.", "shellout!", "(", "\"sudo chown -Rh 0:0 #{File.join(staging_dir, project.install_dir.match(/^\\/?(\\w+)/).to_s)}\"", ")", "log", ".", "info", "(", "log_key", ")", "{", "\"Creating .bff file\"", "}", "# Since we want the owner to be root, we need to sudo the mkinstallp", "# command, otherwise it will not have access to the previously chowned", "# directory.", "shellout!", "(", "\"sudo /usr/sbin/mkinstallp -d #{staging_dir} -T #{File.join(staging_dir, 'gen.template')}\"", ")", "# Print the full contents of the inventory file generated by mkinstallp", "# from within the staging_dir's .info folder (where control files for the", "# packaging process are kept.)", "log", ".", "debug", "(", "log_key", ")", "do", "\"With .inventory file of:\\n\"", "+", "File", ".", "read", "(", "\"#{File.join( staging_dir, '.info', \"#{safe_base_package_name}.inventory\" )}\"", ")", "end", "# Copy the resulting package up to the package_dir", "FileSyncer", ".", "glob", "(", "File", ".", "join", "(", "staging_dir", ",", "\"tmp/*.bff\"", ")", ")", ".", "each", "do", "|", "bff", "|", "copy_file", "(", "bff", ",", "File", ".", "join", "(", "Config", ".", "package_dir", ",", "create_bff_file_name", ")", ")", "end", "ensure", "# chown back to original user's uid/gid so cleanup works correctly", "original_uid", "=", "shellout!", "(", "\"id -u\"", ")", ".", "stdout", ".", "chomp", "original_gid", "=", "shellout!", "(", "\"id -g\"", ")", ".", "stdout", ".", "chomp", "shellout!", "(", "\"sudo chown -Rh #{original_uid}:#{original_gid} #{staging_dir}\"", ")", "end"], "docstring": "Create the bff file using +mkinstallp+.\n\n Warning: This command runs as sudo! AIX requires the use of sudo to run\n the +mkinstallp+ command.\n\n @return [void]", "docstring_tokens": ["Create", "the", "bff", "file", "using", "+", "mkinstallp", "+", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/packagers/bff.rb#L207-L243", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/file_syncer.rb", "func_name": "Omnibus.FileSyncer.relative_path_for", "original_string": "def relative_path_for(path, parent)\n      Pathname.new(path).relative_path_from(Pathname.new(parent)).to_s\n    end", "language": "ruby", "code": "def relative_path_for(path, parent)\n      Pathname.new(path).relative_path_from(Pathname.new(parent)).to_s\n    end", "code_tokens": ["def", "relative_path_for", "(", "path", ",", "parent", ")", "Pathname", ".", "new", "(", "path", ")", ".", "relative_path_from", "(", "Pathname", ".", "new", "(", "parent", ")", ")", ".", "to_s", "end"], "docstring": "The relative path of the given +path+ to the +parent+.\n\n @param [String] path\n   the path to get relative with\n @param [String] parent\n   the parent where the path is contained (hopefully)\n\n @return [String]", "docstring_tokens": ["The", "relative", "path", "of", "the", "given", "+", "path", "+", "to", "the", "+", "parent", "+", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/file_syncer.rb#L186-L188", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/compressors/dmg.rb", "func_name": "Omnibus.Compressor::DMG.set_dmg_icon", "original_string": "def set_dmg_icon\n      log.info(log_key) { \"Setting dmg icon\" }\n\n      Dir.chdir(staging_dir) do\n        shellout! <<-EOH.gsub(/^ {10}/, \"\")\n          # Convert the png to an icon\n          sips -i \"#{resource_path('icon.png')}\"\n\n          # Extract the icon into its own resource\n          DeRez -only icns \"#{resource_path('icon.png')}\" > tmp.rsrc\n\n          # Append the icon reosurce to the DMG\n          Rez -append tmp.rsrc -o \"#{package_path}\"\n\n          # Source the icon\n          SetFile -a C \"#{package_path}\"\n        EOH\n      end\n    end", "language": "ruby", "code": "def set_dmg_icon\n      log.info(log_key) { \"Setting dmg icon\" }\n\n      Dir.chdir(staging_dir) do\n        shellout! <<-EOH.gsub(/^ {10}/, \"\")\n          # Convert the png to an icon\n          sips -i \"#{resource_path('icon.png')}\"\n\n          # Extract the icon into its own resource\n          DeRez -only icns \"#{resource_path('icon.png')}\" > tmp.rsrc\n\n          # Append the icon reosurce to the DMG\n          Rez -append tmp.rsrc -o \"#{package_path}\"\n\n          # Source the icon\n          SetFile -a C \"#{package_path}\"\n        EOH\n      end\n    end", "code_tokens": ["def", "set_dmg_icon", "log", ".", "info", "(", "log_key", ")", "{", "\"Setting dmg icon\"", "}", "Dir", ".", "chdir", "(", "staging_dir", ")", "do", "shellout!", "<<-EOH", ".", "gsub", "(", "/", "/", ",", "\"\"", ")", "#{", "resource_path", "(", "'icon.png'", ")", "}", "#{", "resource_path", "(", "'icon.png'", ")", "}", "#{", "package_path", "}", "#{", "package_path", "}", "EOH", "end", "end"], "docstring": "Set the dmg icon to our custom icon.\n\n @return [void]", "docstring_tokens": ["Set", "the", "dmg", "icon", "to", "our", "custom", "icon", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/compressors/dmg.rb#L274-L292", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/packagers/ips.rb", "func_name": "Omnibus.Packager::IPS.export_pkg_archive_file", "original_string": "def export_pkg_archive_file\n      # The destination file cannot already exist\n      File.delete(package_path) if File.exist?(package_path)\n      shellout!(\"pkgrecv -s #{repo_dir} -a -d #{package_path} #{safe_base_package_name}\")\n      log.info(log_key) { \"Exported IPS package archive: #{package_path}\" }\n\n      list_pkgarchive = shellout(\"pkgrepo list -s #{package_path} '*@latest'\").stdout\n      log.debug(log_key) do\n        <<-EOH.strip\n          IPS package archive contents:\n\n            #{list_pkgarchive}\n        EOH\n      end\n    end", "language": "ruby", "code": "def export_pkg_archive_file\n      # The destination file cannot already exist\n      File.delete(package_path) if File.exist?(package_path)\n      shellout!(\"pkgrecv -s #{repo_dir} -a -d #{package_path} #{safe_base_package_name}\")\n      log.info(log_key) { \"Exported IPS package archive: #{package_path}\" }\n\n      list_pkgarchive = shellout(\"pkgrepo list -s #{package_path} '*@latest'\").stdout\n      log.debug(log_key) do\n        <<-EOH.strip\n          IPS package archive contents:\n\n            #{list_pkgarchive}\n        EOH\n      end\n    end", "code_tokens": ["def", "export_pkg_archive_file", "# The destination file cannot already exist", "File", ".", "delete", "(", "package_path", ")", "if", "File", ".", "exist?", "(", "package_path", ")", "shellout!", "(", "\"pkgrecv -s #{repo_dir} -a -d #{package_path} #{safe_base_package_name}\"", ")", "log", ".", "info", "(", "log_key", ")", "{", "\"Exported IPS package archive: #{package_path}\"", "}", "list_pkgarchive", "=", "shellout", "(", "\"pkgrepo list -s #{package_path} '*@latest'\"", ")", ".", "stdout", "log", ".", "debug", "(", "log_key", ")", "do", "<<-EOH", ".", "strip", "#{", "list_pkgarchive", "}", "EOH", "end", "end"], "docstring": "Convert a the published IPS pkg from the local repo into the more\n easily distributable `*.p5p` archive.\n\n @return [void]", "docstring_tokens": ["Convert", "a", "the", "published", "IPS", "pkg", "from", "the", "local", "repo", "into", "the", "more", "easily", "distributable", "*", ".", "p5p", "archive", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/packagers/ips.rb#L347-L361", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/health_check.rb", "func_name": "Omnibus.HealthCheck.check_for_bad_library", "original_string": "def check_for_bad_library(bad_libs, current_library, name, linked)\n      safe = nil\n\n      whitelist_libs = case Ohai[\"platform\"]\n                       when \"arch\"\n                         ARCH_WHITELIST_LIBS\n                       when \"mac_os_x\"\n                         MAC_WHITELIST_LIBS\n                       when \"solaris2\"\n                         SOLARIS_WHITELIST_LIBS\n                       when \"smartos\"\n                         SMARTOS_WHITELIST_LIBS\n                       when \"freebsd\"\n                         FREEBSD_WHITELIST_LIBS\n                       when \"aix\"\n                         AIX_WHITELIST_LIBS\n                       else\n                         WHITELIST_LIBS\n                       end\n\n      whitelist_libs.each do |reg|\n        safe ||= true if reg.match(name)\n      end\n\n      whitelist_files.each do |reg|\n        safe ||= true if reg.match(current_library)\n      end\n\n      log.debug(log_key) { \"  --> Dependency: #{name}\" }\n      log.debug(log_key) { \"  --> Provided by: #{linked}\" }\n\n      if !safe && linked !~ Regexp.new(project.install_dir)\n        log.debug(log_key) { \"    -> FAILED: #{current_library} has unsafe dependencies\" }\n        bad_libs[current_library] ||= {}\n        bad_libs[current_library][name] ||= {}\n        if bad_libs[current_library][name].key?(linked)\n          bad_libs[current_library][name][linked] += 1\n        else\n          bad_libs[current_library][name][linked] = 1\n        end\n      else\n        log.debug(log_key) { \"    -> PASSED: #{name} is either whitelisted or safely provided.\" }\n      end\n\n      bad_libs\n    end", "language": "ruby", "code": "def check_for_bad_library(bad_libs, current_library, name, linked)\n      safe = nil\n\n      whitelist_libs = case Ohai[\"platform\"]\n                       when \"arch\"\n                         ARCH_WHITELIST_LIBS\n                       when \"mac_os_x\"\n                         MAC_WHITELIST_LIBS\n                       when \"solaris2\"\n                         SOLARIS_WHITELIST_LIBS\n                       when \"smartos\"\n                         SMARTOS_WHITELIST_LIBS\n                       when \"freebsd\"\n                         FREEBSD_WHITELIST_LIBS\n                       when \"aix\"\n                         AIX_WHITELIST_LIBS\n                       else\n                         WHITELIST_LIBS\n                       end\n\n      whitelist_libs.each do |reg|\n        safe ||= true if reg.match(name)\n      end\n\n      whitelist_files.each do |reg|\n        safe ||= true if reg.match(current_library)\n      end\n\n      log.debug(log_key) { \"  --> Dependency: #{name}\" }\n      log.debug(log_key) { \"  --> Provided by: #{linked}\" }\n\n      if !safe && linked !~ Regexp.new(project.install_dir)\n        log.debug(log_key) { \"    -> FAILED: #{current_library} has unsafe dependencies\" }\n        bad_libs[current_library] ||= {}\n        bad_libs[current_library][name] ||= {}\n        if bad_libs[current_library][name].key?(linked)\n          bad_libs[current_library][name][linked] += 1\n        else\n          bad_libs[current_library][name][linked] = 1\n        end\n      else\n        log.debug(log_key) { \"    -> PASSED: #{name} is either whitelisted or safely provided.\" }\n      end\n\n      bad_libs\n    end", "code_tokens": ["def", "check_for_bad_library", "(", "bad_libs", ",", "current_library", ",", "name", ",", "linked", ")", "safe", "=", "nil", "whitelist_libs", "=", "case", "Ohai", "[", "\"platform\"", "]", "when", "\"arch\"", "ARCH_WHITELIST_LIBS", "when", "\"mac_os_x\"", "MAC_WHITELIST_LIBS", "when", "\"solaris2\"", "SOLARIS_WHITELIST_LIBS", "when", "\"smartos\"", "SMARTOS_WHITELIST_LIBS", "when", "\"freebsd\"", "FREEBSD_WHITELIST_LIBS", "when", "\"aix\"", "AIX_WHITELIST_LIBS", "else", "WHITELIST_LIBS", "end", "whitelist_libs", ".", "each", "do", "|", "reg", "|", "safe", "||=", "true", "if", "reg", ".", "match", "(", "name", ")", "end", "whitelist_files", ".", "each", "do", "|", "reg", "|", "safe", "||=", "true", "if", "reg", ".", "match", "(", "current_library", ")", "end", "log", ".", "debug", "(", "log_key", ")", "{", "\"  --> Dependency: #{name}\"", "}", "log", ".", "debug", "(", "log_key", ")", "{", "\"  --> Provided by: #{linked}\"", "}", "if", "!", "safe", "&&", "linked", "!~", "Regexp", ".", "new", "(", "project", ".", "install_dir", ")", "log", ".", "debug", "(", "log_key", ")", "{", "\"    -> FAILED: #{current_library} has unsafe dependencies\"", "}", "bad_libs", "[", "current_library", "]", "||=", "{", "}", "bad_libs", "[", "current_library", "]", "[", "name", "]", "||=", "{", "}", "if", "bad_libs", "[", "current_library", "]", "[", "name", "]", ".", "key?", "(", "linked", ")", "bad_libs", "[", "current_library", "]", "[", "name", "]", "[", "linked", "]", "+=", "1", "else", "bad_libs", "[", "current_library", "]", "[", "name", "]", "[", "linked", "]", "=", "1", "end", "else", "log", ".", "debug", "(", "log_key", ")", "{", "\"    -> PASSED: #{name} is either whitelisted or safely provided.\"", "}", "end", "bad_libs", "end"], "docstring": "Check the given path and library for \"bad\" libraries.\n\n @param [Hash<String, Hash<String, Hash<String, Int>>>]\n   the bad libraries (library_name -> dependency_name -> satisfied_lib_path -> count)\n @param [String]\n   the library being analyzed\n @param [String]\n   dependency library name\n @param [String]\n   actual path of library satisfying the dependency\n\n @return the modified bad_library hash", "docstring_tokens": ["Check", "the", "given", "path", "and", "library", "for", "bad", "libraries", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/health_check.rb#L423-L468", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/digestable.rb", "func_name": "Omnibus.Digestable.update_with_file_contents", "original_string": "def update_with_file_contents(digest, filename)\n      File.open(filename) do |io|\n        while (chunk = io.read(1024 * 8))\n          digest.update(chunk)\n        end\n      end\n    end", "language": "ruby", "code": "def update_with_file_contents(digest, filename)\n      File.open(filename) do |io|\n        while (chunk = io.read(1024 * 8))\n          digest.update(chunk)\n        end\n      end\n    end", "code_tokens": ["def", "update_with_file_contents", "(", "digest", ",", "filename", ")", "File", ".", "open", "(", "filename", ")", "do", "|", "io", "|", "while", "(", "chunk", "=", "io", ".", "read", "(", "1024", "*", "8", ")", ")", "digest", ".", "update", "(", "chunk", ")", "end", "end", "end"], "docstring": "Update the digest with the given contents of the file, reading in small\n chunks to reduce memory. This method will update the given +digest+\n parameter, but returns nothing.\n\n @param [Digest] digest\n   the digest to update\n @param [String] filename\n   the path to the file on disk to read\n\n @return [void]", "docstring_tokens": ["Update", "the", "digest", "with", "the", "given", "contents", "of", "the", "file", "reading", "in", "small", "chunks", "to", "reduce", "memory", ".", "This", "method", "will", "update", "the", "given", "+", "digest", "+", "parameter", "but", "returns", "nothing", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/digestable.rb#L122-L128", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/packagers/pkg.rb", "func_name": "Omnibus.Packager::PKG.safe_version", "original_string": "def safe_version\n      if project.build_version =~ /\\A[a-zA-Z0-9\\.\\+\\-]+\\z/\n        project.build_version.dup\n      else\n        converted = project.build_version.gsub(/[^a-zA-Z0-9\\.\\+\\-]+/, \"-\")\n\n        log.warn(log_key) do\n          \"The `version' component of Mac package names can only include \" \\\n          \"alphabetical characters (a-z, A-Z), numbers (0-9), dots (.), \" \\\n          \"plus signs (+), and dashes (-). Converting \" \\\n          \"`#{project.build_version}' to `#{converted}'.\"\n        end\n\n        converted\n      end\n    end", "language": "ruby", "code": "def safe_version\n      if project.build_version =~ /\\A[a-zA-Z0-9\\.\\+\\-]+\\z/\n        project.build_version.dup\n      else\n        converted = project.build_version.gsub(/[^a-zA-Z0-9\\.\\+\\-]+/, \"-\")\n\n        log.warn(log_key) do\n          \"The `version' component of Mac package names can only include \" \\\n          \"alphabetical characters (a-z, A-Z), numbers (0-9), dots (.), \" \\\n          \"plus signs (+), and dashes (-). Converting \" \\\n          \"`#{project.build_version}' to `#{converted}'.\"\n        end\n\n        converted\n      end\n    end", "code_tokens": ["def", "safe_version", "if", "project", ".", "build_version", "=~", "/", "\\A", "\\.", "\\+", "\\-", "\\z", "/", "project", ".", "build_version", ".", "dup", "else", "converted", "=", "project", ".", "build_version", ".", "gsub", "(", "/", "\\.", "\\+", "\\-", "/", ",", "\"-\"", ")", "log", ".", "warn", "(", "log_key", ")", "do", "\"The `version' component of Mac package names can only include \"", "\"alphabetical characters (a-z, A-Z), numbers (0-9), dots (.), \"", "\"plus signs (+), and dashes (-). Converting \"", "\"`#{project.build_version}' to `#{converted}'.\"", "end", "converted", "end", "end"], "docstring": "Return the PKG-ready version, converting any invalid characters to\n dashes (+-+).\n\n @return [String]", "docstring_tokens": ["Return", "the", "PKG", "-", "ready", "version", "converting", "any", "invalid", "characters", "to", "dashes", "(", "+", "-", "+", ")", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/packagers/pkg.rb#L310-L325", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/publishers/artifactory_publisher.rb", "func_name": "Omnibus.ArtifactoryPublisher.remote_path_for", "original_string": "def remote_path_for(package)\n      File.join(\n        Config.artifactory_base_path,\n        Config.artifactory_publish_pattern % package.metadata\n      )\n    end", "language": "ruby", "code": "def remote_path_for(package)\n      File.join(\n        Config.artifactory_base_path,\n        Config.artifactory_publish_pattern % package.metadata\n      )\n    end", "code_tokens": ["def", "remote_path_for", "(", "package", ")", "File", ".", "join", "(", "Config", ".", "artifactory_base_path", ",", "Config", ".", "artifactory_publish_pattern", "%", "package", ".", "metadata", ")", "end"], "docstring": "The path where the package will live inside of the Artifactory repository.\n This is dynamically computed from the values in the project definition\n and the package metadata.\n\n @example\n   com/getchef/chef/11.6.0/ubuntu/14.04/chef-11.6.0-1.el6.x86_64.rpm\n\n @param [Package] package\n   the package to generate the remote path for\n\n @return [String]", "docstring_tokens": ["The", "path", "where", "the", "package", "will", "live", "inside", "of", "the", "Artifactory", "repository", ".", "This", "is", "dynamically", "computed", "from", "the", "values", "in", "the", "project", "definition", "and", "the", "package", "metadata", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/publishers/artifactory_publisher.rb#L270-L275", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/packagers/msi.rb", "func_name": "Omnibus.Packager::MSI.light_command", "original_string": "def light_command(out_file, is_bundle: false)\n      if is_bundle\n        <<-EOH.split.join(\" \").squeeze(\" \").strip\n        light.exe\n          -nologo\n          #{wix_light_delay_validation}\n          -ext WixUIExtension\n          -ext WixBalExtension\n          #{wix_extension_switches(wix_light_extensions)}\n          -cultures:#{localization}\n          -loc \"#{windows_safe_path(staging_dir, \"localization-#{localization}.wxl\")}\"\n          bundle.wixobj\n          -out \"#{out_file}\"\n        EOH\n      else\n        <<-EOH.split.join(\" \").squeeze(\" \").strip\n          light.exe\n            -nologo\n            #{wix_light_delay_validation}\n            -ext WixUIExtension\n            #{wix_extension_switches(wix_light_extensions)}\n            -cultures:#{localization}\n            -loc \"#{windows_safe_path(staging_dir, \"localization-#{localization}.wxl\")}\"\n            project-files.wixobj source.wixobj\n            -out \"#{out_file}\"\n        EOH\n      end\n    end", "language": "ruby", "code": "def light_command(out_file, is_bundle: false)\n      if is_bundle\n        <<-EOH.split.join(\" \").squeeze(\" \").strip\n        light.exe\n          -nologo\n          #{wix_light_delay_validation}\n          -ext WixUIExtension\n          -ext WixBalExtension\n          #{wix_extension_switches(wix_light_extensions)}\n          -cultures:#{localization}\n          -loc \"#{windows_safe_path(staging_dir, \"localization-#{localization}.wxl\")}\"\n          bundle.wixobj\n          -out \"#{out_file}\"\n        EOH\n      else\n        <<-EOH.split.join(\" \").squeeze(\" \").strip\n          light.exe\n            -nologo\n            #{wix_light_delay_validation}\n            -ext WixUIExtension\n            #{wix_extension_switches(wix_light_extensions)}\n            -cultures:#{localization}\n            -loc \"#{windows_safe_path(staging_dir, \"localization-#{localization}.wxl\")}\"\n            project-files.wixobj source.wixobj\n            -out \"#{out_file}\"\n        EOH\n      end\n    end", "code_tokens": ["def", "light_command", "(", "out_file", ",", "is_bundle", ":", "false", ")", "if", "is_bundle", "<<-EOH", ".", "split", ".", "join", "(", "\" \"", ")", ".", "squeeze", "(", "\" \"", ")", ".", "strip", "#{", "wix_light_delay_validation", "}", "#{", "wix_extension_switches", "(", "wix_light_extensions", ")", "}", "#{", "localization", "}", "#{", "windows_safe_path", "(", "staging_dir", ",", "\"localization-#{localization}.wxl\"", ")", "}", "#{", "out_file", "}", "EOH", "else", "<<-EOH", ".", "split", ".", "join", "(", "\" \"", ")", ".", "squeeze", "(", "\" \"", ")", ".", "strip", "#{", "wix_light_delay_validation", "}", "#{", "wix_extension_switches", "(", "wix_light_extensions", ")", "}", "#{", "localization", "}", "#{", "windows_safe_path", "(", "staging_dir", ",", "\"localization-#{localization}.wxl\"", ")", "}", "#{", "out_file", "}", "EOH", "end", "end"], "docstring": "Get the shell command to link the project WIX object files\n\n @return [String]", "docstring_tokens": ["Get", "the", "shell", "command", "to", "link", "the", "project", "WIX", "object", "files"], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/packagers/msi.rb#L509-L536", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/build_version_dsl.rb", "func_name": "Omnibus.BuildVersionDSL.construct_build_version", "original_string": "def construct_build_version(version_source = nil)\n      case source_type\n      when :git\n        version = if version_source\n                    Omnibus::BuildVersion.new(version_source.project_dir)\n                  else\n                    Omnibus::BuildVersion.new\n                  end\n\n        output = output_method || :semver\n        self.build_version = version.send(output)\n      when :version\n        if version_source\n          self.build_version = version_source.version\n        else\n          raise \"Please tell me the source to get the version from\"\n        end\n      else\n        raise \"I don't know how to construct a build_version using source '#{source_type}'\"\n      end\n    end", "language": "ruby", "code": "def construct_build_version(version_source = nil)\n      case source_type\n      when :git\n        version = if version_source\n                    Omnibus::BuildVersion.new(version_source.project_dir)\n                  else\n                    Omnibus::BuildVersion.new\n                  end\n\n        output = output_method || :semver\n        self.build_version = version.send(output)\n      when :version\n        if version_source\n          self.build_version = version_source.version\n        else\n          raise \"Please tell me the source to get the version from\"\n        end\n      else\n        raise \"I don't know how to construct a build_version using source '#{source_type}'\"\n      end\n    end", "code_tokens": ["def", "construct_build_version", "(", "version_source", "=", "nil", ")", "case", "source_type", "when", ":git", "version", "=", "if", "version_source", "Omnibus", "::", "BuildVersion", ".", "new", "(", "version_source", ".", "project_dir", ")", "else", "Omnibus", "::", "BuildVersion", ".", "new", "end", "output", "=", "output_method", "||", ":semver", "self", ".", "build_version", "=", "version", ".", "send", "(", "output", ")", "when", ":version", "if", "version_source", "self", ".", "build_version", "=", "version_source", ".", "version", "else", "raise", "\"Please tell me the source to get the version from\"", "end", "else", "raise", "\"I don't know how to construct a build_version using source '#{source_type}'\"", "end", "end"], "docstring": "Determines the build_version based on source_type, output_method.\n\n @param version_source [Omnibus::Software] Software object from which the\n   build version will be determined from. Default is nil.\n @return [void]", "docstring_tokens": ["Determines", "the", "build_version", "based", "on", "source_type", "output_method", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/build_version_dsl.rb#L152-L172", "partition": "test"}
