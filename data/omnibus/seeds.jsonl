{"repo": "chef/omnibus", "path": "lib/omnibus/compressor.rb", "func_name": "Omnibus.Compressor.for_current_system", "original_string": "def for_current_system(compressors)\n      family = Ohai[\"platform_family\"]\n\n      if family == \"mac_os_x\"\n        if compressors.include?(:dmg)\n          return DMG\n        end\n\n        if compressors.include?(:tgz)\n          return TGZ\n        end\n      end\n\n      if compressors.include?(:tgz)\n        return TGZ\n      else\n        log.info(log_key) { \"No compressor defined for `#{family}'.\" }\n        return Null\n      end\n    end", "language": "ruby", "code": "def for_current_system(compressors)\n      family = Ohai[\"platform_family\"]\n\n      if family == \"mac_os_x\"\n        if compressors.include?(:dmg)\n          return DMG\n        end\n\n        if compressors.include?(:tgz)\n          return TGZ\n        end\n      end\n\n      if compressors.include?(:tgz)\n        return TGZ\n      else\n        log.info(log_key) { \"No compressor defined for `#{family}'.\" }\n        return Null\n      end\n    end", "code_tokens": ["def", "for_current_system", "(", "compressors", ")", "family", "=", "Ohai", "[", "\"platform_family\"", "]", "if", "family", "==", "\"mac_os_x\"", "if", "compressors", ".", "include?", "(", ":dmg", ")", "return", "DMG", "end", "if", "compressors", ".", "include?", "(", ":tgz", ")", "return", "TGZ", "end", "end", "if", "compressors", ".", "include?", "(", ":tgz", ")", "return", "TGZ", "else", "log", ".", "info", "(", "log_key", ")", "{", "\"No compressor defined for `#{family}'.\"", "}", "return", "Null", "end", "end"], "docstring": "Determine the best compressor for the current system. This method returns\n the class, not an instance of the class.\n\n @example\n   Compressor.for_current_system([:dmg, :tgz]) #=> Packager::DMG\n\n @param [Array<Symbol>] compressors\n   the list of configured compressors\n\n @return [~Compressor::Base]", "docstring_tokens": ["Determine", "the", "best", "compressor", "for", "the", "current", "system", ".", "This", "method", "returns", "the", "class", "not", "an", "instance", "of", "the", "class", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/compressor.rb#L38-L57", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/packagers/bff.rb", "func_name": "Omnibus.Packager::BFF.write_gen_template", "original_string": "def write_gen_template\n      # Get a list of all files\n      files = FileSyncer.glob(\"#{staging_dir}/**/*\").reject do |path|\n        # remove any files with spaces or braces.\n        if path =~ /[[:space:]{}]/\n          log.warn(log_key) { \"Skipping packaging '#{path}' file due to whitespace or braces in filename\" }\n          true\n        end\n      end\n      files.map! do |path|\n        # If paths have colons or commas, rename them and add them to a post-install,\n        # post-sysck renaming script ('config') which is created if needed\n        if path =~ /:|,/\n          alt = path.gsub(/(:|,)/, \"__\")\n          log.debug(log_key) { \"Renaming #{path} to #{alt}\" }\n\n          File.rename(path, alt) if File.exist?(path)\n\n          # Create a config script if needed based on resources/bff/config.erb\n          config_script_path = File.join(scripts_staging_dir, \"config\")\n          unless File.exist? config_script_path\n            render_template(resource_path(\"config.erb\"),\n              destination: \"#{scripts_staging_dir}/config\",\n              variables: {\n                name: project.name,\n              }\n            )\n          end\n\n          File.open(File.join(scripts_staging_dir, \"config\"), \"a\") do |file|\n            file.puts \"mv '#{alt.gsub(/^#{staging_dir}/, '')}' '#{path.gsub(/^#{staging_dir}/, '')}'\"\n          end\n\n          path = alt\n        end\n\n        path.gsub(/^#{staging_dir}/, \"\")\n      end\n\n      # Create a map of scripts that exist to inject into the template\n      scripts = SCRIPT_MAP.inject({}) do |hash, (script, installp_key)|\n        staging_path = File.join(scripts_staging_dir, script.to_s)\n\n        if File.file?(staging_path)\n          hash[installp_key] = staging_path\n          log.debug(log_key) { installp_key + \":\\n\" + File.read(staging_path) }\n        end\n\n        hash\n      end\n\n      render_template(resource_path(\"gen.template.erb\"),\n        destination: File.join(staging_dir, \"gen.template\"),\n        variables: {\n          name: safe_base_package_name,\n          install_dir: project.install_dir,\n          friendly_name: project.friendly_name,\n          version: bff_version,\n          description: project.description,\n          files: files,\n          scripts: scripts,\n        }\n      )\n\n      # Print the full contents of the rendered template file for mkinstallp's use\n      log.debug(log_key) { \"Rendered Template:\\n\" + File.read(File.join(staging_dir, \"gen.template\")) }\n    end", "language": "ruby", "code": "def write_gen_template\n      # Get a list of all files\n      files = FileSyncer.glob(\"#{staging_dir}/**/*\").reject do |path|\n        # remove any files with spaces or braces.\n        if path =~ /[[:space:]{}]/\n          log.warn(log_key) { \"Skipping packaging '#{path}' file due to whitespace or braces in filename\" }\n          true\n        end\n      end\n      files.map! do |path|\n        # If paths have colons or commas, rename them and add them to a post-install,\n        # post-sysck renaming script ('config') which is created if needed\n        if path =~ /:|,/\n          alt = path.gsub(/(:|,)/, \"__\")\n          log.debug(log_key) { \"Renaming #{path} to #{alt}\" }\n\n          File.rename(path, alt) if File.exist?(path)\n\n          # Create a config script if needed based on resources/bff/config.erb\n          config_script_path = File.join(scripts_staging_dir, \"config\")\n          unless File.exist? config_script_path\n            render_template(resource_path(\"config.erb\"),\n              destination: \"#{scripts_staging_dir}/config\",\n              variables: {\n                name: project.name,\n              }\n            )\n          end\n\n          File.open(File.join(scripts_staging_dir, \"config\"), \"a\") do |file|\n            file.puts \"mv '#{alt.gsub(/^#{staging_dir}/, '')}' '#{path.gsub(/^#{staging_dir}/, '')}'\"\n          end\n\n          path = alt\n        end\n\n        path.gsub(/^#{staging_dir}/, \"\")\n      end\n\n      # Create a map of scripts that exist to inject into the template\n      scripts = SCRIPT_MAP.inject({}) do |hash, (script, installp_key)|\n        staging_path = File.join(scripts_staging_dir, script.to_s)\n\n        if File.file?(staging_path)\n          hash[installp_key] = staging_path\n          log.debug(log_key) { installp_key + \":\\n\" + File.read(staging_path) }\n        end\n\n        hash\n      end\n\n      render_template(resource_path(\"gen.template.erb\"),\n        destination: File.join(staging_dir, \"gen.template\"),\n        variables: {\n          name: safe_base_package_name,\n          install_dir: project.install_dir,\n          friendly_name: project.friendly_name,\n          version: bff_version,\n          description: project.description,\n          files: files,\n          scripts: scripts,\n        }\n      )\n\n      # Print the full contents of the rendered template file for mkinstallp's use\n      log.debug(log_key) { \"Rendered Template:\\n\" + File.read(File.join(staging_dir, \"gen.template\")) }\n    end", "code_tokens": ["def", "write_gen_template", "# Get a list of all files", "files", "=", "FileSyncer", ".", "glob", "(", "\"#{staging_dir}/**/*\"", ")", ".", "reject", "do", "|", "path", "|", "# remove any files with spaces or braces.", "if", "path", "=~", "/", "/", "log", ".", "warn", "(", "log_key", ")", "{", "\"Skipping packaging '#{path}' file due to whitespace or braces in filename\"", "}", "true", "end", "end", "files", ".", "map!", "do", "|", "path", "|", "# If paths have colons or commas, rename them and add them to a post-install,", "# post-sysck renaming script ('config') which is created if needed", "if", "path", "=~", "/", "/", "alt", "=", "path", ".", "gsub", "(", "/", "/", ",", "\"__\"", ")", "log", ".", "debug", "(", "log_key", ")", "{", "\"Renaming #{path} to #{alt}\"", "}", "File", ".", "rename", "(", "path", ",", "alt", ")", "if", "File", ".", "exist?", "(", "path", ")", "# Create a config script if needed based on resources/bff/config.erb", "config_script_path", "=", "File", ".", "join", "(", "scripts_staging_dir", ",", "\"config\"", ")", "unless", "File", ".", "exist?", "config_script_path", "render_template", "(", "resource_path", "(", "\"config.erb\"", ")", ",", "destination", ":", "\"#{scripts_staging_dir}/config\"", ",", "variables", ":", "{", "name", ":", "project", ".", "name", ",", "}", ")", "end", "File", ".", "open", "(", "File", ".", "join", "(", "scripts_staging_dir", ",", "\"config\"", ")", ",", "\"a\"", ")", "do", "|", "file", "|", "file", ".", "puts", "\"mv '#{alt.gsub(/^#{staging_dir}/, '')}' '#{path.gsub(/^#{staging_dir}/, '')}'\"", "end", "path", "=", "alt", "end", "path", ".", "gsub", "(", "/", "#{", "staging_dir", "}", "/", ",", "\"\"", ")", "end", "# Create a map of scripts that exist to inject into the template", "scripts", "=", "SCRIPT_MAP", ".", "inject", "(", "{", "}", ")", "do", "|", "hash", ",", "(", "script", ",", "installp_key", ")", "|", "staging_path", "=", "File", ".", "join", "(", "scripts_staging_dir", ",", "script", ".", "to_s", ")", "if", "File", ".", "file?", "(", "staging_path", ")", "hash", "[", "installp_key", "]", "=", "staging_path", "log", ".", "debug", "(", "log_key", ")", "{", "installp_key", "+", "\":\\n\"", "+", "File", ".", "read", "(", "staging_path", ")", "}", "end", "hash", "end", "render_template", "(", "resource_path", "(", "\"gen.template.erb\"", ")", ",", "destination", ":", "File", ".", "join", "(", "staging_dir", ",", "\"gen.template\"", ")", ",", "variables", ":", "{", "name", ":", "safe_base_package_name", ",", "install_dir", ":", "project", ".", "install_dir", ",", "friendly_name", ":", "project", ".", "friendly_name", ",", "version", ":", "bff_version", ",", "description", ":", "project", ".", "description", ",", "files", ":", "files", ",", "scripts", ":", "scripts", ",", "}", ")", "# Print the full contents of the rendered template file for mkinstallp's use", "log", ".", "debug", "(", "log_key", ")", "{", "\"Rendered Template:\\n\"", "+", "File", ".", "read", "(", "File", ".", "join", "(", "staging_dir", ",", "\"gen.template\"", ")", ")", "}", "end"], "docstring": "Create the gen template for +mkinstallp+.\n\n @return [void]\n\n Some details on the various lifecycle scripts:\n\n The order of the installp scripts is:\n - install\n   - pre-install\n   - post-install\n   - config\n - upgrade\n   - pre-remove (of previous version)\n   - pre-install (previous version of software not present anymore)\n   - post-install\n   - config\n - remove\n   - unconfig\n   - unpre-install\n\n To run the new version of scc, the post-install will do.\n To run the previous version with an upgrade, use the pre-remove script.\n To run a source install of scc upon installation of installp package, use the pre-install.\n Upon upgrade, both the pre-remove and the pre-install scripts will run.\n As scc has been removed between the runs of these scripts, it will only run once during upgrade.\n\n Keywords for scripts:\n\n   Pre-installation Script: /path/script\n   Unpre-installation Script: /path/script\n   Post-installation Script: /path/script\n   Pre_rm Script: /path/script\n   Configuration Script: /path/script\n   Unconfiguration Script: /path/script", "docstring_tokens": ["Create", "the", "gen", "template", "for", "+", "mkinstallp", "+", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/packagers/bff.rb#L131-L197", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/file_syncer.rb", "func_name": "Omnibus.FileSyncer.glob", "original_string": "def glob(pattern)\n      pattern = Pathname.new(pattern).cleanpath.to_s\n      Dir.glob(pattern, File::FNM_DOTMATCH).sort.reject do |file|\n        basename = File.basename(file)\n        IGNORED_FILES.include?(basename)\n      end\n    end", "language": "ruby", "code": "def glob(pattern)\n      pattern = Pathname.new(pattern).cleanpath.to_s\n      Dir.glob(pattern, File::FNM_DOTMATCH).sort.reject do |file|\n        basename = File.basename(file)\n        IGNORED_FILES.include?(basename)\n      end\n    end", "code_tokens": ["def", "glob", "(", "pattern", ")", "pattern", "=", "Pathname", ".", "new", "(", "pattern", ")", ".", "cleanpath", ".", "to_s", "Dir", ".", "glob", "(", "pattern", ",", "File", "::", "FNM_DOTMATCH", ")", ".", "sort", ".", "reject", "do", "|", "file", "|", "basename", "=", "File", ".", "basename", "(", "file", ")", "IGNORED_FILES", ".", "include?", "(", "basename", ")", "end", "end"], "docstring": "Glob across the given pattern, accounting for dotfiles, removing Ruby's\n dumb idea to include +'.'+ and +'..'+ as entries.\n\n @param [String] pattern\n   the path or glob pattern to get all files from\n\n @return [Array<String>]\n   the list of all files", "docstring_tokens": ["Glob", "across", "the", "given", "pattern", "accounting", "for", "dotfiles", "removing", "Ruby", "s", "dumb", "idea", "to", "include", "+", ".", "+", "and", "+", "..", "+", "as", "entries", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/file_syncer.rb#L36-L42", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/file_syncer.rb", "func_name": "Omnibus.FileSyncer.all_files_under", "original_string": "def all_files_under(source, options = {})\n      excludes = Array(options[:exclude]).map do |exclude|\n        [exclude, \"#{exclude}/*\"]\n      end.flatten\n\n      source_files = glob(File.join(source, \"**/*\"))\n      source_files = source_files.reject do |source_file|\n        basename = relative_path_for(source_file, source)\n        excludes.any? { |exclude| File.fnmatch?(exclude, basename, File::FNM_DOTMATCH) }\n      end\n    end", "language": "ruby", "code": "def all_files_under(source, options = {})\n      excludes = Array(options[:exclude]).map do |exclude|\n        [exclude, \"#{exclude}/*\"]\n      end.flatten\n\n      source_files = glob(File.join(source, \"**/*\"))\n      source_files = source_files.reject do |source_file|\n        basename = relative_path_for(source_file, source)\n        excludes.any? { |exclude| File.fnmatch?(exclude, basename, File::FNM_DOTMATCH) }\n      end\n    end", "code_tokens": ["def", "all_files_under", "(", "source", ",", "options", "=", "{", "}", ")", "excludes", "=", "Array", "(", "options", "[", ":exclude", "]", ")", ".", "map", "do", "|", "exclude", "|", "[", "exclude", ",", "\"#{exclude}/*\"", "]", "end", ".", "flatten", "source_files", "=", "glob", "(", "File", ".", "join", "(", "source", ",", "\"**/*\"", ")", ")", "source_files", "=", "source_files", ".", "reject", "do", "|", "source_file", "|", "basename", "=", "relative_path_for", "(", "source_file", ",", "source", ")", "excludes", ".", "any?", "{", "|", "exclude", "|", "File", ".", "fnmatch?", "(", "exclude", ",", "basename", ",", "File", "::", "FNM_DOTMATCH", ")", "}", "end", "end"], "docstring": "Glob for all files under a given path/pattern, removing Ruby's\n dumb idea to include +'.'+ and +'..'+ as entries.\n\n @param [String] source\n   the path or glob pattern to get all files from\n\n @option options [String, Array<String>] :exclude\n   a file, folder, or globbing pattern of files to ignore when syncing\n\n @return [Array<String>]\n   the list of all files", "docstring_tokens": ["Glob", "for", "all", "files", "under", "a", "given", "path", "/", "pattern", "removing", "Ruby", "s", "dumb", "idea", "to", "include", "+", ".", "+", "and", "+", "..", "+", "as", "entries", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/file_syncer.rb#L57-L67", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/file_syncer.rb", "func_name": "Omnibus.FileSyncer.sync", "original_string": "def sync(source, destination, options = {})\n      unless File.directory?(source)\n        raise ArgumentError, \"`source' must be a directory, but was a \" \\\n          \"`#{File.ftype(source)}'! If you just want to sync a file, use \" \\\n          \"the `copy' method instead.\"\n      end\n\n      source_files = all_files_under(source, options)\n\n      # Ensure the destination directory exists\n      FileUtils.mkdir_p(destination) unless File.directory?(destination)\n\n      # Copy over the filtered source files\n      source_files.each do |source_file|\n        relative_path = relative_path_for(source_file, source)\n\n        # Create the parent directory\n        parent = File.join(destination, File.dirname(relative_path))\n        FileUtils.mkdir_p(parent) unless File.directory?(parent)\n\n        case File.ftype(source_file).to_sym\n        when :directory\n          FileUtils.mkdir_p(\"#{destination}/#{relative_path}\")\n        when :link\n          target = File.readlink(source_file)\n\n          Dir.chdir(destination) do\n            FileUtils.ln_sf(target, \"#{destination}/#{relative_path}\")\n          end\n        when :file\n          source_stat = File.stat(source_file)\n          # Detect 'files' which are hard links and use ln instead of cp to\n          # duplicate them, provided their source is in place already\n          if hardlink? source_stat\n            if existing = hardlink_sources[[source_stat.dev, source_stat.ino]]\n              FileUtils.ln(existing, \"#{destination}/#{relative_path}\", force: true)\n            else\n              begin\n                FileUtils.cp(source_file, \"#{destination}/#{relative_path}\")\n              rescue Errno::EACCES\n                FileUtils.cp_r(source_file, \"#{destination}/#{relative_path}\", remove_destination: true)\n              end\n              hardlink_sources.store([source_stat.dev, source_stat.ino], \"#{destination}/#{relative_path}\")\n            end\n          else\n            # First attempt a regular copy. If we don't have write\n            # permission on the File, open will probably fail with\n            # EACCES (making it hard to sync files with permission\n            # r--r--r--). Rescue this error and use cp_r's\n            # :remove_destination option.\n            begin\n              FileUtils.cp(source_file, \"#{destination}/#{relative_path}\")\n            rescue Errno::EACCES\n              FileUtils.cp_r(source_file, \"#{destination}/#{relative_path}\", remove_destination: true)\n            end\n          end\n        else\n          raise \"Unknown file type: `File.ftype(source_file)' at `#{source_file}'!\"\n        end\n      end\n\n      # Remove any files in the destination that are not in the source files\n      destination_files = glob(\"#{destination}/**/*\")\n\n      # Calculate the relative paths of files so we can compare to the\n      # source.\n      relative_source_files = source_files.map do |file|\n        relative_path_for(file, source)\n      end\n      relative_destination_files = destination_files.map do |file|\n        relative_path_for(file, destination)\n      end\n\n      # Remove any extra files that are present in the destination, but are\n      # not in the source list\n      extra_files = relative_destination_files - relative_source_files\n      extra_files.each do |file|\n        FileUtils.rm_rf(File.join(destination, file))\n      end\n\n      true\n    end", "language": "ruby", "code": "def sync(source, destination, options = {})\n      unless File.directory?(source)\n        raise ArgumentError, \"`source' must be a directory, but was a \" \\\n          \"`#{File.ftype(source)}'! If you just want to sync a file, use \" \\\n          \"the `copy' method instead.\"\n      end\n\n      source_files = all_files_under(source, options)\n\n      # Ensure the destination directory exists\n      FileUtils.mkdir_p(destination) unless File.directory?(destination)\n\n      # Copy over the filtered source files\n      source_files.each do |source_file|\n        relative_path = relative_path_for(source_file, source)\n\n        # Create the parent directory\n        parent = File.join(destination, File.dirname(relative_path))\n        FileUtils.mkdir_p(parent) unless File.directory?(parent)\n\n        case File.ftype(source_file).to_sym\n        when :directory\n          FileUtils.mkdir_p(\"#{destination}/#{relative_path}\")\n        when :link\n          target = File.readlink(source_file)\n\n          Dir.chdir(destination) do\n            FileUtils.ln_sf(target, \"#{destination}/#{relative_path}\")\n          end\n        when :file\n          source_stat = File.stat(source_file)\n          # Detect 'files' which are hard links and use ln instead of cp to\n          # duplicate them, provided their source is in place already\n          if hardlink? source_stat\n            if existing = hardlink_sources[[source_stat.dev, source_stat.ino]]\n              FileUtils.ln(existing, \"#{destination}/#{relative_path}\", force: true)\n            else\n              begin\n                FileUtils.cp(source_file, \"#{destination}/#{relative_path}\")\n              rescue Errno::EACCES\n                FileUtils.cp_r(source_file, \"#{destination}/#{relative_path}\", remove_destination: true)\n              end\n              hardlink_sources.store([source_stat.dev, source_stat.ino], \"#{destination}/#{relative_path}\")\n            end\n          else\n            # First attempt a regular copy. If we don't have write\n            # permission on the File, open will probably fail with\n            # EACCES (making it hard to sync files with permission\n            # r--r--r--). Rescue this error and use cp_r's\n            # :remove_destination option.\n            begin\n              FileUtils.cp(source_file, \"#{destination}/#{relative_path}\")\n            rescue Errno::EACCES\n              FileUtils.cp_r(source_file, \"#{destination}/#{relative_path}\", remove_destination: true)\n            end\n          end\n        else\n          raise \"Unknown file type: `File.ftype(source_file)' at `#{source_file}'!\"\n        end\n      end\n\n      # Remove any files in the destination that are not in the source files\n      destination_files = glob(\"#{destination}/**/*\")\n\n      # Calculate the relative paths of files so we can compare to the\n      # source.\n      relative_source_files = source_files.map do |file|\n        relative_path_for(file, source)\n      end\n      relative_destination_files = destination_files.map do |file|\n        relative_path_for(file, destination)\n      end\n\n      # Remove any extra files that are present in the destination, but are\n      # not in the source list\n      extra_files = relative_destination_files - relative_source_files\n      extra_files.each do |file|\n        FileUtils.rm_rf(File.join(destination, file))\n      end\n\n      true\n    end", "code_tokens": ["def", "sync", "(", "source", ",", "destination", ",", "options", "=", "{", "}", ")", "unless", "File", ".", "directory?", "(", "source", ")", "raise", "ArgumentError", ",", "\"`source' must be a directory, but was a \"", "\"`#{File.ftype(source)}'! If you just want to sync a file, use \"", "\"the `copy' method instead.\"", "end", "source_files", "=", "all_files_under", "(", "source", ",", "options", ")", "# Ensure the destination directory exists", "FileUtils", ".", "mkdir_p", "(", "destination", ")", "unless", "File", ".", "directory?", "(", "destination", ")", "# Copy over the filtered source files", "source_files", ".", "each", "do", "|", "source_file", "|", "relative_path", "=", "relative_path_for", "(", "source_file", ",", "source", ")", "# Create the parent directory", "parent", "=", "File", ".", "join", "(", "destination", ",", "File", ".", "dirname", "(", "relative_path", ")", ")", "FileUtils", ".", "mkdir_p", "(", "parent", ")", "unless", "File", ".", "directory?", "(", "parent", ")", "case", "File", ".", "ftype", "(", "source_file", ")", ".", "to_sym", "when", ":directory", "FileUtils", ".", "mkdir_p", "(", "\"#{destination}/#{relative_path}\"", ")", "when", ":link", "target", "=", "File", ".", "readlink", "(", "source_file", ")", "Dir", ".", "chdir", "(", "destination", ")", "do", "FileUtils", ".", "ln_sf", "(", "target", ",", "\"#{destination}/#{relative_path}\"", ")", "end", "when", ":file", "source_stat", "=", "File", ".", "stat", "(", "source_file", ")", "# Detect 'files' which are hard links and use ln instead of cp to", "# duplicate them, provided their source is in place already", "if", "hardlink?", "source_stat", "if", "existing", "=", "hardlink_sources", "[", "[", "source_stat", ".", "dev", ",", "source_stat", ".", "ino", "]", "]", "FileUtils", ".", "ln", "(", "existing", ",", "\"#{destination}/#{relative_path}\"", ",", "force", ":", "true", ")", "else", "begin", "FileUtils", ".", "cp", "(", "source_file", ",", "\"#{destination}/#{relative_path}\"", ")", "rescue", "Errno", "::", "EACCES", "FileUtils", ".", "cp_r", "(", "source_file", ",", "\"#{destination}/#{relative_path}\"", ",", "remove_destination", ":", "true", ")", "end", "hardlink_sources", ".", "store", "(", "[", "source_stat", ".", "dev", ",", "source_stat", ".", "ino", "]", ",", "\"#{destination}/#{relative_path}\"", ")", "end", "else", "# First attempt a regular copy. If we don't have write", "# permission on the File, open will probably fail with", "# EACCES (making it hard to sync files with permission", "# r--r--r--). Rescue this error and use cp_r's", "# :remove_destination option.", "begin", "FileUtils", ".", "cp", "(", "source_file", ",", "\"#{destination}/#{relative_path}\"", ")", "rescue", "Errno", "::", "EACCES", "FileUtils", ".", "cp_r", "(", "source_file", ",", "\"#{destination}/#{relative_path}\"", ",", "remove_destination", ":", "true", ")", "end", "end", "else", "raise", "\"Unknown file type: `File.ftype(source_file)' at `#{source_file}'!\"", "end", "end", "# Remove any files in the destination that are not in the source files", "destination_files", "=", "glob", "(", "\"#{destination}/**/*\"", ")", "# Calculate the relative paths of files so we can compare to the", "# source.", "relative_source_files", "=", "source_files", ".", "map", "do", "|", "file", "|", "relative_path_for", "(", "file", ",", "source", ")", "end", "relative_destination_files", "=", "destination_files", ".", "map", "do", "|", "file", "|", "relative_path_for", "(", "file", ",", "destination", ")", "end", "# Remove any extra files that are present in the destination, but are", "# not in the source list", "extra_files", "=", "relative_destination_files", "-", "relative_source_files", "extra_files", ".", "each", "do", "|", "file", "|", "FileUtils", ".", "rm_rf", "(", "File", ".", "join", "(", "destination", ",", "file", ")", ")", "end", "true", "end"], "docstring": "Copy the files from +source+ to +destination+, while removing any files\n in +destination+ that are not present in +source+.\n\n The method accepts an optional +:exclude+ parameter to ignore files and\n folders that match the given pattern(s). Note the exclude pattern behaves\n on paths relative to the given source. If you want to exclude a nested\n directory, you will need to use something like +**/directory+.\n\n @raise ArgumentError\n   if the +source+ parameter is not a directory\n\n @param [String] source\n   the path on disk to sync from\n @param [String] destination\n   the path on disk to sync to\n\n @option options [String, Array<String>] :exclude\n   a file, folder, or globbing pattern of files to ignore when syncing\n\n @return [true]", "docstring_tokens": ["Copy", "the", "files", "from", "+", "source", "+", "to", "+", "destination", "+", "while", "removing", "any", "files", "in", "+", "destination", "+", "that", "are", "not", "present", "in", "+", "source", "+", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/file_syncer.rb#L91-L172", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/packager.rb", "func_name": "Omnibus.Packager.for_current_system", "original_string": "def for_current_system\n      family = Ohai[\"platform_family\"]\n      version = Ohai[\"platform_version\"]\n\n      if family == \"solaris2\" && Chef::Sugar::Constraints::Version.new(version).satisfies?(\">= 5.11\")\n        family = \"ips\"\n      elsif family == \"solaris2\" && Chef::Sugar::Constraints::Version.new(version).satisfies?(\">= 5.10\")\n        family = \"solaris\"\n      end\n      if klass = PLATFORM_PACKAGER_MAP[family]\n        package_types = klass.is_a?(Array) ? klass : [ klass ]\n\n        if package_types.include?(APPX) &&\n            !Chef::Sugar::Constraints::Version.new(version).satisfies?(\">= 6.2\")\n          log.warn(log_key) { \"APPX generation is only supported on Windows versions 2012 and above\" }\n          package_types -= [APPX]\n        end\n\n        package_types\n      else\n        log.warn(log_key) do\n          \"Could not determine packager for `#{family}', defaulting \" \\\n          \"to `makeself'!\"\n        end\n        [Makeself]\n      end\n    end", "language": "ruby", "code": "def for_current_system\n      family = Ohai[\"platform_family\"]\n      version = Ohai[\"platform_version\"]\n\n      if family == \"solaris2\" && Chef::Sugar::Constraints::Version.new(version).satisfies?(\">= 5.11\")\n        family = \"ips\"\n      elsif family == \"solaris2\" && Chef::Sugar::Constraints::Version.new(version).satisfies?(\">= 5.10\")\n        family = \"solaris\"\n      end\n      if klass = PLATFORM_PACKAGER_MAP[family]\n        package_types = klass.is_a?(Array) ? klass : [ klass ]\n\n        if package_types.include?(APPX) &&\n            !Chef::Sugar::Constraints::Version.new(version).satisfies?(\">= 6.2\")\n          log.warn(log_key) { \"APPX generation is only supported on Windows versions 2012 and above\" }\n          package_types -= [APPX]\n        end\n\n        package_types\n      else\n        log.warn(log_key) do\n          \"Could not determine packager for `#{family}', defaulting \" \\\n          \"to `makeself'!\"\n        end\n        [Makeself]\n      end\n    end", "code_tokens": ["def", "for_current_system", "family", "=", "Ohai", "[", "\"platform_family\"", "]", "version", "=", "Ohai", "[", "\"platform_version\"", "]", "if", "family", "==", "\"solaris2\"", "&&", "Chef", "::", "Sugar", "::", "Constraints", "::", "Version", ".", "new", "(", "version", ")", ".", "satisfies?", "(", "\">= 5.11\"", ")", "family", "=", "\"ips\"", "elsif", "family", "==", "\"solaris2\"", "&&", "Chef", "::", "Sugar", "::", "Constraints", "::", "Version", ".", "new", "(", "version", ")", ".", "satisfies?", "(", "\">= 5.10\"", ")", "family", "=", "\"solaris\"", "end", "if", "klass", "=", "PLATFORM_PACKAGER_MAP", "[", "family", "]", "package_types", "=", "klass", ".", "is_a?", "(", "Array", ")", "?", "klass", ":", "[", "klass", "]", "if", "package_types", ".", "include?", "(", "APPX", ")", "&&", "!", "Chef", "::", "Sugar", "::", "Constraints", "::", "Version", ".", "new", "(", "version", ")", ".", "satisfies?", "(", "\">= 6.2\"", ")", "log", ".", "warn", "(", "log_key", ")", "{", "\"APPX generation is only supported on Windows versions 2012 and above\"", "}", "package_types", "-=", "[", "APPX", "]", "end", "package_types", "else", "log", ".", "warn", "(", "log_key", ")", "do", "\"Could not determine packager for `#{family}', defaulting \"", "\"to `makeself'!\"", "end", "[", "Makeself", "]", "end", "end"], "docstring": "Determine the packager(s) for the current system. This method returns the\n class, not an instance of the class.\n\n @example\n   Packager.for_current_system #=> [Packager::RPM]\n\n @return [[~Packager::Base]]", "docstring_tokens": ["Determine", "the", "packager", "(", "s", ")", "for", "the", "current", "system", ".", "This", "method", "returns", "the", "class", "not", "an", "instance", "of", "the", "class", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/packager.rb#L64-L90", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/compressors/dmg.rb", "func_name": "Omnibus.Compressor::DMG.clean_disks", "original_string": "def clean_disks\n      log.info(log_key) { \"Cleaning previously mounted disks\" }\n\n      existing_disks = shellout!(\"mount | grep \\\"/Volumes/#{volume_name}\\\" | awk '{print $1}'\")\n      existing_disks.stdout.lines.each do |existing_disk|\n        existing_disk.chomp!\n\n        Omnibus.logger.debug(log_key) do\n          \"Detaching disk `#{existing_disk}' before starting dmg packaging.\"\n        end\n\n        shellout!(\"hdiutil detach '#{existing_disk}'\")\n      end\n    end", "language": "ruby", "code": "def clean_disks\n      log.info(log_key) { \"Cleaning previously mounted disks\" }\n\n      existing_disks = shellout!(\"mount | grep \\\"/Volumes/#{volume_name}\\\" | awk '{print $1}'\")\n      existing_disks.stdout.lines.each do |existing_disk|\n        existing_disk.chomp!\n\n        Omnibus.logger.debug(log_key) do\n          \"Detaching disk `#{existing_disk}' before starting dmg packaging.\"\n        end\n\n        shellout!(\"hdiutil detach '#{existing_disk}'\")\n      end\n    end", "code_tokens": ["def", "clean_disks", "log", ".", "info", "(", "log_key", ")", "{", "\"Cleaning previously mounted disks\"", "}", "existing_disks", "=", "shellout!", "(", "\"mount | grep \\\"/Volumes/#{volume_name}\\\" | awk '{print $1}'\"", ")", "existing_disks", ".", "stdout", ".", "lines", ".", "each", "do", "|", "existing_disk", "|", "existing_disk", ".", "chomp!", "Omnibus", ".", "logger", ".", "debug", "(", "log_key", ")", "do", "\"Detaching disk `#{existing_disk}' before starting dmg packaging.\"", "end", "shellout!", "(", "\"hdiutil detach '#{existing_disk}'\"", ")", "end", "end"], "docstring": "Cleans any previously left over mounted disks.\n\n We are trying to detach disks that look like:\n\n   /dev/disk1s1 on /Volumes/chef (hfs, local, nodev, nosuid, read-only, noowners, quarantine, mounted by serdar)\n   /dev/disk2s1 on /Volumes/chef 1 (hfs, local, nodev, nosuid, read-only, noowners, quarantine, mounted by serdar)\n\n @return [void]", "docstring_tokens": ["Cleans", "any", "previously", "left", "over", "mounted", "disks", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/compressors/dmg.rb#L119-L132", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/compressors/dmg.rb", "func_name": "Omnibus.Compressor::DMG.attach_dmg", "original_string": "def attach_dmg\n      @device ||= Dir.chdir(staging_dir) do\n        log.info(log_key) { \"Attaching dmg as disk\" }\n\n        cmd = shellout! <<-EOH.gsub(/^ {10}/, \"\")\n          hdiutil attach \\\\\n            -readwrite \\\\\n            -noverify \\\\\n            -noautoopen \\\\\n            \"#{writable_dmg}\" | egrep '^/dev/' | sed 1q | awk '{print $1}'\n        EOH\n\n        cmd.stdout.strip\n      end\n    end", "language": "ruby", "code": "def attach_dmg\n      @device ||= Dir.chdir(staging_dir) do\n        log.info(log_key) { \"Attaching dmg as disk\" }\n\n        cmd = shellout! <<-EOH.gsub(/^ {10}/, \"\")\n          hdiutil attach \\\\\n            -readwrite \\\\\n            -noverify \\\\\n            -noautoopen \\\\\n            \"#{writable_dmg}\" | egrep '^/dev/' | sed 1q | awk '{print $1}'\n        EOH\n\n        cmd.stdout.strip\n      end\n    end", "code_tokens": ["def", "attach_dmg", "@device", "||=", "Dir", ".", "chdir", "(", "staging_dir", ")", "do", "log", ".", "info", "(", "log_key", ")", "{", "\"Attaching dmg as disk\"", "}", "cmd", "=", "shellout!", "<<-EOH", ".", "gsub", "(", "/", "/", ",", "\"\"", ")", "\\\\", "\\\\", "\\\\", "\\\\", "#{", "writable_dmg", "}", "EOH", "cmd", ".", "stdout", ".", "strip", "end", "end"], "docstring": "Attach the dmg, storing a reference to the device for later use.\n\n @return [String]\n   the name of the attached device", "docstring_tokens": ["Attach", "the", "dmg", "storing", "a", "reference", "to", "the", "device", "for", "later", "use", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/compressors/dmg.rb#L156-L170", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/compressors/dmg.rb", "func_name": "Omnibus.Compressor::DMG.copy_assets_to_dmg", "original_string": "def copy_assets_to_dmg\n      log.info(log_key) { \"Copying assets into dmg\" }\n\n      FileSyncer.glob(\"#{resources_dir}/*\").each do |file|\n        FileUtils.cp_r(file, \"/Volumes/#{volume_name}\")\n      end\n    end", "language": "ruby", "code": "def copy_assets_to_dmg\n      log.info(log_key) { \"Copying assets into dmg\" }\n\n      FileSyncer.glob(\"#{resources_dir}/*\").each do |file|\n        FileUtils.cp_r(file, \"/Volumes/#{volume_name}\")\n      end\n    end", "code_tokens": ["def", "copy_assets_to_dmg", "log", ".", "info", "(", "log_key", ")", "{", "\"Copying assets into dmg\"", "}", "FileSyncer", ".", "glob", "(", "\"#{resources_dir}/*\"", ")", ".", "each", "do", "|", "file", "|", "FileUtils", ".", "cp_r", "(", "file", ",", "\"/Volumes/#{volume_name}\"", ")", "end", "end"], "docstring": "Copy assets to dmg", "docstring_tokens": ["Copy", "assets", "to", "dmg"], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/compressors/dmg.rb#L175-L181", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/packagers/ips.rb", "func_name": "Omnibus.Packager::IPS.write_transform_file", "original_string": "def write_transform_file\n      render_template(resource_path(\"doc-transform.erb\"),\n        destination: transform_file,\n        variables: {\n          pathdir: project.install_dir.split(\"/\")[1],\n        }\n      )\n    end", "language": "ruby", "code": "def write_transform_file\n      render_template(resource_path(\"doc-transform.erb\"),\n        destination: transform_file,\n        variables: {\n          pathdir: project.install_dir.split(\"/\")[1],\n        }\n      )\n    end", "code_tokens": ["def", "write_transform_file", "render_template", "(", "resource_path", "(", "\"doc-transform.erb\"", ")", ",", "destination", ":", "transform_file", ",", "variables", ":", "{", "pathdir", ":", "project", ".", "install_dir", ".", "split", "(", "\"/\"", ")", "[", "1", "]", ",", "}", ")", "end"], "docstring": "A set of transform rules that `pkgmogrify' will apply to the package\n manifest.\n\n @return [void]", "docstring_tokens": ["A", "set", "of", "transform", "rules", "that", "pkgmogrify", "will", "apply", "to", "the", "package", "manifest", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/packagers/ips.rb#L207-L214", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/packagers/ips.rb", "func_name": "Omnibus.Packager::IPS.write_pkg_metadata", "original_string": "def write_pkg_metadata\n      render_template(resource_path(\"gen.manifestfile.erb\"),\n        destination: pkg_metadata_file,\n        variables: {\n          name: safe_base_package_name,\n          fmri_package_name: fmri_package_name,\n          description: project.description,\n          summary: project.friendly_name,\n          arch: safe_architecture,\n        }\n      )\n\n      # Append the contents of symlinks_file if it exists\n      if symlinks_file\n        File.open(pkg_metadata_file, \"a\") do |symlink|\n          symlink.write(render_symlinks)\n        end\n      end\n\n      # Print the full contents of the rendered template file to generate package contents\n      log.debug(log_key) { \"Rendered Template:\\n\" + File.read(pkg_metadata_file) }\n    end", "language": "ruby", "code": "def write_pkg_metadata\n      render_template(resource_path(\"gen.manifestfile.erb\"),\n        destination: pkg_metadata_file,\n        variables: {\n          name: safe_base_package_name,\n          fmri_package_name: fmri_package_name,\n          description: project.description,\n          summary: project.friendly_name,\n          arch: safe_architecture,\n        }\n      )\n\n      # Append the contents of symlinks_file if it exists\n      if symlinks_file\n        File.open(pkg_metadata_file, \"a\") do |symlink|\n          symlink.write(render_symlinks)\n        end\n      end\n\n      # Print the full contents of the rendered template file to generate package contents\n      log.debug(log_key) { \"Rendered Template:\\n\" + File.read(pkg_metadata_file) }\n    end", "code_tokens": ["def", "write_pkg_metadata", "render_template", "(", "resource_path", "(", "\"gen.manifestfile.erb\"", ")", ",", "destination", ":", "pkg_metadata_file", ",", "variables", ":", "{", "name", ":", "safe_base_package_name", ",", "fmri_package_name", ":", "fmri_package_name", ",", "description", ":", "project", ".", "description", ",", "summary", ":", "project", ".", "friendly_name", ",", "arch", ":", "safe_architecture", ",", "}", ")", "# Append the contents of symlinks_file if it exists", "if", "symlinks_file", "File", ".", "open", "(", "pkg_metadata_file", ",", "\"a\"", ")", "do", "|", "symlink", "|", "symlink", ".", "write", "(", "render_symlinks", ")", "end", "end", "# Print the full contents of the rendered template file to generate package contents", "log", ".", "debug", "(", "log_key", ")", "{", "\"Rendered Template:\\n\"", "+", "File", ".", "read", "(", "pkg_metadata_file", ")", "}", "end"], "docstring": "Generate package metadata\n\n Create the gen template for `pkgmogrify`\n\n @return [void]", "docstring_tokens": ["Generate", "package", "metadata"], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/packagers/ips.rb#L256-L277", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/packagers/ips.rb", "func_name": "Omnibus.Packager::IPS.publish_ips_pkg", "original_string": "def publish_ips_pkg\n      shellout!(\"pkgrepo -s #{repo_dir} set publisher/prefix=#{publisher_prefix}\")\n      shellout!(\"pkgsend publish -s #{repo_dir} -d #{source_dir} #{pkg_manifest_file}.5.res\")\n      log.info(log_key) { \"Published IPS package to repo: #{repo_dir}\" }\n\n      repo_info = shellout(\"pkg list -afv -g #{repo_dir}\").stdout\n      log.debug(log_key) do\n        <<-EOH.strip\n          Published IPS package:\n\n            #{repo_info}\n        EOH\n      end\n    end", "language": "ruby", "code": "def publish_ips_pkg\n      shellout!(\"pkgrepo -s #{repo_dir} set publisher/prefix=#{publisher_prefix}\")\n      shellout!(\"pkgsend publish -s #{repo_dir} -d #{source_dir} #{pkg_manifest_file}.5.res\")\n      log.info(log_key) { \"Published IPS package to repo: #{repo_dir}\" }\n\n      repo_info = shellout(\"pkg list -afv -g #{repo_dir}\").stdout\n      log.debug(log_key) do\n        <<-EOH.strip\n          Published IPS package:\n\n            #{repo_info}\n        EOH\n      end\n    end", "code_tokens": ["def", "publish_ips_pkg", "shellout!", "(", "\"pkgrepo -s #{repo_dir} set publisher/prefix=#{publisher_prefix}\"", ")", "shellout!", "(", "\"pkgsend publish -s #{repo_dir} -d #{source_dir} #{pkg_manifest_file}.5.res\"", ")", "log", ".", "info", "(", "log_key", ")", "{", "\"Published IPS package to repo: #{repo_dir}\"", "}", "repo_info", "=", "shellout", "(", "\"pkg list -afv -g #{repo_dir}\"", ")", ".", "stdout", "log", ".", "debug", "(", "log_key", ")", "do", "<<-EOH", ".", "strip", "#{", "repo_info", "}", "EOH", "end", "end"], "docstring": "Publish the IPS pkg into the local IPS repo\n\n @return [void]", "docstring_tokens": ["Publish", "the", "IPS", "pkg", "into", "the", "local", "IPS", "repo"], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/packagers/ips.rb#L326-L339", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/health_check.rb", "func_name": "Omnibus.HealthCheck.relocation_check", "original_string": "def relocation_check\n      conflict_map = {}\n\n      embedded_bin = \"#{project.install_dir}/embedded/bin\"\n      Dir.glob(\"#{embedded_bin}/*.dll\") do |lib_path|\n        log.debug(log_key) { \"Analyzing dependencies for #{lib_path}\" }\n\n        File.open(lib_path, \"rb\") do |f|\n          dump = PEdump.new(lib_path)\n          pe = dump.pe f\n\n          # Don't scan dlls for a different architecture.\n          next if windows_arch_i386? == pe.x64?\n\n          lib_name = File.basename(lib_path)\n          base = pe.ioh.ImageBase\n          size = pe.ioh.SizeOfImage\n          conflicts = []\n\n          # This can be done more smartly but O(n^2) is just fine for n = small\n          conflict_map.each do |candidate_name, details|\n            unless details[:base] >= base + size ||\n                details[:base] + details[:size] <= base\n              details[:conflicts] << lib_name\n              conflicts << candidate_name\n            end\n          end\n\n          conflict_map[lib_name] = {\n            base: base,\n            size: size,\n            conflicts: conflicts,\n          }\n\n          log.debug(log_key) { \"Discovered #{lib_name} at #{hex} + #{hex}\" % [ base, size ] }\n        end\n      end\n\n      # Filter out non-conflicting entries.\n      conflict_map.delete_if do |lib_name, details|\n        details[:conflicts].empty?\n      end\n    end", "language": "ruby", "code": "def relocation_check\n      conflict_map = {}\n\n      embedded_bin = \"#{project.install_dir}/embedded/bin\"\n      Dir.glob(\"#{embedded_bin}/*.dll\") do |lib_path|\n        log.debug(log_key) { \"Analyzing dependencies for #{lib_path}\" }\n\n        File.open(lib_path, \"rb\") do |f|\n          dump = PEdump.new(lib_path)\n          pe = dump.pe f\n\n          # Don't scan dlls for a different architecture.\n          next if windows_arch_i386? == pe.x64?\n\n          lib_name = File.basename(lib_path)\n          base = pe.ioh.ImageBase\n          size = pe.ioh.SizeOfImage\n          conflicts = []\n\n          # This can be done more smartly but O(n^2) is just fine for n = small\n          conflict_map.each do |candidate_name, details|\n            unless details[:base] >= base + size ||\n                details[:base] + details[:size] <= base\n              details[:conflicts] << lib_name\n              conflicts << candidate_name\n            end\n          end\n\n          conflict_map[lib_name] = {\n            base: base,\n            size: size,\n            conflicts: conflicts,\n          }\n\n          log.debug(log_key) { \"Discovered #{lib_name} at #{hex} + #{hex}\" % [ base, size ] }\n        end\n      end\n\n      # Filter out non-conflicting entries.\n      conflict_map.delete_if do |lib_name, details|\n        details[:conflicts].empty?\n      end\n    end", "code_tokens": ["def", "relocation_check", "conflict_map", "=", "{", "}", "embedded_bin", "=", "\"#{project.install_dir}/embedded/bin\"", "Dir", ".", "glob", "(", "\"#{embedded_bin}/*.dll\"", ")", "do", "|", "lib_path", "|", "log", ".", "debug", "(", "log_key", ")", "{", "\"Analyzing dependencies for #{lib_path}\"", "}", "File", ".", "open", "(", "lib_path", ",", "\"rb\"", ")", "do", "|", "f", "|", "dump", "=", "PEdump", ".", "new", "(", "lib_path", ")", "pe", "=", "dump", ".", "pe", "f", "# Don't scan dlls for a different architecture.", "next", "if", "windows_arch_i386?", "==", "pe", ".", "x64?", "lib_name", "=", "File", ".", "basename", "(", "lib_path", ")", "base", "=", "pe", ".", "ioh", ".", "ImageBase", "size", "=", "pe", ".", "ioh", ".", "SizeOfImage", "conflicts", "=", "[", "]", "# This can be done more smartly but O(n^2) is just fine for n = small", "conflict_map", ".", "each", "do", "|", "candidate_name", ",", "details", "|", "unless", "details", "[", ":base", "]", ">=", "base", "+", "size", "||", "details", "[", ":base", "]", "+", "details", "[", ":size", "]", "<=", "base", "details", "[", ":conflicts", "]", "<<", "lib_name", "conflicts", "<<", "candidate_name", "end", "end", "conflict_map", "[", "lib_name", "]", "=", "{", "base", ":", "base", ",", "size", ":", "size", ",", "conflicts", ":", "conflicts", ",", "}", "log", ".", "debug", "(", "log_key", ")", "{", "\"Discovered #{lib_name} at #{hex} + #{hex}\"", "%", "[", "base", ",", "size", "]", "}", "end", "end", "# Filter out non-conflicting entries.", "conflict_map", ".", "delete_if", "do", "|", "lib_name", ",", "details", "|", "details", "[", ":conflicts", "]", ".", "empty?", "end", "end"], "docstring": "Check dll image location overlap/conflicts on windows.\n\n @return [Hash<String, Hash<Symbol, ...>>]\n   library_name ->\n     :base -> base address\n     :size -> the total image size in bytes\n     :conflicts -> array of library names that overlap", "docstring_tokens": ["Check", "dll", "image", "location", "overlap", "/", "conflicts", "on", "windows", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/health_check.rb#L230-L272", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/health_check.rb", "func_name": "Omnibus.HealthCheck.health_check_otool", "original_string": "def health_check_otool\n      current_library = nil\n      bad_libs = {}\n\n      read_shared_libs(\"find #{project.install_dir}/ -type f | egrep '\\.(dylib|bundle)$' | xargs otool -L\") do |line|\n        case line\n        when /^(.+):$/\n          current_library = Regexp.last_match[1]\n        when /^\\s+(.+) \\(.+\\)$/\n          linked = Regexp.last_match[1]\n          name = File.basename(linked)\n          bad_libs = check_for_bad_library(bad_libs, current_library, name, linked)\n        end\n      end\n\n      bad_libs\n    end", "language": "ruby", "code": "def health_check_otool\n      current_library = nil\n      bad_libs = {}\n\n      read_shared_libs(\"find #{project.install_dir}/ -type f | egrep '\\.(dylib|bundle)$' | xargs otool -L\") do |line|\n        case line\n        when /^(.+):$/\n          current_library = Regexp.last_match[1]\n        when /^\\s+(.+) \\(.+\\)$/\n          linked = Regexp.last_match[1]\n          name = File.basename(linked)\n          bad_libs = check_for_bad_library(bad_libs, current_library, name, linked)\n        end\n      end\n\n      bad_libs\n    end", "code_tokens": ["def", "health_check_otool", "current_library", "=", "nil", "bad_libs", "=", "{", "}", "read_shared_libs", "(", "\"find #{project.install_dir}/ -type f | egrep '\\.(dylib|bundle)$' | xargs otool -L\"", ")", "do", "|", "line", "|", "case", "line", "when", "/", "/", "current_library", "=", "Regexp", ".", "last_match", "[", "1", "]", "when", "/", "\\s", "\\(", "\\)", "/", "linked", "=", "Regexp", ".", "last_match", "[", "1", "]", "name", "=", "File", ".", "basename", "(", "linked", ")", "bad_libs", "=", "check_for_bad_library", "(", "bad_libs", ",", "current_library", ",", "name", ",", "linked", ")", "end", "end", "bad_libs", "end"], "docstring": "Run healthchecks against otool.\n\n @return [Hash<String, Hash<String, Hash<String, Int>>>]\n   the bad libraries (library_name -> dependency_name -> satisfied_lib_path -> count)", "docstring_tokens": ["Run", "healthchecks", "against", "otool", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/health_check.rb#L280-L296", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/health_check.rb", "func_name": "Omnibus.HealthCheck.health_check_aix", "original_string": "def health_check_aix\n      current_library = nil\n      bad_libs = {}\n\n      read_shared_libs(\"find #{project.install_dir}/ -type f | xargs file | grep \\\"RISC System\\\" | awk -F: '{print $1}' | xargs -n 1 ldd\") do |line|\n        case line\n        when /^(.+) needs:$/\n          current_library = Regexp.last_match[1]\n          log.debug(log_key) { \"Analyzing dependencies for #{current_library}\" }\n        when /^\\s+(.+)$/\n          name = Regexp.last_match[1]\n          linked = Regexp.last_match[1]\n          bad_libs = check_for_bad_library(bad_libs, current_library, name, linked)\n        when /File is not an executable XCOFF file/ # ignore non-executable files\n        else\n          log.warn(log_key) { \"Line did not match for #{current_library}\\n#{line}\" }\n        end\n      end\n\n      bad_libs\n    end", "language": "ruby", "code": "def health_check_aix\n      current_library = nil\n      bad_libs = {}\n\n      read_shared_libs(\"find #{project.install_dir}/ -type f | xargs file | grep \\\"RISC System\\\" | awk -F: '{print $1}' | xargs -n 1 ldd\") do |line|\n        case line\n        when /^(.+) needs:$/\n          current_library = Regexp.last_match[1]\n          log.debug(log_key) { \"Analyzing dependencies for #{current_library}\" }\n        when /^\\s+(.+)$/\n          name = Regexp.last_match[1]\n          linked = Regexp.last_match[1]\n          bad_libs = check_for_bad_library(bad_libs, current_library, name, linked)\n        when /File is not an executable XCOFF file/ # ignore non-executable files\n        else\n          log.warn(log_key) { \"Line did not match for #{current_library}\\n#{line}\" }\n        end\n      end\n\n      bad_libs\n    end", "code_tokens": ["def", "health_check_aix", "current_library", "=", "nil", "bad_libs", "=", "{", "}", "read_shared_libs", "(", "\"find #{project.install_dir}/ -type f | xargs file | grep \\\"RISC System\\\" | awk -F: '{print $1}' | xargs -n 1 ldd\"", ")", "do", "|", "line", "|", "case", "line", "when", "/", "/", "current_library", "=", "Regexp", ".", "last_match", "[", "1", "]", "log", ".", "debug", "(", "log_key", ")", "{", "\"Analyzing dependencies for #{current_library}\"", "}", "when", "/", "\\s", "/", "name", "=", "Regexp", ".", "last_match", "[", "1", "]", "linked", "=", "Regexp", ".", "last_match", "[", "1", "]", "bad_libs", "=", "check_for_bad_library", "(", "bad_libs", ",", "current_library", ",", "name", ",", "linked", ")", "when", "/", "/", "# ignore non-executable files", "else", "log", ".", "warn", "(", "log_key", ")", "{", "\"Line did not match for #{current_library}\\n#{line}\"", "}", "end", "end", "bad_libs", "end"], "docstring": "Run healthchecks against aix.\n\n @return [Hash<String, Hash<String, Hash<String, Int>>>]\n   the bad libraries (library_name -> dependency_name -> satisfied_lib_path -> count)", "docstring_tokens": ["Run", "healthchecks", "against", "aix", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/health_check.rb#L304-L324", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/digestable.rb", "func_name": "Omnibus.Digestable.digest", "original_string": "def digest(path, type = :md5)\n      digest = digest_from_type(type)\n\n      update_with_file_contents(digest, path)\n      digest.hexdigest\n    end", "language": "ruby", "code": "def digest(path, type = :md5)\n      digest = digest_from_type(type)\n\n      update_with_file_contents(digest, path)\n      digest.hexdigest\n    end", "code_tokens": ["def", "digest", "(", "path", ",", "type", "=", ":md5", ")", "digest", "=", "digest_from_type", "(", "type", ")", "update_with_file_contents", "(", "digest", ",", "path", ")", "digest", ".", "hexdigest", "end"], "docstring": "Calculate the digest of the file at the given path. Files are read in\n binary chunks to prevent Ruby from exploding.\n\n @param [String] path\n   the path of the file to digest\n @param [Symbol] type\n   the type of digest to use\n\n @return [String]\n   the hexdigest of the file at the path", "docstring_tokens": ["Calculate", "the", "digest", "of", "the", "file", "at", "the", "given", "path", ".", "Files", "are", "read", "in", "binary", "chunks", "to", "prevent", "Ruby", "from", "exploding", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/digestable.rb#L40-L45", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/digestable.rb", "func_name": "Omnibus.Digestable.digest_directory", "original_string": "def digest_directory(path, type = :md5, options = {})\n      digest = digest_from_type(type)\n      log.info(log_key) { \"Digesting #{path} with #{type}\" }\n      FileSyncer.all_files_under(path, options).each do |filename|\n        # Calculate the filename relative to the given path. Since directories\n        # are SHAed according to their filepath, two difference directories on\n        # disk would have different SHAs even if they had the same content.\n        relative = Pathname.new(filename).relative_path_from(Pathname.new(path))\n\n        case ftype = File.ftype(filename)\n        when \"file\"\n          update_with_string(digest, \"#{ftype} #{relative}\")\n          update_with_file_contents(digest, filename)\n        else\n          update_with_string(digest, \"#{ftype} #{relative}\")\n        end\n      end\n\n      digest.hexdigest\n    end", "language": "ruby", "code": "def digest_directory(path, type = :md5, options = {})\n      digest = digest_from_type(type)\n      log.info(log_key) { \"Digesting #{path} with #{type}\" }\n      FileSyncer.all_files_under(path, options).each do |filename|\n        # Calculate the filename relative to the given path. Since directories\n        # are SHAed according to their filepath, two difference directories on\n        # disk would have different SHAs even if they had the same content.\n        relative = Pathname.new(filename).relative_path_from(Pathname.new(path))\n\n        case ftype = File.ftype(filename)\n        when \"file\"\n          update_with_string(digest, \"#{ftype} #{relative}\")\n          update_with_file_contents(digest, filename)\n        else\n          update_with_string(digest, \"#{ftype} #{relative}\")\n        end\n      end\n\n      digest.hexdigest\n    end", "code_tokens": ["def", "digest_directory", "(", "path", ",", "type", "=", ":md5", ",", "options", "=", "{", "}", ")", "digest", "=", "digest_from_type", "(", "type", ")", "log", ".", "info", "(", "log_key", ")", "{", "\"Digesting #{path} with #{type}\"", "}", "FileSyncer", ".", "all_files_under", "(", "path", ",", "options", ")", ".", "each", "do", "|", "filename", "|", "# Calculate the filename relative to the given path. Since directories", "# are SHAed according to their filepath, two difference directories on", "# disk would have different SHAs even if they had the same content.", "relative", "=", "Pathname", ".", "new", "(", "filename", ")", ".", "relative_path_from", "(", "Pathname", ".", "new", "(", "path", ")", ")", "case", "ftype", "=", "File", ".", "ftype", "(", "filename", ")", "when", "\"file\"", "update_with_string", "(", "digest", ",", "\"#{ftype} #{relative}\"", ")", "update_with_file_contents", "(", "digest", ",", "filename", ")", "else", "update_with_string", "(", "digest", ",", "\"#{ftype} #{relative}\"", ")", "end", "end", "digest", ".", "hexdigest", "end"], "docstring": "Calculate the digest of a directory at the given path. Each file in the\n directory is read in binary chunks to prevent excess memory usage.\n Filesystem entries of all types are included in the digest, including\n directories, links, and sockets. The contents of non-file entries are\n represented as:\n\n   $type $path\n\n while the contents of regular files are represented as:\n\n   file $path\n\n and then appended by the binary contents of the file/\n\n @param [String] path\n   the path of the directory to digest\n @param [Symbol] type\n   the type of digest to use\n @param [Hash] options\n   options to pass through to the FileSyncer when scanning for files\n\n @return [String]\n   the hexdigest of the directory", "docstring_tokens": ["Calculate", "the", "digest", "of", "a", "directory", "at", "the", "given", "path", ".", "Each", "file", "in", "the", "directory", "is", "read", "in", "binary", "chunks", "to", "prevent", "excess", "memory", "usage", ".", "Filesystem", "entries", "of", "all", "types", "are", "included", "in", "the", "digest", "including", "directories", "links", "and", "sockets", ".", "The", "contents", "of", "non", "-", "file", "entries", "are", "represented", "as", ":"], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/digestable.rb#L72-L91", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/digestable.rb", "func_name": "Omnibus.Digestable.digest_from_type", "original_string": "def digest_from_type(type)\n      id = type.to_s.upcase\n      instance = OpenSSL::Digest.const_get(id).new\n    end", "language": "ruby", "code": "def digest_from_type(type)\n      id = type.to_s.upcase\n      instance = OpenSSL::Digest.const_get(id).new\n    end", "code_tokens": ["def", "digest_from_type", "(", "type", ")", "id", "=", "type", ".", "to_s", ".", "upcase", "instance", "=", "OpenSSL", "::", "Digest", ".", "const_get", "(", "id", ")", ".", "new", "end"], "docstring": "Create a new instance of the {Digest} class that corresponds to the given\n type.\n\n @param [#to_s] type\n   the type of digest to use\n\n @return [~Digest]\n   an instance of the digest class", "docstring_tokens": ["Create", "a", "new", "instance", "of", "the", "{", "Digest", "}", "class", "that", "corresponds", "to", "the", "given", "type", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/digestable.rb#L105-L108", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/packagers/pkg.rb", "func_name": "Omnibus.Packager::PKG.build_component_pkg", "original_string": "def build_component_pkg\n      command = <<-EOH.gsub(/^ {8}/, \"\")\n        pkgbuild \\\\\n          --identifier \"#{safe_identifier}\" \\\\\n          --version \"#{safe_version}\" \\\\\n          --scripts \"#{scripts_dir}\" \\\\\n          --root \"#{project.install_dir}\" \\\\\n          --install-location \"#{project.install_dir}\" \\\\\n          \"#{component_pkg}\"\n      EOH\n\n      Dir.chdir(staging_dir) do\n        shellout!(command)\n      end\n    end", "language": "ruby", "code": "def build_component_pkg\n      command = <<-EOH.gsub(/^ {8}/, \"\")\n        pkgbuild \\\\\n          --identifier \"#{safe_identifier}\" \\\\\n          --version \"#{safe_version}\" \\\\\n          --scripts \"#{scripts_dir}\" \\\\\n          --root \"#{project.install_dir}\" \\\\\n          --install-location \"#{project.install_dir}\" \\\\\n          \"#{component_pkg}\"\n      EOH\n\n      Dir.chdir(staging_dir) do\n        shellout!(command)\n      end\n    end", "code_tokens": ["def", "build_component_pkg", "command", "=", "<<-EOH", ".", "gsub", "(", "/", "/", ",", "\"\"", ")", "\\\\", "#{", "safe_identifier", "}", "\\\\", "#{", "safe_version", "}", "\\\\", "#{", "scripts_dir", "}", "\\\\", "#{", "project", ".", "install_dir", "}", "\\\\", "#{", "project", ".", "install_dir", "}", "\\\\", "#{", "component_pkg", "}", "EOH", "Dir", ".", "chdir", "(", "staging_dir", ")", "do", "shellout!", "(", "command", ")", "end", "end"], "docstring": "Construct the intermediate build product. It can be installed with the\n Installer.app, but doesn't contain the data needed to customize the\n installer UI.\n\n @return [void]", "docstring_tokens": ["Construct", "the", "intermediate", "build", "product", ".", "It", "can", "be", "installed", "with", "the", "Installer", ".", "app", "but", "doesn", "t", "contain", "the", "data", "needed", "to", "customize", "the", "installer", "UI", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/packagers/pkg.rb#L189-L203", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/packagers/pkg.rb", "func_name": "Omnibus.Packager::PKG.write_distribution_file", "original_string": "def write_distribution_file\n      render_template(resource_path(\"distribution.xml.erb\"),\n        destination: \"#{staging_dir}/Distribution\",\n        mode: 0600,\n        variables: {\n          friendly_name: project.friendly_name,\n          identifier: safe_identifier,\n          version: safe_version,\n          component_pkg: component_pkg,\n        }\n      )\n    end", "language": "ruby", "code": "def write_distribution_file\n      render_template(resource_path(\"distribution.xml.erb\"),\n        destination: \"#{staging_dir}/Distribution\",\n        mode: 0600,\n        variables: {\n          friendly_name: project.friendly_name,\n          identifier: safe_identifier,\n          version: safe_version,\n          component_pkg: component_pkg,\n        }\n      )\n    end", "code_tokens": ["def", "write_distribution_file", "render_template", "(", "resource_path", "(", "\"distribution.xml.erb\"", ")", ",", "destination", ":", "\"#{staging_dir}/Distribution\"", ",", "mode", ":", "0600", ",", "variables", ":", "{", "friendly_name", ":", "project", ".", "friendly_name", ",", "identifier", ":", "safe_identifier", ",", "version", ":", "safe_version", ",", "component_pkg", ":", "component_pkg", ",", "}", ")", "end"], "docstring": "Write the Distribution file to the staging area. This method generates the\n content of the Distribution file, which is used by +productbuild+ to\n select the component packages to include in the product package.\n\n It also includes information used to customize the UI of the Mac OS X\n installer.\n\n @return [void]", "docstring_tokens": ["Write", "the", "Distribution", "file", "to", "the", "staging", "area", ".", "This", "method", "generates", "the", "content", "of", "the", "Distribution", "file", "which", "is", "used", "by", "+", "productbuild", "+", "to", "select", "the", "component", "packages", "to", "include", "in", "the", "product", "package", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/packagers/pkg.rb#L215-L226", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/packagers/pkg.rb", "func_name": "Omnibus.Packager::PKG.build_product_pkg", "original_string": "def build_product_pkg\n      command = <<-EOH.gsub(/^ {8}/, \"\")\n        productbuild \\\\\n          --distribution \"#{staging_dir}/Distribution\" \\\\\n          --resources \"#{resources_dir}\" \\\\\n      EOH\n\n      command << %Q{  --sign \"#{signing_identity}\" \\\\\\n} if signing_identity\n      command << %Q{  \"#{final_pkg}\"}\n      command << %Q{\\n}\n\n      Dir.chdir(staging_dir) do\n        shellout!(command)\n      end\n    end", "language": "ruby", "code": "def build_product_pkg\n      command = <<-EOH.gsub(/^ {8}/, \"\")\n        productbuild \\\\\n          --distribution \"#{staging_dir}/Distribution\" \\\\\n          --resources \"#{resources_dir}\" \\\\\n      EOH\n\n      command << %Q{  --sign \"#{signing_identity}\" \\\\\\n} if signing_identity\n      command << %Q{  \"#{final_pkg}\"}\n      command << %Q{\\n}\n\n      Dir.chdir(staging_dir) do\n        shellout!(command)\n      end\n    end", "code_tokens": ["def", "build_product_pkg", "command", "=", "<<-EOH", ".", "gsub", "(", "/", "/", ",", "\"\"", ")", "\\\\", "#{", "staging_dir", "}", "\\\\", "#{", "resources_dir", "}", "\\\\", "EOH", "command", "<<", "%Q{  --sign \"#{signing_identity}\" \\\\\\n}", "if", "signing_identity", "command", "<<", "%Q{  \"#{final_pkg}\"}", "command", "<<", "%Q{\\n}", "Dir", ".", "chdir", "(", "staging_dir", ")", "do", "shellout!", "(", "command", ")", "end", "end"], "docstring": "Construct the product package. The generated package is the final build\n product that is shipped to end users.\n\n @return [void]", "docstring_tokens": ["Construct", "the", "product", "package", ".", "The", "generated", "package", "is", "the", "final", "build", "product", "that", "is", "shipped", "to", "end", "users", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/packagers/pkg.rb#L234-L248", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/publishers/artifactory_publisher.rb", "func_name": "Omnibus.ArtifactoryPublisher.artifact_for", "original_string": "def artifact_for(artifact)\n      md5  = artifact.respond_to?(:metadata) ? artifact.metadata[:md5] : digest(artifact.path, :md5)\n      sha1 = artifact.respond_to?(:metadata) ? artifact.metadata[:sha1] : digest(artifact.path, :sha1)\n\n      Artifactory::Resource::Artifact.new(\n        local_path: artifact.path,\n        client:     client,\n        checksums: {\n          \"md5\" => md5,\n          \"sha1\" => sha1,\n        }\n      )\n    end", "language": "ruby", "code": "def artifact_for(artifact)\n      md5  = artifact.respond_to?(:metadata) ? artifact.metadata[:md5] : digest(artifact.path, :md5)\n      sha1 = artifact.respond_to?(:metadata) ? artifact.metadata[:sha1] : digest(artifact.path, :sha1)\n\n      Artifactory::Resource::Artifact.new(\n        local_path: artifact.path,\n        client:     client,\n        checksums: {\n          \"md5\" => md5,\n          \"sha1\" => sha1,\n        }\n      )\n    end", "code_tokens": ["def", "artifact_for", "(", "artifact", ")", "md5", "=", "artifact", ".", "respond_to?", "(", ":metadata", ")", "?", "artifact", ".", "metadata", "[", ":md5", "]", ":", "digest", "(", "artifact", ".", "path", ",", ":md5", ")", "sha1", "=", "artifact", ".", "respond_to?", "(", ":metadata", ")", "?", "artifact", ".", "metadata", "[", ":sha1", "]", ":", "digest", "(", "artifact", ".", "path", ",", ":sha1", ")", "Artifactory", "::", "Resource", "::", "Artifact", ".", "new", "(", "local_path", ":", "artifact", ".", "path", ",", "client", ":", "client", ",", "checksums", ":", "{", "\"md5\"", "=>", "md5", ",", "\"sha1\"", "=>", "sha1", ",", "}", ")", "end"], "docstring": "The artifact object that corresponds to this package.\n\n @param [Package,Metadata] artifact\n   the package or metadata file to create the artifact from\n\n @return [Artifactory::Resource::Artifact]", "docstring_tokens": ["The", "artifact", "object", "that", "corresponds", "to", "this", "package", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/publishers/artifactory_publisher.rb#L90-L102", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/publishers/artifactory_publisher.rb", "func_name": "Omnibus.ArtifactoryPublisher.build_for", "original_string": "def build_for(packages)\n      metadata = packages.first.metadata\n      name     = metadata[:name]\n\n      # Attempt to load the version manifest data from the packages metadata\n      manifest = if version_manifest = metadata[:version_manifest]\n                   Manifest.from_hash(version_manifest)\n                 else\n                   Manifest.new(\n                     metadata[:version],\n                     # we already know the `version_manifest` entry is\n                     # missing so we can't pull in the `build_git_revision`\n                     nil,\n                     metadata[:license]\n                   )\n                 end\n\n      # Upload the actual package\n      log.info(log_key) { \"Saving build info for #{name}, Build ##{manifest.build_version}\" }\n\n      Artifactory::Resource::Build.new(\n        client: client,\n        name:   name,\n        number: manifest.build_version,\n        vcs_revision: manifest.build_git_revision,\n        build_agent: {\n          name: \"omnibus\",\n          version: Omnibus::VERSION,\n        },\n        modules: [\n          {\n            # com.getchef:chef-server:12.0.0\n            id: [\n              Config.artifactory_base_path.tr(\"/\", \".\"),\n              name,\n              manifest.build_version,\n            ].join(\":\"),\n            artifacts: packages.map do |package|\n              [\n                {\n                  type: File.extname(package.path).split(\".\").last,\n                  sha1: package.metadata[:sha1],\n                  md5: package.metadata[:md5],\n                  name: package.metadata[:basename],\n                },\n                {\n                  type: File.extname(package.metadata.path).split(\".\").last,\n                  sha1: digest(package.metadata.path, :sha1),\n                  md5: digest(package.metadata.path, :md5),\n                  name: File.basename(package.metadata.path),\n                },\n              ]\n            end.flatten,\n          },\n        ]\n      )\n    end", "language": "ruby", "code": "def build_for(packages)\n      metadata = packages.first.metadata\n      name     = metadata[:name]\n\n      # Attempt to load the version manifest data from the packages metadata\n      manifest = if version_manifest = metadata[:version_manifest]\n                   Manifest.from_hash(version_manifest)\n                 else\n                   Manifest.new(\n                     metadata[:version],\n                     # we already know the `version_manifest` entry is\n                     # missing so we can't pull in the `build_git_revision`\n                     nil,\n                     metadata[:license]\n                   )\n                 end\n\n      # Upload the actual package\n      log.info(log_key) { \"Saving build info for #{name}, Build ##{manifest.build_version}\" }\n\n      Artifactory::Resource::Build.new(\n        client: client,\n        name:   name,\n        number: manifest.build_version,\n        vcs_revision: manifest.build_git_revision,\n        build_agent: {\n          name: \"omnibus\",\n          version: Omnibus::VERSION,\n        },\n        modules: [\n          {\n            # com.getchef:chef-server:12.0.0\n            id: [\n              Config.artifactory_base_path.tr(\"/\", \".\"),\n              name,\n              manifest.build_version,\n            ].join(\":\"),\n            artifacts: packages.map do |package|\n              [\n                {\n                  type: File.extname(package.path).split(\".\").last,\n                  sha1: package.metadata[:sha1],\n                  md5: package.metadata[:md5],\n                  name: package.metadata[:basename],\n                },\n                {\n                  type: File.extname(package.metadata.path).split(\".\").last,\n                  sha1: digest(package.metadata.path, :sha1),\n                  md5: digest(package.metadata.path, :md5),\n                  name: File.basename(package.metadata.path),\n                },\n              ]\n            end.flatten,\n          },\n        ]\n      )\n    end", "code_tokens": ["def", "build_for", "(", "packages", ")", "metadata", "=", "packages", ".", "first", ".", "metadata", "name", "=", "metadata", "[", ":name", "]", "# Attempt to load the version manifest data from the packages metadata", "manifest", "=", "if", "version_manifest", "=", "metadata", "[", ":version_manifest", "]", "Manifest", ".", "from_hash", "(", "version_manifest", ")", "else", "Manifest", ".", "new", "(", "metadata", "[", ":version", "]", ",", "# we already know the `version_manifest` entry is", "# missing so we can't pull in the `build_git_revision`", "nil", ",", "metadata", "[", ":license", "]", ")", "end", "# Upload the actual package", "log", ".", "info", "(", "log_key", ")", "{", "\"Saving build info for #{name}, Build ##{manifest.build_version}\"", "}", "Artifactory", "::", "Resource", "::", "Build", ".", "new", "(", "client", ":", "client", ",", "name", ":", "name", ",", "number", ":", "manifest", ".", "build_version", ",", "vcs_revision", ":", "manifest", ".", "build_git_revision", ",", "build_agent", ":", "{", "name", ":", "\"omnibus\"", ",", "version", ":", "Omnibus", "::", "VERSION", ",", "}", ",", "modules", ":", "[", "{", "# com.getchef:chef-server:12.0.0", "id", ":", "[", "Config", ".", "artifactory_base_path", ".", "tr", "(", "\"/\"", ",", "\".\"", ")", ",", "name", ",", "manifest", ".", "build_version", ",", "]", ".", "join", "(", "\":\"", ")", ",", "artifacts", ":", "packages", ".", "map", "do", "|", "package", "|", "[", "{", "type", ":", "File", ".", "extname", "(", "package", ".", "path", ")", ".", "split", "(", "\".\"", ")", ".", "last", ",", "sha1", ":", "package", ".", "metadata", "[", ":sha1", "]", ",", "md5", ":", "package", ".", "metadata", "[", ":md5", "]", ",", "name", ":", "package", ".", "metadata", "[", ":basename", "]", ",", "}", ",", "{", "type", ":", "File", ".", "extname", "(", "package", ".", "metadata", ".", "path", ")", ".", "split", "(", "\".\"", ")", ".", "last", ",", "sha1", ":", "digest", "(", "package", ".", "metadata", ".", "path", ",", ":sha1", ")", ",", "md5", ":", "digest", "(", "package", ".", "metadata", ".", "path", ",", ":md5", ")", ",", "name", ":", "File", ".", "basename", "(", "package", ".", "metadata", ".", "path", ")", ",", "}", ",", "]", "end", ".", "flatten", ",", "}", ",", "]", ")", "end"], "docstring": "The build object that corresponds to this package.\n\n @param [Array<Package>] packages\n   the packages to create the build from\n\n @return [Artifactory::Resource::Build]", "docstring_tokens": ["The", "build", "object", "that", "corresponds", "to", "this", "package", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/publishers/artifactory_publisher.rb#L112-L168", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/publishers/artifactory_publisher.rb", "func_name": "Omnibus.ArtifactoryPublisher.client", "original_string": "def client\n      @client ||= Artifactory::Client.new(\n        endpoint:       Config.artifactory_endpoint,\n        username:       Config.artifactory_username,\n        password:       Config.artifactory_password,\n        ssl_pem_file:   Config.artifactory_ssl_pem_file,\n        ssl_verify:     Config.artifactory_ssl_verify,\n        proxy_username: Config.artifactory_proxy_username,\n        proxy_password: Config.artifactory_proxy_password,\n        proxy_address:  Config.artifactory_proxy_address,\n        proxy_port:     Config.artifactory_proxy_port\n      )\n    end", "language": "ruby", "code": "def client\n      @client ||= Artifactory::Client.new(\n        endpoint:       Config.artifactory_endpoint,\n        username:       Config.artifactory_username,\n        password:       Config.artifactory_password,\n        ssl_pem_file:   Config.artifactory_ssl_pem_file,\n        ssl_verify:     Config.artifactory_ssl_verify,\n        proxy_username: Config.artifactory_proxy_username,\n        proxy_password: Config.artifactory_proxy_password,\n        proxy_address:  Config.artifactory_proxy_address,\n        proxy_port:     Config.artifactory_proxy_port\n      )\n    end", "code_tokens": ["def", "client", "@client", "||=", "Artifactory", "::", "Client", ".", "new", "(", "endpoint", ":", "Config", ".", "artifactory_endpoint", ",", "username", ":", "Config", ".", "artifactory_username", ",", "password", ":", "Config", ".", "artifactory_password", ",", "ssl_pem_file", ":", "Config", ".", "artifactory_ssl_pem_file", ",", "ssl_verify", ":", "Config", ".", "artifactory_ssl_verify", ",", "proxy_username", ":", "Config", ".", "artifactory_proxy_username", ",", "proxy_password", ":", "Config", ".", "artifactory_proxy_password", ",", "proxy_address", ":", "Config", ".", "artifactory_proxy_address", ",", "proxy_port", ":", "Config", ".", "artifactory_proxy_port", ")", "end"], "docstring": "The Artifactory client object to communicate with the Artifactory API.\n\n @return [Artifactory::Client]", "docstring_tokens": ["The", "Artifactory", "client", "object", "to", "communicate", "with", "the", "Artifactory", "API", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/publishers/artifactory_publisher.rb#L190-L202", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/packagers/msi.rb", "func_name": "Omnibus.Packager::MSI.upgrade_code", "original_string": "def upgrade_code(val = NULL)\n      if null?(val)\n        @upgrade_code || raise(MissingRequiredAttribute.new(self, :upgrade_code, \"2CD7259C-776D-4DDB-A4C8-6E544E580AA1\"))\n      else\n        unless val.is_a?(String)\n          raise InvalidValue.new(:upgrade_code, \"be a String\")\n        end\n\n        @upgrade_code = val\n      end\n    end", "language": "ruby", "code": "def upgrade_code(val = NULL)\n      if null?(val)\n        @upgrade_code || raise(MissingRequiredAttribute.new(self, :upgrade_code, \"2CD7259C-776D-4DDB-A4C8-6E544E580AA1\"))\n      else\n        unless val.is_a?(String)\n          raise InvalidValue.new(:upgrade_code, \"be a String\")\n        end\n\n        @upgrade_code = val\n      end\n    end", "code_tokens": ["def", "upgrade_code", "(", "val", "=", "NULL", ")", "if", "null?", "(", "val", ")", "@upgrade_code", "||", "raise", "(", "MissingRequiredAttribute", ".", "new", "(", "self", ",", ":upgrade_code", ",", "\"2CD7259C-776D-4DDB-A4C8-6E544E580AA1\"", ")", ")", "else", "unless", "val", ".", "is_a?", "(", "String", ")", "raise", "InvalidValue", ".", "new", "(", ":upgrade_code", ",", "\"be a String\"", ")", "end", "@upgrade_code", "=", "val", "end", "end"], "docstring": "@!group DSL methods\n --------------------------------------------------\n\n Set or retrieve the upgrade code.\n\n @example\n   upgrade_code 'ABCD-1234'\n\n @param [Hash] val\n   the UpgradeCode to set\n\n @return [Hash]\n   the set UpgradeCode", "docstring_tokens": ["@!group", "DSL", "methods", "--------------------------------------------------"], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/packagers/msi.rb#L108-L118", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/packagers/msi.rb", "func_name": "Omnibus.Packager::MSI.parameters", "original_string": "def parameters(val = NULL)\n      if null?(val)\n        @parameters || {}\n      else\n        unless val.is_a?(Hash)\n          raise InvalidValue.new(:parameters, \"be a Hash\")\n        end\n\n        @parameters = val\n      end\n    end", "language": "ruby", "code": "def parameters(val = NULL)\n      if null?(val)\n        @parameters || {}\n      else\n        unless val.is_a?(Hash)\n          raise InvalidValue.new(:parameters, \"be a Hash\")\n        end\n\n        @parameters = val\n      end\n    end", "code_tokens": ["def", "parameters", "(", "val", "=", "NULL", ")", "if", "null?", "(", "val", ")", "@parameters", "||", "{", "}", "else", "unless", "val", ".", "is_a?", "(", "Hash", ")", "raise", "InvalidValue", ".", "new", "(", ":parameters", ",", "\"be a Hash\"", ")", "end", "@parameters", "=", "val", "end", "end"], "docstring": "Set or retrieve the custom msi building parameters.\n\n @example\n   parameters {\n     'MagicParam' => 'ABCD-1234'\n   }\n\n @param [Hash] val\n   the parameters to set\n\n @return [Hash]\n   the set parameters", "docstring_tokens": ["Set", "or", "retrieve", "the", "custom", "msi", "building", "parameters", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/packagers/msi.rb#L135-L145", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/packagers/msi.rb", "func_name": "Omnibus.Packager::MSI.wix_light_extension", "original_string": "def wix_light_extension(extension)\n      unless extension.is_a?(String)\n        raise InvalidValue.new(:wix_light_extension, \"be an String\")\n      end\n\n      wix_light_extensions << extension\n    end", "language": "ruby", "code": "def wix_light_extension(extension)\n      unless extension.is_a?(String)\n        raise InvalidValue.new(:wix_light_extension, \"be an String\")\n      end\n\n      wix_light_extensions << extension\n    end", "code_tokens": ["def", "wix_light_extension", "(", "extension", ")", "unless", "extension", ".", "is_a?", "(", "String", ")", "raise", "InvalidValue", ".", "new", "(", ":wix_light_extension", ",", "\"be an String\"", ")", "end", "wix_light_extensions", "<<", "extension", "end"], "docstring": "Set the wix light extensions to load\n\n @example\n   wix_light_extension 'WixUtilExtension'\n\n @param [String] extension\n   A list of extensions to load\n\n @return [Array]\n   The list of extensions that will be loaded", "docstring_tokens": ["Set", "the", "wix", "light", "extensions", "to", "load"], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/packagers/msi.rb#L160-L166", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/build_version_dsl.rb", "func_name": "Omnibus.BuildVersionDSL.resolve", "original_string": "def resolve(dependency)\n      if from_dependency? && version_dependency == dependency.name\n        construct_build_version(dependency)\n        log.info(log_key) { \"Build Version is set to '#{build_version}'\" }\n      end\n    end", "language": "ruby", "code": "def resolve(dependency)\n      if from_dependency? && version_dependency == dependency.name\n        construct_build_version(dependency)\n        log.info(log_key) { \"Build Version is set to '#{build_version}'\" }\n      end\n    end", "code_tokens": ["def", "resolve", "(", "dependency", ")", "if", "from_dependency?", "&&", "version_dependency", "==", "dependency", ".", "name", "construct_build_version", "(", "dependency", ")", "log", ".", "info", "(", "log_key", ")", "{", "\"Build Version is set to '#{build_version}'\"", "}", "end", "end"], "docstring": "Callback that is called by software objects to determine the version.\n\n @param dependency [Omnibus::Software] Software object that is making the callback.\n @return [void]", "docstring_tokens": ["Callback", "that", "is", "called", "by", "software", "objects", "to", "determine", "the", "version", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/build_version_dsl.rb#L70-L75", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/build_version_dsl.rb", "func_name": "Omnibus.BuildVersionDSL.maybe_append_timestamp", "original_string": "def maybe_append_timestamp(version)\n      if Config.append_timestamp && !has_timestamp?(version)\n        [version, Omnibus::BuildVersion.build_start_time].join(\"+\")\n      else\n        version\n      end\n    end", "language": "ruby", "code": "def maybe_append_timestamp(version)\n      if Config.append_timestamp && !has_timestamp?(version)\n        [version, Omnibus::BuildVersion.build_start_time].join(\"+\")\n      else\n        version\n      end\n    end", "code_tokens": ["def", "maybe_append_timestamp", "(", "version", ")", "if", "Config", ".", "append_timestamp", "&&", "!", "has_timestamp?", "(", "version", ")", "[", "version", ",", "Omnibus", "::", "BuildVersion", ".", "build_start_time", "]", ".", "join", "(", "\"+\"", ")", "else", "version", "end", "end"], "docstring": "Append the build_start_time to the given string if\n Config.append_timestamp is true\n\n @param [String] version\n @return [String]", "docstring_tokens": ["Append", "the", "build_start_time", "to", "the", "given", "string", "if", "Config", ".", "append_timestamp", "is", "true"], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/build_version_dsl.rb#L119-L125", "partition": "test"}
{"repo": "chef/omnibus", "path": "lib/omnibus/build_version_dsl.rb", "func_name": "Omnibus.BuildVersionDSL.has_timestamp?", "original_string": "def has_timestamp?(version)\n      _ver, build_info = version.split(\"+\")\n      return false if build_info.nil?\n      build_info.split(\".\").any? do |part|\n        begin\n          Time.strptime(part, Omnibus::BuildVersion::TIMESTAMP_FORMAT)\n          true\n        rescue ArgumentError\n          false\n        end\n      end\n    end", "language": "ruby", "code": "def has_timestamp?(version)\n      _ver, build_info = version.split(\"+\")\n      return false if build_info.nil?\n      build_info.split(\".\").any? do |part|\n        begin\n          Time.strptime(part, Omnibus::BuildVersion::TIMESTAMP_FORMAT)\n          true\n        rescue ArgumentError\n          false\n        end\n      end\n    end", "code_tokens": ["def", "has_timestamp?", "(", "version", ")", "_ver", ",", "build_info", "=", "version", ".", "split", "(", "\"+\"", ")", "return", "false", "if", "build_info", ".", "nil?", "build_info", ".", "split", "(", "\".\"", ")", ".", "any?", "do", "|", "part", "|", "begin", "Time", ".", "strptime", "(", "part", ",", "Omnibus", "::", "BuildVersion", "::", "TIMESTAMP_FORMAT", ")", "true", "rescue", "ArgumentError", "false", "end", "end", "end"], "docstring": "Returns true if a given version string Looks like it was already\n created with a function that added a timestamp. The goal of this\n is to avoid breaking all of the people who are currently using\n BuildVersion.semver to create dates.\n\n @param [String] version\n @return [Boolean]", "docstring_tokens": ["Returns", "true", "if", "a", "given", "version", "string", "Looks", "like", "it", "was", "already", "created", "with", "a", "function", "that", "added", "a", "timestamp", ".", "The", "goal", "of", "this", "is", "to", "avoid", "breaking", "all", "of", "the", "people", "who", "are", "currently", "using", "BuildVersion", ".", "semver", "to", "create", "dates", "."], "sha": "968307c129ee54416f5a4d07ca8f8ca2d2b12825", "url": "https://github.com/chef/omnibus/blob/968307c129ee54416f5a4d07ca8f8ca2d2b12825/lib/omnibus/build_version_dsl.rb#L134-L145", "partition": "test"}
